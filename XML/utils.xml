<directory_structure>
src/
  date_utils/
    core.rs
    formatting.rs
    mod.rs
    parsing.rs
    periods.rs
  file_patterns/
    mod.rs
  pnr_utils/
    generation.rs
    mod.rs
    types.rs
    validation.rs
  string_utils/
    case_conversion.rs
    formatting.rs
    mod.rs
    parsing.rs
  config.rs
  date.rs
  error.rs
  lib.rs
  logging.rs
  rich_console.rs
  string.rs
Cargo.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/date_utils/core.rs">
//! Core date utilities and traits.
//!
//! This module provides the core date utility traits and functions that form
//! the foundation of the date utility system.

use crate::error::{validation_error, Result};
use chrono::{Datelike, NaiveDate};

/// Date utilities trait providing common date operations
pub trait DateUtils {
    /// Calculate the age at a reference date
    ///
    /// # Arguments
    /// * `birth_date` - The birth date
    /// * `reference_date` - The reference date to calculate age at
    ///
    /// # Returns
    /// The age in years
    fn age_at(birth_date: NaiveDate, reference_date: NaiveDate) -> u32;

    /// Get the quarter (1-4) for a given date
    ///
    /// # Arguments
    /// * `date` - The date
    ///
    /// # Returns
    /// The quarter (1-4)
    fn quarter_from_date(date: NaiveDate) -> u32;

    /// Check if a year is a leap year
    ///
    /// # Arguments
    /// * `year` - The year to check
    ///
    /// # Returns
    /// `true` if the year is a leap year, `false` otherwise
    fn is_leap_year(year: i32) -> bool;

    /// Get the days in a month
    ///
    /// # Arguments
    /// * `year` - The year
    /// * `month` - The month (1-12)
    ///
    /// # Returns
    /// The number of days in the month
    fn days_in_month(year: i32, month: u32) -> u32;

    /// Create a date from year, month, and day
    ///
    /// # Arguments
    /// * `year` - The year
    /// * `month` - The month (1-12)
    /// * `day` - The day (1-31)
    ///
    /// # Returns
    /// A Result containing the date or an error if the date is invalid
    fn create_date(year: i32, month: u32, day: u32) -> Result<NaiveDate>;
}

/// Implementation of `DateUtils`
pub struct DateUtilsImpl;

impl DateUtils for DateUtilsImpl {
    fn age_at(birth_date: NaiveDate, reference_date: NaiveDate) -> u32 {
        let years = reference_date.year() - birth_date.year();

        if reference_date.month() < birth_date.month()
            || (reference_date.month() == birth_date.month()
                && reference_date.day() < birth_date.day())
        {
            (years - 1) as u32
        } else {
            years as u32
        }
    }

    fn quarter_from_date(date: NaiveDate) -> u32 {
        ((date.month() - 1) / 3) + 1
    }

    fn is_leap_year(year: i32) -> bool {
        (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
    }

    fn days_in_month(year: i32, month: u32) -> u32 {
        match month {
            2 => {
                if Self::is_leap_year(year) {
                    29
                } else {
                    28
                }
            }
            4 | 6 | 9 | 11 => 30,
            1 | 3 | 5 | 7 | 8 | 10 | 12 => 31,
            _ => 0, // Invalid month
        }
    }

    fn create_date(year: i32, month: u32, day: u32) -> Result<NaiveDate> {
        NaiveDate::from_ymd_opt(year, month, day)
            .ok_or_else(|| validation_error(format!("Invalid date: {year}-{month}-{day}")))
    }
}

/// Comprehensive trait for date-related helpers with consistent error handling
pub trait DateHelpers {
    /// Convert to `NaiveDate`
    ///
    /// # Returns
    /// * `Result<NaiveDate>` - The date as a `NaiveDate` or an error
    ///
    /// # Errors
    /// Returns an error if the conversion fails
    fn to_naive_date(&self) -> Result<NaiveDate>;

    /// Get year from date
    ///
    /// # Returns
    /// * `Result<i32>` - The year as an i32 or an error
    ///
    /// # Errors
    /// Returns an error if the conversion to `NaiveDate` fails
    fn year(&self) -> Result<i32>;

    /// Calculate age at a reference date
    ///
    /// # Arguments
    /// * `reference_date` - The date at which to calculate the age
    ///
    /// # Returns
    /// * `Result<u32>` - The age in years or an error
    ///
    /// # Errors
    /// Returns an error if:
    /// - The conversion to `NaiveDate` fails
    /// - The calculation yields an invalid age (e.g., negative)
    fn age_at(&self, reference_date: &NaiveDate) -> Result<u32>;

    /// Check if date is in a specific year
    ///
    /// # Arguments
    /// * `year` - The year to check against
    ///
    /// # Returns
    /// * `Result<bool>` - True if the date is in the specified year, false otherwise
    ///
    /// # Errors
    /// Returns an error if the conversion to `NaiveDate` fails
    fn is_in_year(&self, year: i32) -> Result<bool>;

    /// Get month from date
    ///
    /// # Returns
    /// * `Result<u32>` - The month as a u32 (1-12) or an error
    ///
    /// # Errors
    /// Returns an error if the conversion to `NaiveDate` fails
    fn month(&self) -> Result<u32>;

    /// Get day from date
    ///
    /// # Returns
    /// * `Result<u32>` - The day as a u32 (1-31) or an error
    ///
    /// # Errors
    /// Returns an error if the conversion to `NaiveDate` fails
    fn day(&self) -> Result<u32>;

    /// Get the quarter (1-4) for this date
    ///
    /// # Returns
    /// * `Result<u32>` - The quarter (1-4) or an error
    ///
    /// # Errors
    /// Returns an error if the conversion to `NaiveDate` fails
    fn quarter(&self) -> Result<u32> {
        Ok(((self.month()? - 1) / 3) + 1)
    }
}

// Implementation of DateHelpers is provided in the original files and will be adapted
// This file contains just the trait definition for now

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_quarter_from_date() {
        let date1 = NaiveDate::from_ymd_opt(2023, 1, 15).unwrap();
        let date2 = NaiveDate::from_ymd_opt(2023, 4, 15).unwrap();
        let date3 = NaiveDate::from_ymd_opt(2023, 7, 15).unwrap();
        let date4 = NaiveDate::from_ymd_opt(2023, 10, 15).unwrap();

        assert_eq!(DateUtilsImpl::quarter_from_date(date1), 1);
        assert_eq!(DateUtilsImpl::quarter_from_date(date2), 2);
        assert_eq!(DateUtilsImpl::quarter_from_date(date3), 3);
        assert_eq!(DateUtilsImpl::quarter_from_date(date4), 4);
    }

    #[test]
    fn test_age_at() {
        let birth_date = NaiveDate::from_ymd_opt(1990, 6, 15).unwrap();
        let before_birthday = NaiveDate::from_ymd_opt(2023, 6, 14).unwrap();
        let on_birthday = NaiveDate::from_ymd_opt(2023, 6, 15).unwrap();
        let after_birthday = NaiveDate::from_ymd_opt(2023, 6, 16).unwrap();

        assert_eq!(DateUtilsImpl::age_at(birth_date, before_birthday), 32);
        assert_eq!(DateUtilsImpl::age_at(birth_date, on_birthday), 33);
        assert_eq!(DateUtilsImpl::age_at(birth_date, after_birthday), 33);
    }

    #[test]
    fn test_is_leap_year() {
        assert!(!DateUtilsImpl::is_leap_year(1900));
        assert!(DateUtilsImpl::is_leap_year(2000));
        assert!(DateUtilsImpl::is_leap_year(2004));
        assert!(!DateUtilsImpl::is_leap_year(2023));
    }

    #[test]
    fn test_days_in_month() {
        assert_eq!(DateUtilsImpl::days_in_month(2023, 1), 31);
        assert_eq!(DateUtilsImpl::days_in_month(2023, 2), 28);
        assert_eq!(DateUtilsImpl::days_in_month(2024, 2), 29);
        assert_eq!(DateUtilsImpl::days_in_month(2023, 4), 30);
    }

    #[test]
    fn test_create_date() {
        assert!(DateUtilsImpl::create_date(2023, 1, 31).is_ok());
        assert!(DateUtilsImpl::create_date(2023, 2, 31).is_err());
    }
}
</file>

<file path="src/date_utils/formatting.rs">
//! Date formatting utilities.
//!
//! This module provides utilities for formatting dates in various formats.

use chrono::NaiveDate;

/// Trait for date formatting operations
pub trait DateFormattingUtils {
    /// Format a date as a string
    ///
    /// # Arguments
    /// * `date` - The date to format
    /// * `format` - The format string to use (defaults to "%Y-%m-%d")
    ///
    /// # Returns
    /// A string containing the formatted date
    fn format_date(date: NaiveDate, format: Option<&str>) -> String;

    /// Format an optional date as a string
    ///
    /// # Arguments
    /// * `date` - The optional date to format
    /// * `format` - The format string to use (defaults to "%Y-%m-%d")
    /// * `null_placeholder` - The placeholder to use for null dates (defaults to "N/A")
    ///
    /// # Returns
    /// A string containing the formatted date or the null placeholder
    fn format_optional_date(
        date: Option<NaiveDate>,
        format: Option<&str>,
        null_placeholder: Option<&str>,
    ) -> String;
}

/// Implementation of `DateFormattingUtils`
pub struct DateFormattingUtilsImpl;

impl DateFormattingUtils for DateFormattingUtilsImpl {
    fn format_date(date: NaiveDate, format: Option<&str>) -> String {
        let format_str = format.unwrap_or("%Y-%m-%d");
        date.format(format_str).to_string()
    }

    fn format_optional_date(
        date: Option<NaiveDate>,
        format: Option<&str>,
        null_placeholder: Option<&str>,
    ) -> String {
        let format_str = format.unwrap_or("%Y-%m-%d");
        let placeholder = null_placeholder.unwrap_or("N/A");

        match date {
            Some(d) => d.format(format_str).to_string(),
            None => placeholder.to_string(),
        }
    }
}

/// Formats a date as a string in the specified format.
///
/// # Parameters
///
/// * `date` - The date to format
/// * `format` - The format string to use (defaults to "%Y-%m-%d")
///
/// # Returns
///
/// A string containing the formatted date.
///
/// # Errors
///
/// This function will not error, but will return a placeholder string
/// if the date is None.
#[must_use] pub fn format_date(date: Option<NaiveDate>, format: Option<&str>) -> String {
    let format_str = format.unwrap_or("%Y-%m-%d");
    match date {
        Some(d) => d.format(format_str).to_string(),
        None => "N/A".to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_format_date() {
        let date = NaiveDate::from_ymd_opt(2023, 1, 31).unwrap();

        assert_eq!(
            DateFormattingUtilsImpl::format_date(date, None),
            "2023-01-31"
        );
        assert_eq!(
            DateFormattingUtilsImpl::format_date(date, Some("%d/%m/%Y")),
            "31/01/2023"
        );
        assert_eq!(
            DateFormattingUtilsImpl::format_date(date, Some("%Y%m%d")),
            "20230131"
        );
    }

    #[test]
    fn test_format_optional_date() {
        let date = NaiveDate::from_ymd_opt(2023, 1, 31);

        assert_eq!(
            DateFormattingUtilsImpl::format_optional_date(date, None, None),
            "2023-01-31"
        );
        assert_eq!(
            DateFormattingUtilsImpl::format_optional_date(None, None, None),
            "N/A"
        );
        assert_eq!(
            DateFormattingUtilsImpl::format_optional_date(None, None, Some("Unknown")),
            "Unknown"
        );
    }

    #[test]
    fn test_format_date_function() {
        let date = NaiveDate::from_ymd_opt(2023, 1, 31);

        assert_eq!(format_date(date, None), "2023-01-31");
        assert_eq!(format_date(None, None), "N/A");
        assert_eq!(format_date(date, Some("%d/%m/%Y")), "31/01/2023");
    }
}
</file>

<file path="src/date_utils/mod.rs">
//! Consolidated date handling utilities.
//!
//! This module provides various functions and traits for working with dates,
//! including parsing, formatting, manipulation, and calculation of various date
//! properties like age, quarter, etc.
//!
//! It consolidates functionality previously scattered across multiple modules
//! into a single, comprehensive implementation that can be used throughout the
//! codebase.

pub mod core;
pub mod formatting;
pub mod parsing;
pub mod periods;

pub use core::*;
pub use formatting::*;
pub use parsing::*;
pub use periods::*;

// Re-export core types and traits for convenience
pub use crate::error::Result;
pub use chrono::{Datelike, Duration, NaiveDate};
</file>

<file path="src/date_utils/parsing.rs">
//! Date parsing utilities.
//!
//! This module provides utilities for parsing dates in various formats.

use crate::error::{date_parse_error, validation_error, Result};
use chrono::NaiveDate;

/// Trait for date parsing operations
pub trait DateParsingUtils {
    /// Parse a date string in various formats (YMD, DMY, etc.)
    ///
    /// # Arguments
    /// * `date_str` - The date string to parse
    ///
    /// # Returns
    /// A Result containing the parsed date or an error
    fn parse_flexible(date_str: &str) -> Result<NaiveDate>;

    /// Parse a date string in ISO format (YYYY-MM-DD)
    ///
    /// # Arguments
    /// * `date_str` - The date string to parse
    ///
    /// # Returns
    /// A Result containing the parsed date or an error
    fn parse_iso(date_str: &str) -> Result<NaiveDate>;

    /// Parse a year string into an i32
    ///
    /// # Arguments
    /// * `year_str` - The year string to parse
    ///
    /// # Returns
    /// A Result containing the parsed year or an error
    fn parse_year(year_str: &str) -> Result<i32>;

    /// Parse a period string (YYYYMM) into a date
    ///
    /// # Arguments
    /// * `period_str` - The period string to parse
    ///
    /// # Returns
    /// A Result containing the parsed date (first day of the month) or an error
    fn parse_period(period_str: &str) -> Result<NaiveDate>;
}

/// Implementation of `DateParsingUtils`
pub struct DateParsingUtilsImpl;

impl DateParsingUtils for DateParsingUtilsImpl {
    fn parse_flexible(date_str: &str) -> Result<NaiveDate> {
        // Try different date formats
        let formats = [
            "%Y-%m-%d", // ISO format (2023-01-31)
            "%d-%m-%Y", // European format (31-01-2023)
            "%d/%m/%Y", // European format with slash (31/01/2023)
            "%Y%m%d",   // Compact format (20230131)
            "%Y%m",     // Year-month (202301)
        ];

        for format in &formats {
            if let Ok(date) = NaiveDate::parse_from_str(date_str, format) {
                return Ok(date);
            }
        }

        Err(date_parse_error(format!(
            "Could not parse date: {date_str}"
        )))
    }

    fn parse_iso(date_str: &str) -> Result<NaiveDate> {
        NaiveDate::parse_from_str(date_str, "%Y-%m-%d").map_err(|e| {
            date_parse_error(format!("Failed to parse ISO date '{date_str}': {e}"))
        })
    }

    fn parse_year(year_str: &str) -> Result<i32> {
        year_str
            .parse::<i32>()
            .map_err(|e| validation_error(format!("Failed to parse year '{year_str}': {e}")))
    }

    fn parse_period(period_str: &str) -> Result<NaiveDate> {
        if period_str.len() != 6 {
            return Err(validation_error(format!(
                "Invalid period format (expected YYYYMM): {period_str}"
            )));
        }

        let year = Self::parse_year(&period_str[0..4])?;
        let month = period_str[4..6].parse::<u32>().map_err(|e| {
            validation_error(format!(
                "Failed to parse month in period '{period_str}': {e}"
            ))
        })?;

        if !(1..=12).contains(&month) {
            return Err(validation_error(format!(
                "Invalid month in period '{period_str}': {month}"
            )));
        }

        NaiveDate::from_ymd_opt(year, month, 1).ok_or_else(|| {
            validation_error(format!(
                "Invalid date for period '{period_str}': {year}-{month}-01"
            ))
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_flexible() {
        assert!(DateParsingUtilsImpl::parse_flexible("2023-01-31").is_ok());
        assert!(DateParsingUtilsImpl::parse_flexible("31-01-2023").is_ok());
        assert!(DateParsingUtilsImpl::parse_flexible("31/01/2023").is_ok());
        assert!(DateParsingUtilsImpl::parse_flexible("20230131").is_ok());
        assert!(DateParsingUtilsImpl::parse_flexible("202301").is_ok());
        assert!(DateParsingUtilsImpl::parse_flexible("invalid date").is_err());
    }

    #[test]
    fn test_parse_iso() {
        assert!(DateParsingUtilsImpl::parse_iso("2023-01-31").is_ok());
        assert!(DateParsingUtilsImpl::parse_iso("31-01-2023").is_err());
    }

    #[test]
    fn test_parse_year() {
        assert_eq!(DateParsingUtilsImpl::parse_year("2023").unwrap(), 2023);
        assert!(DateParsingUtilsImpl::parse_year("abc").is_err());
    }

    #[test]
    fn test_parse_period() {
        let date = DateParsingUtilsImpl::parse_period("202301").unwrap();
        assert_eq!(date, NaiveDate::from_ymd_opt(2023, 1, 1).unwrap());

        assert!(DateParsingUtilsImpl::parse_period("20231").is_err());
        assert!(DateParsingUtilsImpl::parse_period("202313").is_err());
    }
}
</file>

<file path="src/date_utils/periods.rs">
//! Date period utilities.
//!
//! This module provides utilities for working with date periods, including
//! functions to find the start/end of quarters, years, etc.

use crate::date_utils::core::{DateUtils, DateUtilsImpl};
use chrono::{Datelike, NaiveDate};

/// Trait for date period operations
pub trait DatePeriodUtils {
    /// Get start date of quarter for a given date
    ///
    /// # Arguments
    /// * `date` - The date
    ///
    /// # Returns
    /// The start date of the quarter
    fn start_of_quarter(date: NaiveDate) -> NaiveDate;

    /// Get end date of quarter for a given date
    ///
    /// # Arguments
    /// * `date` - The date
    ///
    /// # Returns
    /// The end date of the quarter
    fn end_of_quarter(date: NaiveDate) -> NaiveDate;

    /// Get start date of year for a given date
    ///
    /// # Arguments
    /// * `date` - The date
    ///
    /// # Returns
    /// The start date of the year
    fn start_of_year(date: NaiveDate) -> NaiveDate;

    /// Get end date of year for a given date
    ///
    /// # Arguments
    /// * `date` - The date
    ///
    /// # Returns
    /// The end date of the year
    fn end_of_year(date: NaiveDate) -> NaiveDate;

    /// Convert a date to a period string (YYYYMM format)
    ///
    /// # Arguments
    /// * `date` - The date
    ///
    /// # Returns
    /// The period string in YYYYMM format
    fn to_period_string(date: NaiveDate) -> String;

    /// Convert a date to a year string (YYYY format)
    ///
    /// # Arguments
    /// * `date` - The date
    ///
    /// # Returns
    /// The year string in YYYY format
    fn to_year_string(date: NaiveDate) -> String;
}

/// Implementation of `DatePeriodUtils`
pub struct DatePeriodUtilsImpl;

impl DatePeriodUtils for DatePeriodUtilsImpl {
    fn start_of_quarter(date: NaiveDate) -> NaiveDate {
        let quarter = DateUtilsImpl::quarter_from_date(date);
        let month = ((quarter - 1) * 3) + 1;

        NaiveDate::from_ymd_opt(date.year(), month, 1)
            .unwrap_or_else(|| NaiveDate::from_ymd_opt(date.year(), 1, 1).unwrap())
    }

    fn end_of_quarter(date: NaiveDate) -> NaiveDate {
        let quarter = DateUtilsImpl::quarter_from_date(date);
        let month = quarter * 3;
        let days = DateUtilsImpl::days_in_month(date.year(), month);

        NaiveDate::from_ymd_opt(date.year(), month, days)
            .unwrap_or_else(|| NaiveDate::from_ymd_opt(date.year(), 12, 31).unwrap())
    }

    fn start_of_year(date: NaiveDate) -> NaiveDate {
        NaiveDate::from_ymd_opt(date.year(), 1, 1).unwrap_or(date)
    }

    fn end_of_year(date: NaiveDate) -> NaiveDate {
        NaiveDate::from_ymd_opt(date.year(), 12, 31).unwrap_or(date)
    }

    fn to_period_string(date: NaiveDate) -> String {
        format!("{}{:02}", date.year(), date.month())
    }

    fn to_year_string(date: NaiveDate) -> String {
        date.year().to_string()
    }
}

/// Extract a period (YYYYMM or YYYY) from a filename
///
/// # Arguments
/// * `filename` - The filename to extract the period from
///
/// # Returns
/// An Option containing the period string, or None if no period was found
#[must_use] pub fn extract_period_from_filename(filename: &str) -> Option<String> {
    // Match YYYYMM pattern (e.g., 202301)
    let re_period = regex::Regex::new(r"(?:^|[^\d])(\d{6})(?:[^\d]|$)").ok()?;
    if let Some(cap) = re_period.captures(filename) {
        return cap.get(1).map(|m| m.as_str().to_string());
    }

    // Match YYYY pattern (e.g., 2023)
    let re_year = regex::Regex::new(r"(?:^|[^\d])(\d{4})(?:[^\d]|$)").ok()?;
    if let Some(cap) = re_year.captures(filename) {
        return cap.get(1).map(|m| m.as_str().to_string());
    }

    None
}

/// Extract a year from a filename
///
/// # Arguments
/// * `filename` - The filename to extract the year from
///
/// # Returns
/// An Option containing the year as an i32, or None if no year was found
#[must_use] pub fn extract_year_from_filename(filename: &str) -> Option<i32> {
    let period = extract_period_from_filename(filename)?;

    // If we have a 6-digit period (YYYYMM), extract the year part
    if period.len() == 6 {
        return period[0..4].parse::<i32>().ok();
    }

    // Otherwise, assume it's already a year
    period.parse::<i32>().ok()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_start_and_end_of_quarter() {
        let date = NaiveDate::from_ymd_opt(2023, 2, 15).unwrap();

        let start = DatePeriodUtilsImpl::start_of_quarter(date);
        let end = DatePeriodUtilsImpl::end_of_quarter(date);

        assert_eq!(start, NaiveDate::from_ymd_opt(2023, 1, 1).unwrap());
        assert_eq!(end, NaiveDate::from_ymd_opt(2023, 3, 31).unwrap());
    }

    #[test]
    fn test_start_and_end_of_year() {
        let date = NaiveDate::from_ymd_opt(2023, 6, 15).unwrap();

        let start = DatePeriodUtilsImpl::start_of_year(date);
        let end = DatePeriodUtilsImpl::end_of_year(date);

        assert_eq!(start, NaiveDate::from_ymd_opt(2023, 1, 1).unwrap());
        assert_eq!(end, NaiveDate::from_ymd_opt(2023, 12, 31).unwrap());
    }

    #[test]
    fn test_to_period_string() {
        let date = NaiveDate::from_ymd_opt(2023, 1, 15).unwrap();
        assert_eq!(DatePeriodUtilsImpl::to_period_string(date), "202301");

        let date = NaiveDate::from_ymd_opt(2023, 12, 31).unwrap();
        assert_eq!(DatePeriodUtilsImpl::to_period_string(date), "202312");
    }

    #[test]
    fn test_extract_period_from_filename() {
        assert_eq!(
            extract_period_from_filename("data_202301.csv"),
            Some("202301".to_string())
        );
        assert_eq!(
            extract_period_from_filename("data_2023.csv"),
            Some("2023".to_string())
        );
        assert_eq!(extract_period_from_filename("data.csv"), None);
    }

    #[test]
    fn test_extract_year_from_filename() {
        assert_eq!(extract_year_from_filename("data_202301.csv"), Some(2023));
        assert_eq!(extract_year_from_filename("data_2023.csv"), Some(2023));
        assert_eq!(extract_year_from_filename("data.csv"), None);
    }
}
</file>

<file path="src/file_patterns/mod.rs">
//! File pattern utilities for finding and categorizing files.
//!
//! This module provides utilities for working with file patterns, including
//! finding files that match specific patterns, detecting register types, and
//! organizing files into groups.

use regex::Regex;
use std::collections::HashMap;
use std::io;
use std::path::{Path, PathBuf};

/// Find a parquet file by name in a list of base directories
///
/// # Arguments
/// * `base_paths` - The base directories to search in
/// * `filename` - The filename to search for
///
/// # Returns
/// A Result containing the full path to the found file, or an error if not found
pub fn find_parquet_file(base_paths: &[&Path], filename: &str) -> Result<PathBuf, io::Error> {
    // Ensure filename ends with .parquet
    let file_to_find = if filename.ends_with(".parquet") {
        filename.to_string()
    } else {
        format!("{filename}.parquet")
    };

    for base_path in base_paths {
        let full_path = base_path.join(&file_to_find);
        if full_path.exists() {
            return Ok(full_path);
        }
    }

    Err(io::Error::new(
        io::ErrorKind::NotFound,
        format!("File not found: {filename}"),
    ))
}

/// Find all parquet files in a directory that match a pattern
///
/// # Arguments
/// * `dir` - The directory to search in
/// * `pattern` - An optional regex pattern to match against filenames
///
/// # Returns
/// A Result containing a vector of paths to matching files, or an error
pub fn find_all_parquet_files(
    dir: &Path,
    pattern: Option<&str>,
) -> Result<Vec<PathBuf>, io::Error> {
    if !dir.exists() {
        return Err(io::Error::new(
            io::ErrorKind::NotFound,
            format!("Directory not found: {}", dir.display()),
        ));
    }

    let regex = if let Some(pat) = pattern {
        Some(Regex::new(pat).map_err(|e| {
            io::Error::new(io::ErrorKind::InvalidInput, format!("Invalid regex: {e}"))
        })?)
    } else {
        None
    };

    let mut result = Vec::new();

    for entry in std::fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_file() && path.extension().is_some_and(|ext| ext == "parquet") {
            let filename = path.file_name().unwrap().to_string_lossy();

            if let Some(ref re) = regex {
                if re.is_match(&filename) {
                    result.push(path);
                }
            } else {
                result.push(path);
            }
        }
    }

    // Sort by modification time (newest first)
    result.sort_by(|a, b| {
        let a_metadata = std::fs::metadata(a).unwrap();
        let b_metadata = std::fs::metadata(b).unwrap();
        b_metadata
            .modified()
            .unwrap()
            .cmp(&a_metadata.modified().unwrap())
    });

    Ok(result)
}

/// Group files by their register type
///
/// # Arguments
/// * `files` - A vector of file paths
///
/// # Returns
/// A `HashMap` mapping register types to vectors of file paths
#[must_use] pub fn group_files_by_type(files: Vec<PathBuf>) -> HashMap<String, Vec<PathBuf>> {
    let mut groups: HashMap<String, Vec<PathBuf>> = HashMap::new();

    for file in files {
        if let Some(filename) = file.file_name() {
            let filename_str = filename.to_string_lossy();
            if let Some(register_type) = detect_register_type(&filename_str) {
                groups
                    .entry(register_type.to_string())
                    .or_default()
                    .push(file);
            } else {
                groups.entry("unknown".to_string()).or_default().push(file);
            }
        }
    }

    groups
}

/// Detect the register type from a filename
///
/// # Arguments
/// * `filename` - The filename to analyze
///
/// # Returns
/// An Option containing the detected register type, or None if not detected
#[must_use] pub fn detect_register_type(filename: &str) -> Option<&'static str> {
    let patterns = [
        ("akm", r"(?i)akm|arbejdsklassifikationsmodul"),
        ("bef", r"(?i)bef|befolkning"),
        ("ind", r"(?i)ind|indkomst"),
        ("uddf", r"(?i)uddf|uddannelse"),
        ("idan", r"(?i)idan|idanmark"),
        ("lpr", r"(?i)lpr|landspatientregister"),
    ];

    for (register_type, pattern) in &patterns {
        if Regex::new(pattern).ok()?.is_match(filename) {
            return Some(register_type);
        }
    }

    None
}

/// Extract a period (YYYYMM or YYYY) from a filename
///
/// # Arguments
/// * `filename` - The filename to extract the period from
///
/// # Returns
/// An Option containing the period string, or None if not found
#[must_use] pub fn extract_period_from_filename(filename: &str) -> Option<String> {
    // Match YYYYMM pattern (e.g., 202301)
    let re_period = Regex::new(r"(?:^|[^\d])(\d{6})(?:[^\d]|$)").ok()?;
    if let Some(cap) = re_period.captures(filename) {
        return cap.get(1).map(|m| m.as_str().to_string());
    }

    // Match YYYY pattern (e.g., 2023)
    let re_year = Regex::new(r"(?:^|[^\d])(\d{4})(?:[^\d]|$)").ok()?;
    if let Some(cap) = re_year.captures(filename) {
        return cap.get(1).map(|m| m.as_str().to_string());
    }

    None
}

/// Extract a year from a filename
///
/// # Arguments
/// * `filename` - The filename to extract the year from
///
/// # Returns
/// An Option containing the year as an i32, or None if not found
#[must_use] pub fn extract_year_from_filename(filename: &str) -> Option<i32> {
    let period = extract_period_from_filename(filename)?;

    // If we have a 6-digit period (YYYYMM), extract the year part
    if period.len() == 6 {
        return period[0..4].parse::<i32>().ok();
    }

    // Otherwise, assume it's already a year
    period.parse::<i32>().ok()
}

/// Detect the data structure in a directory by analyzing file patterns
///
/// # Arguments
/// * `base_dir` - The base directory to analyze
///
/// # Returns
/// A Result containing a `HashMap` mapping register types to file paths, or an error
pub fn detect_data_structure(base_dir: &Path) -> Result<HashMap<String, PathBuf>, io::Error> {
    let mut result = HashMap::new();

    // Find all parquet files
    let files = find_all_parquet_files(base_dir, None)?;

    // Group files by type
    let grouped = group_files_by_type(files);

    // Pick the newest file for each type
    for (register_type, files) in grouped {
        if !files.is_empty() {
            result.insert(register_type, files[0].clone());
        }
    }

    Ok(result)
}
</file>

<file path="src/pnr_utils/generation.rs">
//! PNR generation utilities.
//!
//! This module provides utilities for generating synthetic PNRs for testing
//! and development purposes.

use super::types::{FamilyInfo, ParentPair, PersonInfo};
use crate::error::{validation_error, Result};
use chrono::{Duration, NaiveDate};
use hashbrown::HashMap;
use rand::Rng;

/// A pool of generated PNRs for testing and development
#[derive(Debug)]
pub struct PnrPool {
    /// All PNRs in the pool
    pool: HashMap<usize, PersonInfo>,
    /// Only children PNRs
    children: HashMap<usize, PersonInfo>,
    /// Only parent PNRs
    parents: HashMap<usize, PersonInfo>,
}

impl PnrPool {
    /// Create a new PNR pool with the specified number of records
    ///
    /// # Arguments
    /// * `total_records` - The number of records to generate
    /// * `rng` - The random number generator to use
    ///
    /// # Returns
    /// A Result containing the PNR pool or an error
    pub fn new<R: Rng>(total_records: usize, rng: &mut R) -> Result<Self> {
        let mut pool = HashMap::new();
        let mut children = HashMap::new();
        let mut parents = HashMap::new();

        // Define study period constants
        let _study_start = NaiveDate::from_ymd_opt(2000, 1, 1)
            .ok_or_else(|| validation_error("Invalid study start date (2000-01-01)"))?;
        let study_end = NaiveDate::from_ymd_opt(2018, 12, 31)
            .ok_or_else(|| validation_error("Invalid study end date (2018-12-31)"))?;
        let earliest_birth = NaiveDate::from_ymd_opt(1995, 1, 1)
            .ok_or_else(|| validation_error("Invalid earliest birth date (1995-01-01)"))?;
        let latest_birth = study_end;

        let birth_range_days = (latest_birth - earliest_birth).num_days() as i32;

        // Generate children first
        for i in 0..total_records {
            // Generate child's birth date within study period
            let days_offset = rng.random_range(0..=birth_range_days);
            let birth_date = earliest_birth + Duration::days(i64::from(days_offset));

            let sequence = rng.random_range(0..10000);
            let pnr = format!("{}-{:04}", birth_date.format("%d%m%y"), sequence);

            children.insert(i, (birth_date, pnr.clone()));
            pool.insert(i, (birth_date, pnr));

            // Generate parents based on child's birth date
            let mother_age = rng.random_range(20..46); // mothers aged 20-45 at birth
            let father_age = rng.random_range(20..50); // fathers aged 20-49 at birth

            let mother_birth = birth_date - Duration::days(mother_age * 365);
            let father_birth = birth_date - Duration::days(father_age * 365);

            let mother_sequence = rng.random_range(0..10000);
            let father_sequence = rng.random_range(0..10000);

            let mother_pnr = format!("{}-{:04}", mother_birth.format("%d%m%y"), mother_sequence);
            let father_pnr = format!("{}-{:04}", father_birth.format("%d%m%y"), father_sequence);

            parents.insert(i + 1_000_000, (father_birth, father_pnr.clone())); // Father
            parents.insert(i + 2_000_000, (mother_birth, mother_pnr.clone())); // Mother

            pool.insert(i + 1_000_000, (father_birth, father_pnr));
            pool.insert(i + 2_000_000, (mother_birth, mother_pnr));
        }

        Ok(Self {
            pool,
            children,
            parents,
        })
    }

    /// Get a person's information by index
    ///
    /// # Arguments
    /// * `index` - The index of the person
    ///
    /// # Returns
    /// An Option containing the person's information
    #[must_use]
    pub fn get(&self, index: &usize) -> Option<PersonInfo> {
        self.pool.get(index).map(|(date, pnr)| (*date, pnr.clone()))
    }

    /// Get a child's information by index
    ///
    /// # Arguments
    /// * `index` - The index of the child
    ///
    /// # Returns
    /// An Option containing the child's information
    #[must_use]
    pub fn get_child(&self, index: &usize) -> Option<PersonInfo> {
        self.children
            .get(index)
            .map(|(date, pnr)| (*date, pnr.clone()))
    }

    /// Get a child's parents by index
    ///
    /// # Arguments
    /// * `index` - The index of the child
    ///
    /// # Returns
    /// An Option containing the child's parents' information
    #[must_use]
    pub fn get_parents(&self, index: &usize) -> Option<ParentPair> {
        let father = self.parents.get(&(index + 1_000_000))?;
        let mother = self.parents.get(&(index + 2_000_000))?;
        Some(((father.0, father.1.clone()), (mother.0, mother.1.clone())))
    }

    /// Get a child's family (child and parents) by index
    ///
    /// # Arguments
    /// * `index` - The index of the child
    ///
    /// # Returns
    /// An Option containing the child's family information
    #[must_use]
    pub fn get_family(&self, index: &usize) -> Option<FamilyInfo> {
        let child = self.get_child(index)?;
        let parents = self.get_parents(index)?;
        Some((child, parents))
    }

    /// Get the total number of records in the pool
    ///
    /// # Returns
    /// The number of records in the pool
    #[must_use]
    pub fn len(&self) -> usize {
        self.pool.len()
    }

    /// Check if the pool is empty
    ///
    /// # Returns
    /// True if the pool is empty, false otherwise
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.pool.is_empty()
    }

    /// Get the number of children in the pool
    ///
    /// # Returns
    /// The number of children in the pool
    #[must_use]
    pub fn num_children(&self) -> usize {
        self.children.len()
    }

    /// Get the number of parents in the pool
    ///
    /// # Returns
    /// The number of parents in the pool
    #[must_use]
    pub fn num_parents(&self) -> usize {
        self.parents.len()
    }
}

/// Generate a PNR from a date and sequence number
///
/// # Arguments
/// * `date` - The birth date
/// * `sequence` - The sequence number (0-9999)
///
/// # Returns
/// A PNR string in the format DD-MM-YY-XXXX
#[must_use] pub fn generate_pnr(date: &NaiveDate, sequence: u16) -> String {
    format!("{}-{:04}", date.format("%d%m%y"), sequence % 10000)
}

/// Generate a pool of PNRs for testing
///
/// # Arguments
/// * `size` - The number of PNRs to generate
/// * `start_year` - The start year for birth dates
/// * `end_year` - The end year for birth dates
///
/// # Returns
/// A vector of PNRs
#[must_use] pub fn generate_test_pnrs(size: usize, start_year: i32, end_year: i32) -> Vec<String> {
    let mut rng = rand::rng();
    let mut pnrs = Vec::with_capacity(size);

    let start_date = NaiveDate::from_ymd_opt(start_year, 1, 1)
        .unwrap_or_else(|| NaiveDate::from_ymd_opt(2000, 1, 1).unwrap());

    let end_date = NaiveDate::from_ymd_opt(end_year, 12, 31)
        .unwrap_or_else(|| NaiveDate::from_ymd_opt(2020, 12, 31).unwrap());

    let days = (end_date - start_date).num_days() as i32;

    for _ in 0..size {
        let offset = rng.random_range(0..=days);
        let date = start_date + Duration::days(i64::from(offset));
        let sequence = rng.random_range(0..10000);

        pnrs.push(generate_pnr(&date, sequence));
    }

    pnrs
}
</file>

<file path="src/pnr_utils/mod.rs">
//! Consolidated Personal Identification Number (PNR) utilities.
//!
//! This module provides various functions and types for working with PNRs,
//! including generation, validation, and lookup operations.
//!
//! It consolidates functionality previously scattered across multiple modules
//! into a single, comprehensive implementation that can be used throughout the
//! codebase.

pub mod generation;
pub mod types;
pub mod validation;

pub use generation::*;
pub use types::*;
pub use validation::*;

// Re-export core types and traits for convenience
pub use crate::error::Result;
pub use chrono::{Datelike, Duration, NaiveDate};
</file>

<file path="src/pnr_utils/types.rs">
//! Core PNR types and definitions.
//!
//! This module defines the core types used for working with Personal
//! Identification Numbers (PNRs) throughout the codebase.

use chrono::NaiveDate;

/// Represents an individual's information (birth date and PNR)
pub type PersonInfo = (NaiveDate, String);

/// Represents a pair of parents (father, mother)
pub type ParentPair = (PersonInfo, PersonInfo);

/// Represents a family (child and parents)
pub type FamilyInfo = (PersonInfo, ParentPair);

/// The gender of a person, derived from their PNR
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Gender {
    /// Male
    Male,
    /// Female
    Female,
    /// Unknown or unspecified gender
    Unknown,
}

impl Gender {
    /// Create a Gender from a PNR's last digit
    ///
    /// # Arguments
    /// * `last_digit` - The last digit of the PNR
    ///
    /// # Returns
    /// The gender (Male for odd, Female for even)
    #[must_use] pub const fn from_pnr_digit(last_digit: u8) -> Self {
        match last_digit % 2 {
            0 => Self::Female,
            _ => Self::Male,
        }
    }

    /// Get a string representation of the gender
    ///
    /// # Returns
    /// "M" for Male, "F" for Female, "U" for Unknown
    #[must_use] pub const fn to_string(&self) -> &'static str {
        match self {
            Self::Male => "M",
            Self::Female => "F",
            Self::Unknown => "U",
        }
    }
}

impl From<&str> for Gender {
    fn from(s: &str) -> Self {
        match s.trim().to_uppercase().as_str() {
            "M" | "MALE" => Self::Male,
            "F" | "FEMALE" => Self::Female,
            _ => Self::Unknown,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_gender_from_pnr_digit() {
        assert_eq!(Gender::from_pnr_digit(1), Gender::Male);
        assert_eq!(Gender::from_pnr_digit(2), Gender::Female);
        assert_eq!(Gender::from_pnr_digit(3), Gender::Male);
        assert_eq!(Gender::from_pnr_digit(4), Gender::Female);
    }

    #[test]
    fn test_gender_to_string() {
        assert_eq!(Gender::Male.to_string(), "M");
        assert_eq!(Gender::Female.to_string(), "F");
        assert_eq!(Gender::Unknown.to_string(), "U");
    }

    #[test]
    fn test_gender_from_string() {
        assert_eq!(Gender::from("M"), Gender::Male);
        assert_eq!(Gender::from("F"), Gender::Female);
        assert_eq!(Gender::from("Male"), Gender::Male);
        assert_eq!(Gender::from("Female"), Gender::Female);
        assert_eq!(Gender::from("MALE"), Gender::Male);
        assert_eq!(Gender::from("FEMALE"), Gender::Female);
        assert_eq!(Gender::from("Unknown"), Gender::Unknown);
    }
}
</file>

<file path="src/pnr_utils/validation.rs">
//! PNR validation utilities.
//!
//! This module provides utilities for validating PNRs and extracting
//! information from them.

use super::types::Gender;
use crate::date_utils::core::DateUtils;
use crate::date_utils::parsing::DateParsingUtils;
use crate::date_utils::parsing::DateParsingUtilsImpl;
use crate::error::{validation_error, Result};
use chrono::NaiveDate;

/// Trait for PNR validation operations
pub trait PnrValidationUtils {
    /// Validate a PNR string
    ///
    /// # Arguments
    /// * `pnr` - The PNR string to validate
    ///
    /// # Returns
    /// A Result indicating whether the PNR is valid
    fn validate_pnr(pnr: &str) -> Result<()>;

    /// Extract the birth date from a PNR
    ///
    /// # Arguments
    /// * `pnr` - The PNR string
    ///
    /// # Returns
    /// A Result containing the birth date or an error
    fn extract_birth_date(pnr: &str) -> Result<NaiveDate>;

    /// Extract the gender from a PNR
    ///
    /// # Arguments
    /// * `pnr` - The PNR string
    ///
    /// # Returns
    /// A Result containing the gender or an error
    fn extract_gender(pnr: &str) -> Result<Gender>;

    /// Calculate the age of a person based on their PNR at a reference date
    ///
    /// # Arguments
    /// * `pnr` - The PNR string
    /// * `reference_date` - The reference date
    ///
    /// # Returns
    /// A Result containing the age in years or an error
    fn age_from_pnr(pnr: &str, reference_date: &NaiveDate) -> Result<u32>;
}

/// Implementation of `PnrValidationUtils`
pub struct PnrValidationUtilsImpl;

impl PnrValidationUtils for PnrValidationUtilsImpl {
    fn validate_pnr(pnr: &str) -> Result<()> {
        // Check format: DDMMYY-XXXX
        let re = regex::Regex::new(r"^(\d{2})(\d{2})(\d{2})-(\d{4})$")
            .map_err(|e| validation_error(format!("Regex error: {e}")))?;

        let captures = re
            .captures(pnr)
            .ok_or_else(|| validation_error(format!("Invalid PNR format: {pnr}")))?;

        let day = captures
            .get(1)
            .unwrap()
            .as_str()
            .parse::<u32>()
            .map_err(|_| validation_error(format!("Invalid day in PNR: {pnr}")))?;

        let month = captures
            .get(2)
            .unwrap()
            .as_str()
            .parse::<u32>()
            .map_err(|_| validation_error(format!("Invalid month in PNR: {pnr}")))?;

        let year = captures
            .get(3)
            .unwrap()
            .as_str()
            .parse::<u32>()
            .map_err(|_| validation_error(format!("Invalid year in PNR: {pnr}")))?;

        // Basic validation
        if !(1..=12).contains(&month) {
            return Err(validation_error(format!("Invalid month in PNR: {pnr}")));
        }

        if !(1..=31).contains(&day) {
            return Err(validation_error(format!("Invalid day in PNR: {pnr}")));
        }

        // Convert to full year (assuming 1900s for now, but could be extended)
        let full_year = 1900 + year;

        // Check if the date is valid
        if NaiveDate::from_ymd_opt(full_year as i32, month, day).is_none() {
            return Err(validation_error(format!("Invalid date in PNR: {pnr}")));
        }

        Ok(())
    }

    fn extract_birth_date(pnr: &str) -> Result<NaiveDate> {
        // Validate first
        Self::validate_pnr(pnr)?;

        // Extract date components
        let re = regex::Regex::new(r"^(\d{2})(\d{2})(\d{2})-(\d{4})$")
            .map_err(|e| validation_error(format!("Regex error: {e}")))?;

        let captures = re.captures(pnr).unwrap(); // Safe due to validation
        let day = captures.get(1).unwrap().as_str();
        let month = captures.get(2).unwrap().as_str();
        let year = captures.get(3).unwrap().as_str();

        // Convert to full year (assuming 1900s for now)
        let full_year = format!("19{year}");

        // Parse date
        let date_str = format!("{full_year}-{month}-{day}");
        DateParsingUtilsImpl::parse_iso(&date_str)
    }

    fn extract_gender(pnr: &str) -> Result<Gender> {
        // Validate first
        Self::validate_pnr(pnr)?;

        // Get the last digit
        let re = regex::Regex::new(r"^(\d{2})(\d{2})(\d{2})-(\d{4})$")
            .map_err(|e| validation_error(format!("Regex error: {e}")))?;

        let captures = re.captures(pnr).unwrap(); // Safe due to validation
        let sequence = captures.get(4).unwrap().as_str();
        let last_digit = sequence.chars().last().unwrap().to_digit(10).unwrap() as u8;

        Ok(Gender::from_pnr_digit(last_digit))
    }

    fn age_from_pnr(pnr: &str, reference_date: &NaiveDate) -> Result<u32> {
        let birth_date = Self::extract_birth_date(pnr)?;
        Ok(<crate::DateUtilsImpl as DateUtils>::age_at(
            birth_date,
            *reference_date,
        ))
    }
}

/// Parse a PNR string and extract its components
///
/// # Arguments
/// * `pnr` - The PNR string to parse
///
/// # Returns
/// A Result containing a tuple of (day, month, year, sequence) or an error
pub fn parse_pnr(pnr: &str) -> Result<(u32, u32, u32, u16)> {
    // Check format: DDMMYY-XXXX
    let re = regex::Regex::new(r"^(\d{2})(\d{2})(\d{2})-(\d{4})$")
        .map_err(|e| validation_error(format!("Regex error: {e}")))?;

    let captures = re
        .captures(pnr)
        .ok_or_else(|| validation_error(format!("Invalid PNR format: {pnr}")))?;

    let day = captures
        .get(1)
        .unwrap()
        .as_str()
        .parse::<u32>()
        .map_err(|_| validation_error(format!("Invalid day in PNR: {pnr}")))?;

    let month = captures
        .get(2)
        .unwrap()
        .as_str()
        .parse::<u32>()
        .map_err(|_| validation_error(format!("Invalid month in PNR: {pnr}")))?;

    let year = captures
        .get(3)
        .unwrap()
        .as_str()
        .parse::<u32>()
        .map_err(|_| validation_error(format!("Invalid year in PNR: {pnr}")))?;

    let sequence = captures
        .get(4)
        .unwrap()
        .as_str()
        .parse::<u16>()
        .map_err(|_| validation_error(format!("Invalid sequence in PNR: {pnr}")))?;

    Ok((day, month, year, sequence))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_pnr() {
        assert!(PnrValidationUtilsImpl::validate_pnr("010100-1234").is_ok());
        assert!(PnrValidationUtilsImpl::validate_pnr("311295-5678").is_ok());

        // Invalid format
        assert!(PnrValidationUtilsImpl::validate_pnr("0101001234").is_err());
        assert!(PnrValidationUtilsImpl::validate_pnr("01-01-00-1234").is_err());

        // Invalid date components
        assert!(PnrValidationUtilsImpl::validate_pnr("320100-1234").is_err()); // Invalid day
        assert!(PnrValidationUtilsImpl::validate_pnr("011300-1234").is_err()); // Invalid month
        assert!(PnrValidationUtilsImpl::validate_pnr("290200-1234").is_err()); // Invalid date (non leap year)
    }

    #[test]
    fn test_extract_birth_date() {
        let date = PnrValidationUtilsImpl::extract_birth_date("010100-1234").unwrap();
        assert_eq!(date, NaiveDate::from_ymd_opt(1900, 1, 1).unwrap());

        let date = PnrValidationUtilsImpl::extract_birth_date("311295-5678").unwrap();
        assert_eq!(date, NaiveDate::from_ymd_opt(1995, 12, 31).unwrap());
    }

    #[test]
    fn test_extract_gender() {
        let gender = PnrValidationUtilsImpl::extract_gender("010100-1231").unwrap();
        assert_eq!(gender, Gender::Male);

        let gender = PnrValidationUtilsImpl::extract_gender("010100-1232").unwrap();
        assert_eq!(gender, Gender::Female);
    }

    #[test]
    fn test_age_from_pnr() {
        let reference_date = NaiveDate::from_ymd_opt(2023, 1, 1).unwrap();

        let age = PnrValidationUtilsImpl::age_from_pnr("010190-1234", &reference_date).unwrap();
        assert_eq!(age, 33);

        let age = PnrValidationUtilsImpl::age_from_pnr("311295-5678", &reference_date).unwrap();
        assert_eq!(age, 27);
    }

    #[test]
    fn test_parse_pnr() {
        let (day, month, year, sequence) = parse_pnr("010100-1234").unwrap();
        assert_eq!(day, 1);
        assert_eq!(month, 1);
        assert_eq!(year, 0);
        assert_eq!(sequence, 1234);

        let (day, month, year, sequence) = parse_pnr("311295-5678").unwrap();
        assert_eq!(day, 31);
        assert_eq!(month, 12);
        assert_eq!(year, 95);
        assert_eq!(sequence, 5678);
    }
}
</file>

<file path="src/string_utils/case_conversion.rs">
//! String case conversion utilities.
//!
//! This module provides utilities for converting strings between different cases
//! (camel case, snake case, title case, etc.).

/// Trait for string case conversion operations
pub trait StringCaseUtils {
    /// Convert a string to title case
    ///
    /// # Arguments
    /// * `s` - The string to convert
    ///
    /// # Returns
    /// The string converted to title case
    fn to_title_case(s: &str) -> String;

    /// Convert a string to snake case
    ///
    /// # Arguments
    /// * `s` - The string to convert
    ///
    /// # Returns
    /// The string converted to snake case
    fn to_snake_case(s: &str) -> String;

    /// Convert a string to camel case
    ///
    /// # Arguments
    /// * `s` - The string to convert
    ///
    /// # Returns
    /// The string converted to camel case
    fn to_camel_case(s: &str) -> String;

    /// Convert a string to pascal case
    ///
    /// # Arguments
    /// * `s` - The string to convert
    ///
    /// # Returns
    /// The string converted to pascal case
    fn to_pascal_case(s: &str) -> String;

    /// Convert a string to kebab case
    ///
    /// # Arguments
    /// * `s` - The string to convert
    ///
    /// # Returns
    /// The string converted to kebab case
    fn to_kebab_case(s: &str) -> String;
}

/// Implementation of `StringCaseUtils`
pub struct StringCaseUtilsImpl;

impl StringCaseUtils for StringCaseUtilsImpl {
    fn to_title_case(s: &str) -> String {
        s.split_whitespace()
            .map(|word| {
                if word.is_empty() {
                    word.to_string()
                } else {
                    let mut chars = word.chars();
                    chars.next().map_or_else(String::new, |first| {
                        first.to_uppercase().collect::<String>() + chars.as_str()
                    })
                }
            })
            .collect::<Vec<String>>()
            .join(" ")
    }

    fn to_snake_case(s: &str) -> String {
        // First separate by spaces
        let mut result = String::new();
        let mut prev_is_uppercase = false;

        for c in s.chars() {
            if c.is_uppercase() {
                if !prev_is_uppercase && !result.is_empty() && !result.ends_with('_') {
                    result.push('_');
                }
                result.push(c.to_lowercase().next().unwrap());
                prev_is_uppercase = true;
            } else if c == ' ' || c == '-' {
                result.push('_');
                prev_is_uppercase = false;
            } else {
                result.push(c);
                prev_is_uppercase = false;
            }
        }

        result
    }

    fn to_camel_case(s: &str) -> String {
        let mut result = String::new();
        let mut capitalize_next = false;

        for c in s.chars() {
            if c == ' ' || c == '_' || c == '-' {
                capitalize_next = true;
            } else if capitalize_next {
                result.push(c.to_uppercase().next().unwrap());
                capitalize_next = false;
            } else if result.is_empty() {
                result.push(c.to_lowercase().next().unwrap());
            } else {
                result.push(c);
            }
        }

        result
    }

    fn to_pascal_case(s: &str) -> String {
        let camel = Self::to_camel_case(s);

        if camel.is_empty() {
            return camel;
        }

        let mut chars = camel.chars();
        let first = chars.next().unwrap().to_uppercase().next().unwrap();
        first.to_string() + chars.as_str()
    }

    fn to_kebab_case(s: &str) -> String {
        Self::to_snake_case(s).replace('_', "-")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_title_case() {
        assert_eq!(
            StringCaseUtilsImpl::to_title_case("hello world"),
            "Hello World"
        );
        assert_eq!(
            StringCaseUtilsImpl::to_title_case("HELLO WORLD"),
            "HELLO WORLD"
        );
        assert_eq!(
            StringCaseUtilsImpl::to_title_case("hello_world"),
            "Hello_world"
        );
    }

    #[test]
    fn test_to_snake_case() {
        assert_eq!(
            StringCaseUtilsImpl::to_snake_case("HelloWorld"),
            "hello_world"
        );
        assert_eq!(
            StringCaseUtilsImpl::to_snake_case("hello world"),
            "hello_world"
        );
        assert_eq!(
            StringCaseUtilsImpl::to_snake_case("Hello-World"),
            "hello_world"
        );
    }

    #[test]
    fn test_to_camel_case() {
        assert_eq!(
            StringCaseUtilsImpl::to_camel_case("hello_world"),
            "helloWorld"
        );
        assert_eq!(
            StringCaseUtilsImpl::to_camel_case("hello world"),
            "helloWorld"
        );
        assert_eq!(
            StringCaseUtilsImpl::to_camel_case("hello-world"),
            "helloWorld"
        );
    }

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(
            StringCaseUtilsImpl::to_pascal_case("hello_world"),
            "HelloWorld"
        );
        assert_eq!(
            StringCaseUtilsImpl::to_pascal_case("hello world"),
            "HelloWorld"
        );
        assert_eq!(
            StringCaseUtilsImpl::to_pascal_case("hello-world"),
            "HelloWorld"
        );
    }

    #[test]
    fn test_to_kebab_case() {
        assert_eq!(
            StringCaseUtilsImpl::to_kebab_case("HelloWorld"),
            "hello-world"
        );
        assert_eq!(
            StringCaseUtilsImpl::to_kebab_case("hello world"),
            "hello-world"
        );
        assert_eq!(
            StringCaseUtilsImpl::to_kebab_case("hello_world"),
            "hello-world"
        );
    }
}
</file>

<file path="src/string_utils/formatting.rs">
//! String formatting utilities.
//!
//! This module provides utilities for formatting and manipulating strings.

/// Trait for string formatting operations
pub trait StringFormattingUtils {
    /// Truncate a string to a maximum length, adding an ellipsis if truncated
    ///
    /// # Arguments
    /// * `s` - The string to truncate
    /// * `max_length` - The maximum length
    ///
    /// # Returns
    /// The truncated string, with an ellipsis if truncated
    fn truncate(s: &str, max_length: usize) -> String;

    /// Sanitize a string for use as an identifier
    ///
    /// # Arguments
    /// * `input` - The string to sanitize
    ///
    /// # Returns
    /// A sanitized string that can be used as an identifier
    fn sanitize_identifier(input: &str) -> String;

    /// Ensure a string starts with a given prefix
    ///
    /// # Arguments
    /// * `s` - The string to check
    /// * `prefix` - The prefix to ensure
    ///
    /// # Returns
    /// The string with the prefix added if it doesn't already start with it
    fn ensure_prefix(s: &str, prefix: &str) -> String;

    /// Ensure a string ends with a given suffix
    ///
    /// # Arguments
    /// * `s` - The string to check
    /// * `suffix` - The suffix to ensure
    ///
    /// # Returns
    /// The string with the suffix added if it doesn't already end with it
    fn ensure_suffix(s: &str, suffix: &str) -> String;

    /// Pad a string to a fixed width with a given character
    ///
    /// # Arguments
    /// * `s` - The string to pad
    /// * `width` - The desired width
    /// * `pad_char` - The character to use for padding (defaults to space)
    /// * `right_align` - Whether to right-align the string (defaults to false)
    ///
    /// # Returns
    /// The padded string
    fn pad(s: &str, width: usize, pad_char: Option<char>, right_align: Option<bool>) -> String;
}

/// Implementation of `StringFormattingUtils`
pub struct StringFormattingUtilsImpl;

impl StringFormattingUtils for StringFormattingUtilsImpl {
    fn truncate(s: &str, max_length: usize) -> String {
        if s.len() <= max_length {
            return s.to_string();
        }

        // Try to truncate at a word boundary
        let truncated = &s[0..max_length.saturating_sub(3)];
        let mut result = String::from(truncated);

        // Find the last space to truncate at a word boundary
        if let Some(last_space) = result.rfind(' ') {
            result.truncate(last_space);
        }

        result.push_str("...");
        result
    }

    fn sanitize_identifier(input: &str) -> String {
        input
            .chars()
            .map(|c| {
                if c.is_alphanumeric() || c == '_' {
                    c
                } else {
                    '_'
                }
            })
            .collect()
    }

    fn ensure_prefix(s: &str, prefix: &str) -> String {
        if s.starts_with(prefix) {
            s.to_string()
        } else {
            format!("{prefix}{s}")
        }
    }

    fn ensure_suffix(s: &str, suffix: &str) -> String {
        if s.ends_with(suffix) {
            s.to_string()
        } else {
            format!("{s}{suffix}")
        }
    }

    fn pad(s: &str, width: usize, pad_char: Option<char>, right_align: Option<bool>) -> String {
        let char_to_pad = pad_char.unwrap_or(' ');
        let align_right = right_align.unwrap_or(false);

        if s.len() >= width {
            return s.to_string();
        }

        let padding = char_to_pad.to_string().repeat(width - s.len());

        if align_right {
            format!("{padding}{s}")
        } else {
            format!("{s}{padding}")
        }
    }
}

/// Truncates a string to the specified length, adding an ellipsis if truncated.
///
/// # Parameters
///
/// * `input` - The string to truncate
/// * `max_length` - The maximum length
///
/// # Returns
///
/// A truncated string, with an ellipsis if truncated.
#[must_use] pub fn truncate(input: &str, max_length: usize) -> String {
    if input.len() <= max_length {
        input.to_string()
    } else {
        format!("{}...", &input[0..max_length.saturating_sub(3)])
    }
}

/// Sanitizes a string for use as an identifier, replacing invalid characters with underscores.
///
/// # Parameters
///
/// * `input` - The string to sanitize
///
/// # Returns
///
/// A sanitized string that can be used as an identifier.
#[must_use] pub fn sanitize_identifier(input: &str) -> String {
    input
        .chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_truncate() {
        assert_eq!(
            StringFormattingUtilsImpl::truncate("Hello world", 20),
            "Hello world"
        );
        assert_eq!(
            StringFormattingUtilsImpl::truncate("Hello world", 8),
            "Hello..."
        );
        assert_eq!(
            StringFormattingUtilsImpl::truncate("HelloWorld", 8),
            "Hello..."
        );
    }

    #[test]
    fn test_sanitize_identifier() {
        assert_eq!(
            StringFormattingUtilsImpl::sanitize_identifier("Hello World"),
            "Hello_World"
        );
        assert_eq!(
            StringFormattingUtilsImpl::sanitize_identifier("Hello-World"),
            "Hello_World"
        );
        assert_eq!(
            StringFormattingUtilsImpl::sanitize_identifier("Hello_World"),
            "Hello_World"
        );
    }

    #[test]
    fn test_ensure_prefix() {
        assert_eq!(
            StringFormattingUtilsImpl::ensure_prefix("World", "Hello "),
            "Hello World"
        );
        assert_eq!(
            StringFormattingUtilsImpl::ensure_prefix("Hello World", "Hello "),
            "Hello World"
        );
    }

    #[test]
    fn test_ensure_suffix() {
        assert_eq!(
            StringFormattingUtilsImpl::ensure_suffix("Hello", " World"),
            "Hello World"
        );
        assert_eq!(
            StringFormattingUtilsImpl::ensure_suffix("Hello World", " World"),
            "Hello World"
        );
    }

    #[test]
    fn test_pad() {
        assert_eq!(
            StringFormattingUtilsImpl::pad("Hello", 10, None, None),
            "Hello     "
        );
        assert_eq!(
            StringFormattingUtilsImpl::pad("Hello", 10, Some('-'), None),
            "Hello-----"
        );
        assert_eq!(
            StringFormattingUtilsImpl::pad("Hello", 10, None, Some(true)),
            "     Hello"
        );
        assert_eq!(
            StringFormattingUtilsImpl::pad("Hello", 10, Some('-'), Some(true)),
            "-----Hello"
        );
        assert_eq!(
            StringFormattingUtilsImpl::pad("Hello World", 5, None, None),
            "Hello World"
        );
    }

    #[test]
    fn test_truncate_function() {
        assert_eq!(truncate("Hello world", 20), "Hello world");
        assert_eq!(truncate("Hello world", 8), "Hello...");
    }

    #[test]
    fn test_sanitize_identifier_function() {
        assert_eq!(sanitize_identifier("Hello World"), "Hello_World");
        assert_eq!(sanitize_identifier("Hello-World"), "Hello_World");
    }
}
</file>

<file path="src/string_utils/mod.rs">
//! Consolidated string manipulation utilities.
//!
//! This module provides various functions and traits for working with strings,
//! including case conversion, parsing, formatting, truncation, and sanitization.
//!
//! It consolidates functionality previously scattered across multiple modules
//! into a single, comprehensive implementation that can be used throughout the
//! codebase.

pub mod case_conversion;
pub mod formatting;
pub mod parsing;

pub use case_conversion::*;
pub use formatting::*;
pub use parsing::*;

// Re-export core types and traits for convenience
pub use crate::error::Result;
</file>

<file path="src/string_utils/parsing.rs">
//! String parsing utilities.
//!
//! This module provides utilities for parsing strings into various types.

use crate::error::{validation_error, Result};

/// Trait for string parsing operations
pub trait StringParsingUtils {
    /// Parse a string as an i32, with a custom error message
    ///
    /// # Arguments
    /// * `s` - The string to parse
    /// * `error_msg` - The error message to use if parsing fails
    ///
    /// # Returns
    /// A Result containing the parsed i32 or an error
    fn parse_i32(s: &str, error_msg: &str) -> Result<i32>;

    /// Parse a string as an f64, with a custom error message
    ///
    /// # Arguments
    /// * `s` - The string to parse
    /// * `error_msg` - The error message to use if parsing fails
    ///
    /// # Returns
    /// A Result containing the parsed f64 or an error
    fn parse_f64(s: &str, error_msg: &str) -> Result<f64>;

    /// Parse a string as a boolean, with a custom error message
    ///
    /// # Arguments
    /// * `s` - The string to parse
    /// * `error_msg` - The error message to use if parsing fails
    ///
    /// # Returns
    /// A Result containing the parsed boolean or an error
    fn parse_bool(s: &str, error_msg: &str) -> Result<bool>;

    /// Parse a string as an Option<i32>, with a custom error message
    ///
    /// # Arguments
    /// * `s` - The string to parse
    /// * `error_msg` - The error message to use if parsing fails
    ///
    /// # Returns
    /// A Result containing the parsed Option<i32> or an error
    /// Returns Ok(None) if the string is empty or "null"
    fn parse_optional_i32(s: &str, error_msg: &str) -> Result<Option<i32>>;

    /// Parse a string as an Option<f64>, with a custom error message
    ///
    /// # Arguments
    /// * `s` - The string to parse
    /// * `error_msg` - The error message to use if parsing fails
    ///
    /// # Returns
    /// A Result containing the parsed Option<f64> or an error
    /// Returns Ok(None) if the string is empty or "null"
    fn parse_optional_f64(s: &str, error_msg: &str) -> Result<Option<f64>>;
}

/// Implementation of `StringParsingUtils`
pub struct StringParsingUtilsImpl;

impl StringParsingUtils for StringParsingUtilsImpl {
    fn parse_i32(s: &str, error_msg: &str) -> Result<i32> {
        s.trim()
            .parse::<i32>()
            .map_err(|_| validation_error(format!("{error_msg}: '{s}'")))
    }

    fn parse_f64(s: &str, error_msg: &str) -> Result<f64> {
        s.trim()
            .parse::<f64>()
            .map_err(|_| validation_error(format!("{error_msg}: '{s}'")))
    }

    fn parse_bool(s: &str, error_msg: &str) -> Result<bool> {
        match s.trim().to_lowercase().as_str() {
            "true" | "yes" | "1" => Ok(true),
            "false" | "no" | "0" => Ok(false),
            _ => Err(validation_error(format!("{error_msg}: '{s}'"))),
        }
    }

    fn parse_optional_i32(s: &str, error_msg: &str) -> Result<Option<i32>> {
        let trimmed = s.trim();
        if trimmed.is_empty() || trimmed.eq_ignore_ascii_case("null") {
            Ok(None)
        } else {
            trimmed
                .parse::<i32>()
                .map(Some)
                .map_err(|_| validation_error(format!("{error_msg}: '{s}'")))
        }
    }

    fn parse_optional_f64(s: &str, error_msg: &str) -> Result<Option<f64>> {
        let trimmed = s.trim();
        if trimmed.is_empty() || trimmed.eq_ignore_ascii_case("null") {
            Ok(None)
        } else {
            trimmed
                .parse::<f64>()
                .map(Some)
                .map_err(|_| validation_error(format!("{error_msg}: '{s}'")))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_i32() {
        assert_eq!(
            StringParsingUtilsImpl::parse_i32("123", "Invalid number").unwrap(),
            123
        );
        assert!(StringParsingUtilsImpl::parse_i32("abc", "Invalid number").is_err());
    }

    #[test]
    fn test_parse_f64() {
        assert_eq!(
            StringParsingUtilsImpl::parse_f64("123.45", "Invalid number").unwrap(),
            123.45
        );
        assert!(StringParsingUtilsImpl::parse_f64("abc", "Invalid number").is_err());
    }

    #[test]
    fn test_parse_bool() {
        assert!(
            StringParsingUtilsImpl::parse_bool("true", "Invalid boolean").unwrap()
        );
        assert!(
            StringParsingUtilsImpl::parse_bool("yes", "Invalid boolean").unwrap()
        );
        assert!(
            StringParsingUtilsImpl::parse_bool("1", "Invalid boolean").unwrap()
        );
        assert!(
            !StringParsingUtilsImpl::parse_bool("false", "Invalid boolean").unwrap()
        );
        assert!(
            !StringParsingUtilsImpl::parse_bool("no", "Invalid boolean").unwrap()
        );
        assert!(
            !StringParsingUtilsImpl::parse_bool("0", "Invalid boolean").unwrap()
        );
        assert!(StringParsingUtilsImpl::parse_bool("abc", "Invalid boolean").is_err());
    }

    #[test]
    fn test_parse_optional_i32() {
        assert_eq!(
            StringParsingUtilsImpl::parse_optional_i32("123", "Invalid number").unwrap(),
            Some(123)
        );
        assert_eq!(
            StringParsingUtilsImpl::parse_optional_i32("", "Invalid number").unwrap(),
            None
        );
        assert_eq!(
            StringParsingUtilsImpl::parse_optional_i32("null", "Invalid number").unwrap(),
            None
        );
        assert!(StringParsingUtilsImpl::parse_optional_i32("abc", "Invalid number").is_err());
    }

    #[test]
    fn test_parse_optional_f64() {
        assert_eq!(
            StringParsingUtilsImpl::parse_optional_f64("123.45", "Invalid number").unwrap(),
            Some(123.45)
        );
        assert_eq!(
            StringParsingUtilsImpl::parse_optional_f64("", "Invalid number").unwrap(),
            None
        );
        assert_eq!(
            StringParsingUtilsImpl::parse_optional_f64("null", "Invalid number").unwrap(),
            None
        );
        assert!(StringParsingUtilsImpl::parse_optional_f64("abc", "Invalid number").is_err());
    }
}
</file>

<file path="src/config.rs">
use crate::error::{config_error, Context, Result};
use serde::{Deserialize, Serialize};
use std::fs::File;
use std::io::BufReader;
use std::path::Path;

/// Generic config loading function for any type that implements Deserialize
pub fn load_config<T>(path: impl AsRef<Path>) -> Result<T>
where
    T: for<'de> Deserialize<'de>,
{
    let file = File::open(path.as_ref())
        .with_context(|| format!("Failed to open config file: {:?}", path.as_ref()))?;

    let reader = BufReader::new(file);

    if path.as_ref().extension().is_some_and(|ext| ext == "json") {
        serde_json::from_reader(reader)
            .with_context(|| format!("Failed to parse JSON config: {:?}", path.as_ref()))
    } else {
        // Default to JSON, but you can add support for other formats like YAML or TOML
        Err(config_error(format!(
            "Unsupported config format: {:?}",
            path.as_ref().extension().unwrap_or_default()
        )))
    }
}

/// Save config to a file in the specified format
pub fn save_config<T>(config: &T, path: impl AsRef<Path>) -> Result<()>
where
    T: Serialize,
{
    let file = File::create(path.as_ref())
        .with_context(|| format!("Failed to create config file: {:?}", path.as_ref()))?;

    if path.as_ref().extension().is_some_and(|ext| ext == "json") {
        serde_json::to_writer_pretty(file, config)
            .with_context(|| format!("Failed to write JSON config: {:?}", path.as_ref()))
    } else {
        // Default to JSON, but you can add support for other formats
        Err(config_error(format!(
            "Unsupported config format: {:?}",
            path.as_ref().extension().unwrap_or_default()
        )))
    }
}

/// Create default config file if it doesn't exist
pub fn create_default_config<T>(path: impl AsRef<Path>, default_config: T) -> Result<()>
where
    T: Serialize,
{
    if path.as_ref().exists() {
        Ok(())
    } else {
        save_config(&default_config, path)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    #[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
    struct TestConfig {
        name: String,
        value: i32,
    }

    #[test]
    fn test_load_and_save_config() {
        // Create a temp file with a .json extension
        let temp_file_path = NamedTempFile::new().unwrap().path().with_extension("json");
        let mut temp_file = std::fs::File::create(&temp_file_path).unwrap();

        let test_config = TestConfig {
            name: "test".to_string(),
            value: 42,
        };

        // Write initial JSON to the temp file
        write!(
            temp_file,
            "{}",
            serde_json::to_string_pretty(&test_config).unwrap()
        )
        .unwrap();

        // Test loading config
        let loaded_config: TestConfig = load_config(&temp_file_path).unwrap();
        assert_eq!(loaded_config, test_config);

        // Test saving config
        let modified_config = TestConfig {
            name: "modified".to_string(),
            value: 99,
        };
        save_config(&modified_config, &temp_file_path).unwrap();

        // Verify save worked by loading again
        let reloaded_config: TestConfig = load_config(&temp_file_path).unwrap();
        assert_eq!(reloaded_config, modified_config);
    }

    #[test]
    fn test_create_default_config() {
        let temp_file = NamedTempFile::new().unwrap();
        let path = temp_file.path().to_path_buf();

        // Delete the file so we can test creation
        std::fs::remove_file(&path).unwrap();

        let default_config = TestConfig {
            name: "default".to_string(),
            value: 0,
        };

        // Create default config - add file extension to make it work with the detection
        let path_with_extension = path.with_extension("json");

        // Create default config
        create_default_config(&path_with_extension, default_config.clone()).unwrap();

        // Verify it was created correctly
        let loaded_config: TestConfig = load_config(&path_with_extension).unwrap();
        assert_eq!(loaded_config, default_config);
    }
}
</file>

<file path="src/date.rs">
use crate::error::{date_parse_error, Result};
use chrono::{Datelike, NaiveDate};

/// Get the quarter (1-4) from a date
#[must_use]
pub fn quarter_from_date(date: NaiveDate) -> u32 {
    ((date.month() - 1) / 3) + 1
}

/// Utility trait for date operations
pub trait DateUtils {
    /// Parse a date string in various formats (YMD, DMY, etc.)
    fn parse_flexible(date_str: &str) -> Result<NaiveDate>;

    /// Convert a date to a period string (YYYYMM format)
    fn to_period_string(date: NaiveDate) -> String;

    /// Get start date of quarter for a given date
    fn start_of_quarter(date: NaiveDate) -> NaiveDate;

    /// Get end date of quarter for a given date
    fn end_of_quarter(date: NaiveDate) -> NaiveDate;

    /// Get start date of year for a given date
    fn start_of_year(date: NaiveDate) -> NaiveDate;

    /// Get end date of year for a given date
    fn end_of_year(date: NaiveDate) -> NaiveDate;

    /// Get age in years at a given reference date
    fn age_at(birth_date: NaiveDate, reference_date: NaiveDate) -> u32;
}

/// Implementation of `DateUtils`
pub struct DateUtilsImpl;

impl DateUtils for DateUtilsImpl {
    fn parse_flexible(date_str: &str) -> Result<NaiveDate> {
        // Try different date formats
        let formats = [
            "%Y-%m-%d", // ISO format (2023-01-31)
            "%d-%m-%Y", // European format (31-01-2023)
            "%d/%m/%Y", // European format with slash (31/01/2023)
            "%Y%m%d",   // Compact format (20230131)
            "%Y%m",     // Year-month (202301)
        ];

        for format in &formats {
            if let Ok(date) = NaiveDate::parse_from_str(date_str, format) {
                return Ok(date);
            }
        }

        Err(date_parse_error(format!(
            "Could not parse date: {date_str}"
        )))
    }

    fn to_period_string(date: NaiveDate) -> String {
        format!("{}{:02}", date.year(), date.month())
    }

    fn start_of_quarter(date: NaiveDate) -> NaiveDate {
        let quarter = quarter_from_date(date);
        let month = ((quarter - 1) * 3) + 1;

        NaiveDate::from_ymd_opt(date.year(), month, 1)
            .unwrap_or_else(|| NaiveDate::from_ymd_opt(date.year(), 1, 1).unwrap())
    }

    fn end_of_quarter(date: NaiveDate) -> NaiveDate {
        let quarter = quarter_from_date(date);
        let month = quarter * 3;

        let year = date.year();
        let days_in_month = if month == 2 {
            if is_leap_year(year) {
                29
            } else {
                28
            }
        } else if [4, 6, 9, 11].contains(&month) {
            30
        } else {
            31
        };

        NaiveDate::from_ymd_opt(year, month, days_in_month)
            .unwrap_or_else(|| NaiveDate::from_ymd_opt(year, 12, 31).unwrap())
    }

    fn start_of_year(date: NaiveDate) -> NaiveDate {
        NaiveDate::from_ymd_opt(date.year(), 1, 1).unwrap_or(date)
    }

    fn end_of_year(date: NaiveDate) -> NaiveDate {
        NaiveDate::from_ymd_opt(date.year(), 12, 31).unwrap_or(date)
    }

    fn age_at(birth_date: NaiveDate, reference_date: NaiveDate) -> u32 {
        let years = reference_date.year() - birth_date.year();

        if reference_date.month() < birth_date.month()
            || (reference_date.month() == birth_date.month()
                && reference_date.day() < birth_date.day())
        {
            (years - 1) as u32
        } else {
            years as u32
        }
    }
}

/// Check if a year is a leap year
const fn is_leap_year(year: i32) -> bool {
    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_quarter_from_date() {
        let date1 = NaiveDate::from_ymd_opt(2023, 1, 15).unwrap();
        let date2 = NaiveDate::from_ymd_opt(2023, 4, 15).unwrap();
        let date3 = NaiveDate::from_ymd_opt(2023, 7, 15).unwrap();
        let date4 = NaiveDate::from_ymd_opt(2023, 10, 15).unwrap();

        assert_eq!(quarter_from_date(date1), 1);
        assert_eq!(quarter_from_date(date2), 2);
        assert_eq!(quarter_from_date(date3), 3);
        assert_eq!(quarter_from_date(date4), 4);
    }

    #[test]
    fn test_parse_flexible() {
        assert!(DateUtilsImpl::parse_flexible("2023-01-31").is_ok());
        assert!(DateUtilsImpl::parse_flexible("31-01-2023").is_ok());
        assert!(DateUtilsImpl::parse_flexible("31/01/2023").is_ok());
        assert!(DateUtilsImpl::parse_flexible("20230131").is_ok());
        assert!(DateUtilsImpl::parse_flexible("invalid date").is_err());
    }

    #[test]
    fn test_to_period_string() {
        let date = NaiveDate::from_ymd_opt(2023, 1, 15).unwrap();
        assert_eq!(DateUtilsImpl::to_period_string(date), "202301");
    }

    #[test]
    fn test_start_and_end_of_quarter() {
        let date = NaiveDate::from_ymd_opt(2023, 2, 15).unwrap();

        let start = DateUtilsImpl::start_of_quarter(date);
        let end = DateUtilsImpl::end_of_quarter(date);

        assert_eq!(start, NaiveDate::from_ymd_opt(2023, 1, 1).unwrap());
        assert_eq!(end, NaiveDate::from_ymd_opt(2023, 3, 31).unwrap());
    }

    #[test]
    fn test_age_at() {
        let birth_date = NaiveDate::from_ymd_opt(1990, 6, 15).unwrap();
        let before_birthday = NaiveDate::from_ymd_opt(2023, 6, 14).unwrap();
        let on_birthday = NaiveDate::from_ymd_opt(2023, 6, 15).unwrap();
        let after_birthday = NaiveDate::from_ymd_opt(2023, 6, 16).unwrap();

        assert_eq!(DateUtilsImpl::age_at(birth_date, before_birthday), 32);
        assert_eq!(DateUtilsImpl::age_at(birth_date, on_birthday), 33);
        assert_eq!(DateUtilsImpl::age_at(birth_date, after_birthday), 33);
    }
}
</file>

<file path="src/error.rs">
// Re-export IdsError from the types crate
pub use types::error::{IdsError, LegacyErrorContext as Context, Result};

// Helper functions for specific error types
pub fn date_parse_error<T: std::fmt::Display>(msg: T) -> IdsError {
    IdsError::InvalidDate(msg.to_string())
}

pub fn config_error<T: std::fmt::Display>(msg: T) -> IdsError {
    IdsError::Config(msg.to_string())
}

pub fn validation_error<T: std::fmt::Display>(msg: T) -> IdsError {
    IdsError::Validation(msg.to_string())
}

pub fn logging_error<T: std::fmt::Display>(msg: T) -> IdsError {
    // Since Logging variant was removed, use Other variant instead
    IdsError::other(format!("Logging error: {msg}"))
}

// Simplified helper for converting errors with context
pub fn with_context<T, E>(result: std::result::Result<T, E>, context: String) -> Result<T>
where
    E: std::fmt::Display + 'static,
{
    result.with_context(move || context)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_with_context_for_io_error() {
        let io_error = std::io::Error::new(std::io::ErrorKind::NotFound, "file not found");
        let result: std::result::Result<(), _> = Err(io_error);
        let ids_result = result.with_context(|| "Failed to read file");
        assert!(matches!(ids_result, Err(IdsError::Io(_))));
    }

    #[test]
    fn test_with_context_for_generic_error() {
        let result: std::result::Result<(), &str> = Err("custom error");
        let ids_result = result.with_context(|| "Operation failed");
        assert!(matches!(ids_result, Err(IdsError::Validation(_))));
        if let Err(IdsError::Validation(msg)) = ids_result {
            assert!(msg.contains("Operation failed"));
            assert!(msg.contains("custom error"));
        }
    }

    #[test]
    fn test_helper_functions() {
        let error = validation_error("Invalid input");
        assert!(matches!(error, IdsError::Validation(_)));

        let error = config_error("Missing configuration");
        assert!(matches!(error, IdsError::Config(_)));

        let error = date_parse_error("Invalid date format");
        assert!(matches!(error, IdsError::InvalidDate(_)));
    }
}
</file>

<file path="src/lib.rs">
//! Utility functions and types for the IDS-RS project.
//!
//! This crate provides various utility functions and types that are used
//! throughout the IDS-RS project, including:
//!
//! - Date utilities for working with dates, periods, and time ranges
//! - String utilities for string manipulation, parsing, and formatting
//! - PNR utilities for working with personal identification numbers
//! - File pattern utilities for finding and categorizing files
//! - Error handling utilities and types
//! - Logging utilities and configuration
//! - Rich console output and progress reporting
//!
//! Many of these utilities were previously scattered across different modules
//! and have been consolidated here for better organization and reuse.

// Core utilities
pub mod config;
pub mod error;
pub mod logging;
pub mod rich_console;

// Consolidated utilities
pub mod date_utils;
pub mod file_patterns;
pub mod pnr_utils;
pub mod string_utils;

// Older utilities (to be migrated)
pub mod date;
pub mod string;

// Re-export commonly used utilities for convenience
pub use crate::date_utils::core::{DateHelpers, DateUtils, DateUtilsImpl};
pub use crate::date_utils::formatting::{DateFormattingUtils, DateFormattingUtilsImpl};
pub use crate::date_utils::parsing::{DateParsingUtils, DateParsingUtilsImpl};
pub use crate::date_utils::periods::{DatePeriodUtils, DatePeriodUtilsImpl};

pub use crate::string_utils::case_conversion::{StringCaseUtils, StringCaseUtilsImpl};
pub use crate::string_utils::formatting::{StringFormattingUtils, StringFormattingUtilsImpl};
pub use crate::string_utils::parsing::{StringParsingUtils, StringParsingUtilsImpl};

pub use crate::pnr_utils::generation::{generate_pnr, PnrPool};
pub use crate::pnr_utils::types::{FamilyInfo, Gender, ParentPair, PersonInfo};
pub use crate::pnr_utils::validation::{PnrValidationUtils, PnrValidationUtilsImpl};
</file>

<file path="src/logging.rs">
use crate::error::{logging_error, Context, Result};
use colored::Colorize;
use log::{Level, LevelFilter, Record};
use std::fs::{File, OpenOptions};
use std::io::Write;
use std::path::Path;
use std::time::{Duration, Instant};

/// Simple logger that writes to both console and a file
pub struct SimpleLogger {
    log_file: Option<File>,
    console_level: LevelFilter,
    file_level: LevelFilter,
}

impl SimpleLogger {
    /// Create a new logger with the specified log file and level filters
    pub fn new(
        log_path: Option<&Path>,
        console_level: LevelFilter,
        file_level: LevelFilter,
    ) -> Result<Self> {
        let log_file = if let Some(path) = log_path {
            // Create the directory structure if it doesn't exist
            if let Some(parent) = path.parent() {
                std::fs::create_dir_all(parent)
                    .with_context(|| format!("Failed to create log directory: {parent:?}"))?;
            }

            Some(
                OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(path)
                    .with_context(|| format!("Failed to open log file: {path:?}"))?,
            )
        } else {
            None
        };

        Ok(Self {
            log_file,
            console_level,
            file_level,
        })
    }

    /// Write to the log file if configured
    fn write_to_file(&mut self, record: &Record) {
        if let Some(ref mut file) = self.log_file {
            if record.level() <= self.file_level {
                let timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S%.3f");
                let message = format!(
                    "[{}] {} [{}:{}] {}\n",
                    timestamp,
                    record.level(),
                    record.file().unwrap_or("unknown"),
                    record.line().unwrap_or(0),
                    record.args()
                );

                let _ = file.write_all(message.as_bytes());
                let _ = file.flush();
            }
        }
    }

    /// Write to the console if the level matches
    fn write_to_console(&self, record: &Record) {
        if record.level() <= self.console_level {
            match record.level() {
                Level::Error => eprintln!("{} {}", "ERROR:".bright_red().bold(), record.args()),
                Level::Warn => eprintln!("{} {}", "WARN:".yellow().bold(), record.args()),
                Level::Info => println!("{} {}", "INFO:".bright_blue().bold(), record.args()),
                Level::Debug => println!("{} {}", "DEBUG:".bright_cyan(), record.args()),
                Level::Trace => println!("{} {}", "TRACE:".dimmed(), record.args()),
            }
        }
    }
}

impl log::Log for SimpleLogger {
    fn enabled(&self, metadata: &log::Metadata) -> bool {
        metadata.level() <= self.console_level || metadata.level() <= self.file_level
    }

    fn log(&self, record: &log::Record) {
        if self.enabled(record.metadata()) {
            let mut logger = Self {
                log_file: None,
                console_level: self.console_level,
                file_level: self.file_level,
            };

            if let Some(ref file) = self.log_file {
                if let Ok(fd) = file.try_clone() {
                    logger.log_file = Some(fd);
                }
            }

            logger.write_to_file(record);
            self.write_to_console(record);
        }
    }

    fn flush(&self) {
        if let Some(ref file) = self.log_file {
            let _ = file.sync_all();
        }
    }
}

/// Configure and initialize the logger
pub fn setup_logger(
    log_file: Option<&Path>,
    console_level: LevelFilter,
    file_level: LevelFilter,
) -> Result<()> {
    let logger = SimpleLogger::new(log_file, console_level, file_level)?;

    // Initialize the global logger
    match log::set_boxed_logger(Box::new(logger)) {
        Ok(()) => {
            // Set the maximum log level based on both console and file levels
            log::set_max_level(std::cmp::max(console_level, file_level));
            log::info!(
                "Logger initialized with console level: {console_level:?}, file level: {file_level:?}"
            );
            Ok(())
        }
        Err(_) => Err(logging_error(
            "Failed to initialize logger: logger already set",
        )),
    }
}

/// A performance timer for logging execution times
pub struct PerformanceTimer {
    name: String,
    start: Instant,
    checkpoints: Vec<(String, Duration)>,
    silent: bool,
}

impl PerformanceTimer {
    /// Create a new performance timer with the given operation name
    #[must_use] pub fn new(operation_name: &str) -> Self {
        Self {
            name: operation_name.to_string(),
            start: Instant::now(),
            checkpoints: Vec::new(),
            silent: false,
        }
    }

    /// Create a new performance timer that doesn't log its results
    #[must_use] pub fn silent(operation_name: &str) -> Self {
        Self {
            name: operation_name.to_string(),
            start: Instant::now(),
            checkpoints: Vec::new(),
            silent: true,
        }
    }

    /// Record a checkpoint in the timer
    pub fn checkpoint(&mut self, checkpoint_name: &str) {
        self.checkpoints
            .push((checkpoint_name.to_string(), self.start.elapsed()));
    }

    /// Complete the timer and log the performance data
    pub fn finish(&mut self) -> Duration {
        let total_duration = self.start.elapsed();

        if !self.silent {
            // Log the total time
            log::debug!(
                "{} {} {} {}",
                "PERF:".bright_magenta().bold(),
                self.name.yellow(),
                "completed in".dimmed(),
                format!("{total_duration:.2?}").green()
            );

            // Log checkpoints if any
            if !self.checkpoints.is_empty() {
                let mut checkpoint_logs = Vec::new();
                let mut last_time = Duration::from_secs(0);

                for (name, time) in &self.checkpoints {
                    let segment_duration = *time - last_time;
                    checkpoint_logs.push(format!("{}: {:.2?}", name.blue(), segment_duration));
                    last_time = *time;
                }

                // Add the final segment if there's a gap
                if last_time < total_duration {
                    let final_segment = total_duration - last_time;
                    checkpoint_logs.push(format!("{}: {:.2?}", "final".blue(), final_segment));
                }

                log::debug!(
                    "{} {} {}",
                    "PERF:".bright_magenta().bold(),
                    self.name.yellow(),
                    format!("checkpoints: {}", checkpoint_logs.join(", ")).dimmed()
                );
            }
        }

        total_duration
    }

    /// Get the elapsed time without finishing the timer
    #[must_use] pub fn elapsed(&self) -> Duration {
        self.start.elapsed()
    }

    /// Format a time duration in a human-readable format
    #[must_use] pub fn format_duration(duration: Duration) -> String {
        let secs = duration.as_secs();
        let millis = duration.subsec_millis();

        if secs == 0 {
            format!("{millis} ms")
        } else if secs < 60 {
            format!("{secs}.{millis:03} s")
        } else {
            let mins = secs / 60;
            let secs = secs % 60;
            format!("{mins}m {secs}s")
        }
    }
}

/// Shorthand function to time a closure and log its execution time
pub fn time_operation<F, T>(operation_name: &str, f: F) -> T
where
    F: FnOnce() -> T,
{
    let timer = Instant::now();
    let result = f();
    let duration = timer.elapsed();

    log::debug!(
        "{} {} {} {}",
        "PERF:".bright_magenta().bold(),
        operation_name.yellow(),
        "completed in".dimmed(),
        format!("{duration:.2?}").green()
    );

    result
}

/// Measure memory usage before and after an operation (currently stub - platform dependent)
pub fn measure_memory_usage<F, T>(operation_name: &str, f: F) -> T
where
    F: FnOnce() -> T,
{
    // In a real implementation, we would measure memory before

    let result = f();

    // And measure memory after, then log the difference
    // This is platform dependent and would require additional dependencies

    log::debug!(
        "{} {} {}",
        "MEM:".bright_cyan().bold(),
        operation_name.yellow(),
        "(Memory measurement not implemented)".dimmed()
    );

    result
}

/// Console output utilities for structured information display
pub struct ConsoleOutput;

impl ConsoleOutput {
    /// Print a section header
    pub fn section(title: &str) {
        println!("\n{}", title.green().bold());
        println!("{}", "═".repeat(title.len()).green());
    }

    /// Print a subsection header
    pub fn subsection(title: &str) {
        println!("\n{}", title.blue().bold());
        println!("{}", "─".repeat(title.len()).blue());
    }

    /// Print a key-value pair with optional formatting
    pub fn key_value(key: &str, value: &str) {
        println!("{}: {}", key.bold(), value);
    }

    /// Print a key-value pair with colored value
    pub fn key_value_colored(key: &str, value: &str, success: bool) {
        let colored_value = if success { value.green() } else { value.red() };
        println!("{}: {}", key.bold(), colored_value);
    }

    /// Print a success message
    pub fn success(message: &str) {
        println!("{} {}", "✓".green().bold(), message);
    }

    /// Print an error message
    pub fn error(message: &str) {
        eprintln!("{} {}", "✗".red().bold(), message);
    }

    /// Print a warning message
    pub fn warning(message: &str) {
        println!("{} {}", "!".yellow().bold(), message);
    }

    /// Format a percentage with appropriate color based on value
    #[must_use] pub fn format_percentage(value: f64) -> colored::ColoredString {
        let percentage = format!("{:.2}%", value * 100.0);
        if value >= 0.9 {
            percentage.green()
        } else if value >= 0.7 {
            percentage.yellow()
        } else {
            percentage.red()
        }
    }

    /// Format a number with appropriate units (K, M, B)
    #[must_use] pub fn format_number(num: usize) -> String {
        if num < 1_000 {
            num.to_string()
        } else if num < 1_000_000 {
            format!("{:.2}K", num as f64 / 1_000.0)
        } else if num < 1_000_000_000 {
            format!("{:.2}M", num as f64 / 1_000_000.0)
        } else {
            format!("{:.2}B", num as f64 / 1_000_000_000.0)
        }
    }

    /// Print a progress status
    pub fn status(step: usize, total: usize, description: &str) {
        let progress = format!("[{step}/{total}]").blue();
        println!("{progress} {description}");
    }

    /// Print a table with headers and rows
    pub fn table(headers: &[&str], rows: &[Vec<String>]) {
        // Determine column widths
        let mut widths = headers.iter().map(|h| h.len()).collect::<Vec<_>>();

        for row in rows {
            for (i, cell) in row.iter().enumerate() {
                if i < widths.len() {
                    widths[i] = widths[i].max(cell.len());
                }
            }
        }

        // Print headers
        print!("│ ");
        for (i, header) in headers.iter().enumerate() {
            let padding = " ".repeat(widths[i].saturating_sub(header.len()));
            print!("{}{} │ ", header.bold(), padding);
        }
        println!();

        // Print separator
        print!("├─");
        for (_, width) in widths.iter().enumerate().take(headers.len()) {
            print!("{}┼─", "─".repeat(width + 1));
        }
        println!();

        // Print rows
        for row in rows {
            print!("│ ");
            for (i, cell) in row.iter().enumerate() {
                if i < widths.len() {
                    let padding = " ".repeat(widths[i].saturating_sub(cell.len()));
                    print!("{cell}{padding} │ ");
                }
            }
            println!();
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use log::{debug, error, info, trace, warn};
    use std::io::Read;
    use std::thread::sleep;
    use tempfile::NamedTempFile;

    #[test]
    fn test_logger_levels() {
        let temp_file = NamedTempFile::new().unwrap();

        // Initialize logger with different levels for console and file
        let result = setup_logger(
            Some(temp_file.path()),
            LevelFilter::Info,  // Console: only info and higher
            LevelFilter::Debug, // File: debug and higher
        );

        assert!(result.is_ok());

        // Log messages at different levels
        error!("This is an error");
        warn!("This is a warning");
        info!("This is an info message");
        debug!("This is a debug message");
        trace!("This is a trace message");

        // Verify log contents
        let mut file_content = String::new();
        let mut file = OpenOptions::new()
            .read(true)
            .open(temp_file.path())
            .unwrap();

        file.read_to_string(&mut file_content).unwrap();

        // Check that error, warn, info, and debug messages are in the file
        assert!(file_content.contains("ERROR"));
        assert!(file_content.contains("WARN"));
        assert!(file_content.contains("INFO"));
        assert!(file_content.contains("DEBUG"));

        // Check that trace messages are NOT in the file
        assert!(!file_content.contains("TRACE"));
    }

    #[test]
    fn test_performance_timer() {
        // Setup logging to see the output
        let temp_file = NamedTempFile::new().unwrap();
        let _ = setup_logger(
            Some(temp_file.path()),
            LevelFilter::Debug,
            LevelFilter::Debug,
        );

        let mut timer = PerformanceTimer::new("test_operation");

        // Simulate some work
        sleep(Duration::from_millis(10));
        timer.checkpoint("step1");

        sleep(Duration::from_millis(20));
        timer.checkpoint("step2");

        sleep(Duration::from_millis(15));
        let duration = timer.finish();

        assert!(
            duration.as_millis() >= 45,
            "Timer should record at least 45ms"
        );

        // Test the time_operation helper
        let result = time_operation("simple_add", || {
            sleep(Duration::from_millis(10));
            2 + 2
        });

        assert_eq!(result, 4);

        // Test memory measurement stub
        let result = measure_memory_usage("memory_test", || {
            let mut v = Vec::new();
            for i in 0..1000 {
                v.push(i);
            }
            v.len()
        });

        assert_eq!(result, 1000);
    }
}
</file>

<file path="src/rich_console.rs">
use console::{Style, Term};
use std::fmt::Display;
use std::io;

/// Rich Console UI for enhanced terminal output
///
/// This module provides a Rich-like terminal UI experience with panels, tables,
/// and styled output. It's designed to improve the aesthetics of CLI applications.
pub struct RichConsole {
    term: Term,
    width: u16,
}

/// Alignment options for text in tables and panels
pub enum Alignment {
    Left,
    Center,
    Right,
}

/// Box drawing characters for different box styles
pub struct BoxChars {
    pub top_left: &'static str,
    pub top_right: &'static str,
    pub bottom_left: &'static str,
    pub bottom_right: &'static str,
    pub horizontal: &'static str,
    pub vertical: &'static str,
    pub t_down: &'static str,
    pub t_up: &'static str,
    pub t_right: &'static str,
    pub t_left: &'static str,
    pub cross: &'static str,
}

/// Predefined box styles
pub enum BoxStyle {
    Single,
    Double,
    Rounded,
    Bold,
    Minimal,
}

impl BoxChars {
    /// Get a set of box drawing characters based on a style
    #[must_use] pub const fn from_style(style: BoxStyle) -> Self {
        match style {
            BoxStyle::Single => Self {
                top_left: "┌",
                top_right: "┐",
                bottom_left: "└",
                bottom_right: "┘",
                horizontal: "─",
                vertical: "│",
                t_down: "┬",
                t_up: "┴",
                t_right: "├",
                t_left: "┤",
                cross: "┼",
            },
            BoxStyle::Double => Self {
                top_left: "╔",
                top_right: "╗",
                bottom_left: "╚",
                bottom_right: "╝",
                horizontal: "═",
                vertical: "║",
                t_down: "╦",
                t_up: "╩",
                t_right: "╠",
                t_left: "╣",
                cross: "╬",
            },
            BoxStyle::Rounded => Self {
                top_left: "╭",
                top_right: "╮",
                bottom_left: "╰",
                bottom_right: "╯",
                horizontal: "─",
                vertical: "│",
                t_down: "┬",
                t_up: "┴",
                t_right: "├",
                t_left: "┤",
                cross: "┼",
            },
            BoxStyle::Bold => Self {
                top_left: "┏",
                top_right: "┓",
                bottom_left: "┗",
                bottom_right: "┛",
                horizontal: "━",
                vertical: "┃",
                t_down: "┳",
                t_up: "┻",
                t_right: "┣",
                t_left: "┫",
                cross: "╋",
            },
            BoxStyle::Minimal => Self {
                top_left: "┌",
                top_right: "┐",
                bottom_left: "└",
                bottom_right: "┘",
                horizontal: "─",
                vertical: "│",
                t_down: "┬",
                t_up: "┴",
                t_right: "├",
                t_left: "┤",
                cross: "┼",
            },
        }
    }
}

impl RichConsole {
    /// Create a new `RichConsole` instance
    #[must_use] pub fn new() -> Self {
        let term = Term::stdout();
        let (width, _) = term.size();
        Self { term, width }
    }

    /// Create a new `RichConsole` instance for stderr
    #[must_use] pub fn for_stderr() -> Self {
        let term = Term::stderr();
        let (width, _) = term.size();
        Self { term, width }
    }

    /// Get the current terminal width
    #[must_use] pub const fn width(&self) -> u16 {
        self.width
    }

    /// Force set a different terminal width (useful for testing or constrained output)
    pub const fn set_width(&mut self, width: u16) {
        self.width = width;
    }

    /// Refresh the terminal size
    pub fn refresh_size(&mut self) {
        let (width, _) = self.term.size();
        self.width = width;
    }

    /// Clear the current line
    pub fn clear_line(&self) -> io::Result<()> {
        self.term.clear_line()
    }

    /// Move the cursor up by n lines
    pub fn move_cursor_up(&self, n: usize) -> io::Result<()> {
        self.term.move_cursor_up(n)
    }

    /// Move the cursor down by n lines
    pub fn move_cursor_down(&self, n: usize) -> io::Result<()> {
        self.term.move_cursor_down(n)
    }

    /// Draw a horizontal rule with optional title
    pub fn rule<S: AsRef<str>>(&self, title: Option<S>) -> io::Result<()> {
        let width = self.width as usize;

        // Default style for the rule
        let rule_style = Style::new().dim();
        let title_style = Style::new().bold();

        // Character to use for the rule
        let rule_char = "─";

        match title {
            Some(title) => {
                let title = title.as_ref();
                let title_len = console::measure_text_width(title);

                // Calculate padding on each side of the title
                let padding = (width - title_len) / 2;
                if padding <= 0 {
                    // Title is too long, just print it
                    self.term
                        .write_line(&format!(" {} ", title_style.apply_to(title)))?;
                } else {
                    // Create the rule with the title in the middle
                    let left_pad = rule_style.apply_to(rule_char.repeat(padding - 1));
                    let right_pad =
                        rule_style.apply_to(rule_char.repeat(width - padding - title_len - 1));
                    self.term.write_line(&format!(
                        "{} {} {}",
                        left_pad,
                        title_style.apply_to(title),
                        right_pad
                    ))?;
                }
            }
            None => {
                // Just a plain rule
                self.term
                    .write_line(&rule_style.apply_to(rule_char.repeat(width)).to_string())?;
            }
        }

        Ok(())
    }

    /// Draw a panel with a title and content
    pub fn panel<S, F>(&self, title: S, content: F) -> io::Result<()>
    where
        S: AsRef<str>,
        F: FnOnce(&Self) -> io::Result<()>,
    {
        self.panel_with_style(title, BoxStyle::Rounded, content)
    }

    /// Draw a panel with a title, custom box style, and content
    pub fn panel_with_style<S, F>(
        &self,
        title: S,
        box_style: BoxStyle,
        content: F,
    ) -> io::Result<()>
    where
        S: AsRef<str>,
        F: FnOnce(&Self) -> io::Result<()>,
    {
        let title = title.as_ref();
        let box_chars = BoxChars::from_style(box_style);
        let width = self.width as usize;

        // Default styles
        let border_style = Style::new().cyan();
        let title_style = Style::new().bold();

        // Top border with title
        let title_len = console::measure_text_width(title);
        let title_with_padding = format!(" {title} ");
        let title_with_padding_len = title_len + 2; // Add space on each side

        let left_border_len = 2; // The top-left corner + 1 horizontal
        let right_border_len = width.saturating_sub(left_border_len + title_with_padding_len);

        // Create the top border with title
        let top_border = format!(
            "{}{}{}{}{}",
            border_style.apply_to(box_chars.top_left),
            border_style.apply_to(box_chars.horizontal.to_string()),
            title_style.apply_to(title_with_padding),
            border_style.apply_to(
                box_chars
                    .horizontal
                    .repeat(right_border_len.saturating_sub(1))
            ),
            border_style.apply_to(box_chars.top_right)
        );
        self.term.write_line(&top_border)?;

        // Execute the content function
        content(self)?;

        // Bottom border
        let bottom_border = format!(
            "{}{}{}",
            border_style.apply_to(box_chars.bottom_left),
            border_style.apply_to(box_chars.horizontal.repeat(width.saturating_sub(2))),
            border_style.apply_to(box_chars.bottom_right)
        );
        self.term.write_line(&bottom_border)?;

        Ok(())
    }

    /// Print a header with a title
    pub fn header<S: AsRef<str>>(&self, title: S) -> io::Result<()> {
        let title = title.as_ref();
        let title_style = Style::new().bold().green();

        self.term.write_line("")?;
        self.term
            .write_line(&title_style.apply_to(title).to_string())?;

        // Underline with Unicode box character
        let width = console::measure_text_width(title);
        let underline = "═".repeat(width);
        let underline_style = Style::new().green();

        self.term
            .write_line(&underline_style.apply_to(underline).to_string())?;

        Ok(())
    }

    /// Print a subheader with a title
    pub fn subheader<S: AsRef<str>>(&self, title: S) -> io::Result<()> {
        let title = title.as_ref();
        let title_style = Style::new().bold().blue();

        self.term.write_line("")?;
        self.term
            .write_line(&title_style.apply_to(title).to_string())?;

        // Underline with Unicode box character (less prominent than header)
        let width = console::measure_text_width(title);
        let underline = "─".repeat(width);
        let underline_style = Style::new().blue();

        self.term
            .write_line(&underline_style.apply_to(underline).to_string())?;

        Ok(())
    }

    /// Print a key-value pair with default styling
    pub fn key_value<K, V>(&self, key: K, value: V) -> io::Result<()>
    where
        K: AsRef<str>,
        V: Display,
    {
        let key_style = Style::new().bold();
        self.key_value_with_style(key, value, key_style, Style::new())
    }

    /// Print a key-value pair with custom styling for key and value
    pub fn key_value_with_style<K, V>(
        &self,
        key: K,
        value: V,
        key_style: Style,
        value_style: Style,
    ) -> io::Result<()>
    where
        K: AsRef<str>,
        V: Display,
    {
        let key = key.as_ref();
        let value_str = format!("{value}");

        // Format with key-value styling
        let formatted_line = format!(
            "{}: {}",
            key_style.apply_to(key),
            value_style.apply_to(&value_str)
        );

        self.term.write_line(&formatted_line)?;
        Ok(())
    }

    /// Print a success message
    pub fn success<S: AsRef<str>>(&self, message: S) -> io::Result<()> {
        let message = message.as_ref();
        let symbol_style = Style::new().green().bold();
        let message_style = Style::new().green();

        self.term.write_line(&format!(
            "{} {}",
            symbol_style.apply_to("✓"),
            message_style.apply_to(message)
        ))?;
        Ok(())
    }

    /// Print an error message
    pub fn error<S: AsRef<str>>(&self, message: S) -> io::Result<()> {
        let message = message.as_ref();
        let symbol_style = Style::new().red().bold();
        let message_style = Style::new().red();

        self.term.write_line(&format!(
            "{} {}",
            symbol_style.apply_to("✗"),
            message_style.apply_to(message)
        ))?;
        Ok(())
    }

    /// Print a warning message
    pub fn warning<S: AsRef<str>>(&self, message: S) -> io::Result<()> {
        let message = message.as_ref();
        let symbol_style = Style::new().yellow().bold();
        let message_style = Style::new().yellow();

        self.term.write_line(&format!(
            "{} {}",
            symbol_style.apply_to("⚠"),
            message_style.apply_to(message)
        ))?;
        Ok(())
    }

    /// Print an info message
    pub fn info<S: AsRef<str>>(&self, message: S) -> io::Result<()> {
        let message = message.as_ref();
        let symbol_style = Style::new().blue().bold();
        let message_style = Style::new().blue();

        self.term.write_line(&format!(
            "{} {}",
            symbol_style.apply_to("ℹ"),
            message_style.apply_to(message)
        ))?;
        Ok(())
    }

    /// Print a status message with formatting
    pub fn status<S1: AsRef<str>, S2: AsRef<str>>(
        &self,
        status: S1,
        message: S2,
    ) -> io::Result<()> {
        let status = status.as_ref();
        let message = message.as_ref();

        let status_style = Style::new().bold().blue();
        let message_style = Style::new();

        self.term.write_line(&format!(
            "{} {}",
            status_style.apply_to(format!("[{status}]")),
            message_style.apply_to(message)
        ))?;
        Ok(())
    }

    /// Format a number with commas and appropriate scale (K, M, B)
    #[must_use] pub fn format_number(num: usize) -> String {
        if num < 1_000 {
            format!("{num}")
        } else if num < 1_000_000 {
            format!("{:.2}K", num as f64 / 1_000.0)
        } else if num < 1_000_000_000 {
            format!("{:.2}M", num as f64 / 1_000_000.0)
        } else {
            format!("{:.2}B", num as f64 / 1_000_000_000.0)
        }
    }

    /// Format a duration in a human-readable way
    #[must_use] pub fn format_duration(duration: std::time::Duration) -> String {
        let total_secs = duration.as_secs();
        let millis = duration.subsec_millis();

        if total_secs == 0 {
            format!("{millis}ms")
        } else if total_secs < 60 {
            format!("{total_secs}.{millis:03}s")
        } else {
            let mins = total_secs / 60;
            let secs = total_secs % 60;
            if mins < 60 {
                format!("{mins}m {secs}s")
            } else {
                let hours = mins / 60;
                let mins = mins % 60;
                format!("{hours}h {mins}m")
            }
        }
    }

    /// Draw a simple table with headers and rows
    pub fn table<S>(&self, headers: &[S], rows: &[Vec<String>]) -> io::Result<()>
    where
        S: AsRef<str>,
    {
        self.table_with_style(headers, rows, BoxStyle::Single)
    }

    /// Draw a table with custom box style
    pub fn table_with_style<S>(
        &self,
        headers: &[S],
        rows: &[Vec<String>],
        box_style: BoxStyle,
    ) -> io::Result<()>
    where
        S: AsRef<str>,
    {
        let box_chars = BoxChars::from_style(box_style);

        // Determine column widths
        let mut col_widths = Vec::with_capacity(headers.len());

        // Initialize with header widths
        for header in headers {
            col_widths.push(console::measure_text_width(header.as_ref()));
        }

        // Update with row content widths
        for row in rows {
            for (i, cell) in row.iter().enumerate() {
                if i < col_widths.len() {
                    let cell_width = console::measure_text_width(cell);
                    col_widths[i] = col_widths[i].max(cell_width);
                }
            }
        }

        // Style definitions
        let border_style = Style::new().dim();
        let header_style = Style::new().bold();

        // Top border
        let mut top_border = String::from(box_chars.top_left);
        for (i, width) in col_widths.iter().enumerate() {
            top_border.push_str(&box_chars.horizontal.repeat(width + 2));
            top_border.push_str(if i < col_widths.len() - 1 {
                box_chars.t_down
            } else {
                box_chars.top_right
            });
        }
        self.term
            .write_line(&border_style.apply_to(top_border).to_string())?;

        // Headers
        let mut header_row = String::from(box_chars.vertical);
        for (i, header) in headers.iter().enumerate() {
            let header_str = header.as_ref();
            let width = col_widths[i];
            let padding = width - console::measure_text_width(header_str);
            header_row.push_str(&format!(
                " {} {}",
                header_style.apply_to(header_str),
                " ".repeat(padding)
            ));
            header_row.push_str(box_chars.vertical);
        }
        self.term.write_line(&header_row)?;

        // Header-data separator
        let mut separator = String::from(box_chars.t_right);
        for (i, width) in col_widths.iter().enumerate() {
            separator.push_str(&box_chars.horizontal.repeat(width + 2));
            separator.push_str(if i < col_widths.len() - 1 {
                box_chars.cross
            } else {
                box_chars.t_left
            });
        }
        self.term
            .write_line(&border_style.apply_to(separator).to_string())?;

        // Data rows
        for row in rows {
            let mut data_row = String::from(box_chars.vertical);
            for (i, cell) in row.iter().enumerate() {
                if i < col_widths.len() {
                    let width = col_widths[i];
                    let padding = width - console::measure_text_width(cell);
                    data_row.push_str(&format!(" {}{} ", cell, " ".repeat(padding)));
                    data_row.push_str(box_chars.vertical);
                }
            }
            self.term.write_line(&data_row)?;
        }

        // Bottom border
        let mut bottom_border = String::from(box_chars.bottom_left);
        for (i, width) in col_widths.iter().enumerate() {
            bottom_border.push_str(&box_chars.horizontal.repeat(width + 2));
            bottom_border.push_str(if i < col_widths.len() - 1 {
                box_chars.t_up
            } else {
                box_chars.bottom_right
            });
        }
        self.term
            .write_line(&border_style.apply_to(bottom_border).to_string())?;

        Ok(())
    }

    /// Create a vertical bar chart in the terminal
    pub fn bar_chart<S, V>(
        &self,
        title: S,
        labels: &[S],
        values: &[V],
        max_value: Option<V>,
    ) -> io::Result<()>
    where
        S: AsRef<str>,
        V: Into<f64> + Copy + PartialOrd,
    {
        let title = title.as_ref();
        let max_height = 10; // Maximum height of bars

        // Calculate the maximum value
        let max_val = match max_value {
            Some(max) => max.into(),
            None => values.iter().map(|&v| v.into()).fold(0.0, f64::max),
        };

        // Styles
        let title_style = Style::new().bold();
        let label_style = Style::new();
        let bar_style = Style::new().green();

        // Title
        self.term
            .write_line(&title_style.apply_to(title).to_string())?;
        self.term.write_line("")?;

        // Calculate bar heights
        let heights: Vec<usize> = values
            .iter()
            .map(|&v| {
                let ratio = if max_val > 0.0 {
                    v.into() / max_val
                } else {
                    0.0
                };
                (ratio * max_height as f64).round() as usize
            })
            .collect();

        // Draw bars from top to bottom
        for h in (0..max_height).rev() {
            let mut line = String::new();

            for &height in &heights {
                if height > h {
                    line.push_str(&bar_style.apply_to("█").to_string());
                    line.push(' ');
                } else {
                    line.push_str("  ");
                }
            }

            self.term.write_line(&line)?;
        }

        // Draw the baseline
        let baseline = "─".repeat(heights.len() * 2);
        self.term
            .write_line(&Style::new().dim().apply_to(baseline).to_string())?;

        // Labels
        let mut labels_line = String::new();
        for label in labels {
            let label_text = label.as_ref();
            if label_text.len() <= 2 {
                labels_line.push_str(&label_style.apply_to(label_text).to_string());
            } else {
                // Truncate long labels
                labels_line.push_str(&label_style.apply_to(&label_text[0..2]).to_string());
            }
            labels_line.push(' ');
        }

        self.term.write_line(&labels_line)?;

        Ok(())
    }
}

impl Default for RichConsole {
    fn default() -> Self {
        Self::new()
    }
}
</file>

<file path="src/string.rs">
use crate::error::{validation_error, Result};

/// Utility trait for string operations
pub trait StringUtils {
    /// Convert a string to title case
    fn to_title_case(s: &str) -> String;

    /// Convert a string to snake case
    fn to_snake_case(s: &str) -> String;

    /// Convert a string to camel case
    fn to_camel_case(s: &str) -> String;

    /// Parse a string as an i32, with a custom error message
    fn parse_i32(s: &str, error_msg: &str) -> Result<i32>;

    /// Parse a string as an f64, with a custom error message
    fn parse_f64(s: &str, error_msg: &str) -> Result<f64>;

    /// Truncate a string to a maximum length with ellipsis
    fn truncate(s: &str, max_length: usize) -> String;
}

/// Implementation of `StringUtils`
pub struct StringUtilsImpl;

impl StringUtils for StringUtilsImpl {
    fn to_title_case(s: &str) -> String {
        s.split_whitespace()
            .map(|word| {
                if word.is_empty() {
                    word.to_string()
                } else {
                    let mut chars = word.chars();
                    chars.next().map_or_else(String::new, |first| {
                        first.to_uppercase().collect::<String>() + chars.as_str()
                    })
                }
            })
            .collect::<Vec<String>>()
            .join(" ")
    }

    fn to_snake_case(s: &str) -> String {
        // First separate by spaces
        let mut result = String::new();
        let mut prev_is_uppercase = false;

        for c in s.chars() {
            if c.is_uppercase() {
                if !prev_is_uppercase && !result.is_empty() && !result.ends_with('_') {
                    result.push('_');
                }
                result.push(c.to_lowercase().next().unwrap());
                prev_is_uppercase = true;
            } else if c == ' ' || c == '-' {
                result.push('_');
                prev_is_uppercase = false;
            } else {
                result.push(c);
                prev_is_uppercase = false;
            }
        }

        result
    }

    fn to_camel_case(s: &str) -> String {
        let mut result = String::new();
        let mut capitalize_next = false;

        for c in s.chars() {
            if c == ' ' || c == '_' || c == '-' {
                capitalize_next = true;
            } else if capitalize_next {
                result.push(c.to_uppercase().next().unwrap());
                capitalize_next = false;
            } else if result.is_empty() {
                result.push(c.to_lowercase().next().unwrap());
            } else {
                result.push(c);
            }
        }

        result
    }

    fn parse_i32(s: &str, error_msg: &str) -> Result<i32> {
        s.trim()
            .parse::<i32>()
            .map_err(|_| validation_error(format!("{error_msg}: '{s}'")))
    }

    fn parse_f64(s: &str, error_msg: &str) -> Result<f64> {
        s.trim()
            .parse::<f64>()
            .map_err(|_| validation_error(format!("{error_msg}: '{s}'")))
    }

    fn truncate(s: &str, max_length: usize) -> String {
        if s.len() <= max_length {
            return s.to_string();
        }

        // Try to truncate at a word boundary
        let truncated = &s[0..max_length.saturating_sub(3)];
        let mut result = String::from(truncated);

        // Find the last space to truncate at a word boundary
        if let Some(last_space) = result.rfind(' ') {
            result.truncate(last_space);
        }

        result.push_str("...");
        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_title_case() {
        assert_eq!(StringUtilsImpl::to_title_case("hello world"), "Hello World");
        assert_eq!(StringUtilsImpl::to_title_case("HELLO WORLD"), "HELLO WORLD");
        assert_eq!(StringUtilsImpl::to_title_case("hello_world"), "Hello_world");
    }

    #[test]
    fn test_to_snake_case() {
        assert_eq!(StringUtilsImpl::to_snake_case("HelloWorld"), "hello_world");
        assert_eq!(StringUtilsImpl::to_snake_case("hello world"), "hello_world");
        assert_eq!(StringUtilsImpl::to_snake_case("Hello-World"), "hello_world");
    }

    #[test]
    fn test_to_camel_case() {
        assert_eq!(StringUtilsImpl::to_camel_case("hello_world"), "helloWorld");
        assert_eq!(StringUtilsImpl::to_camel_case("hello world"), "helloWorld");
        assert_eq!(StringUtilsImpl::to_camel_case("hello-world"), "helloWorld");
    }

    #[test]
    fn test_parse_i32() {
        assert_eq!(
            StringUtilsImpl::parse_i32("123", "Invalid number").unwrap(),
            123
        );
        assert!(StringUtilsImpl::parse_i32("abc", "Invalid number").is_err());
    }

    #[test]
    fn test_parse_f64() {
        assert_eq!(
            StringUtilsImpl::parse_f64("123.45", "Invalid number").unwrap(),
            123.45
        );
        assert!(StringUtilsImpl::parse_f64("abc", "Invalid number").is_err());
    }

    #[test]
    fn test_truncate() {
        assert_eq!(StringUtilsImpl::truncate("Hello world", 20), "Hello world");
        assert_eq!(StringUtilsImpl::truncate("Hello world", 8), "Hello...");
        assert_eq!(StringUtilsImpl::truncate("HelloWorld", 8), "Hello...");
    }
}
</file>

<file path="Cargo.toml">
[package]
name = "utils"
version.workspace = true
edition.workspace = true

[dependencies]
chrono.workspace = true
thiserror.workspace = true
serde.workspace = true
serde_json.workspace = true
hashbrown.workspace = true
rand.workspace = true
log = { workspace = true, features = ["std"] }
csv.workspace = true
colored.workspace = true
anyhow.workspace = true
tempfile.workspace = true
console = "0.15.11"
types = { path = "../types" }
regex = "1.11.1"
</file>

</files>
