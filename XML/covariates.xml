<directory_structure>
src/
  balance/
    checker/
      balance_calculation.rs
      builder.rs
      mod.rs
      paired_analysis.rs
      performance.rs
      README.md
    proc_impl/
      categorical.rs
      config.rs
      date_grouping.rs
      mod.rs
      numeric.rs
      progress.rs
      README.md
    memory.rs
    metrics.rs
    mod.rs
    optimization.rs
    processor.rs
    results.rs
    stats.rs
  core/
    config.rs
    mod.rs
    registry.rs
  data/
    matched_pairs/
      loader.rs
      mod.rs
      record.rs
    mod.rs
    storage.rs
  processing/
    demographic/
      mod.rs
    education/
      mod.rs
    income/
      mod.rs
    occupation/
      mod.rs
    factory.rs
    mod.rs
    processor.rs
  reporting/
    balance_report.rs
    comprehensive_report.rs
    csv_report.rs
    mod.rs
    structured_output.rs
  lib.rs
  models.rs
  prelude.rs
Cargo.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/balance/checker/balance_calculation.rs">
use super::BalanceChecker;
use crate::balance::results::BalanceResults;
use chrono::NaiveDate;
use indicatif::{ProgressBar, ProgressStyle};
use log::debug;
use types::error::IdsError;
use types::models::CovariateType;

impl BalanceChecker {
    /// Calculate balance metrics between case and control groups
    pub fn calculate_balance(
        &self,
        cases: &[(String, NaiveDate)],
        controls: &[(String, NaiveDate)],
    ) -> Result<BalanceResults, IdsError> {
        debug!(
            "Starting balance calculation for {} cases and {} controls",
            cases.len(),
            controls.len()
        );

        let multi_progress = indicatif::MultiProgress::new();
        let overall_style = ProgressStyle::default_bar()
            .template("[{elapsed_precise}] {bar:40.cyan/blue} {pos}/{len} {msg}")
            .expect("Failed to create progress bar template - this is a static template that should never fail");

        let overall_pb = multi_progress.add(ProgressBar::new(3)); // 3 steps: demographics, income, education
        overall_pb.set_style(overall_style);
        overall_pb.set_message("Calculating balance...");

        let mut results = BalanceResults::new();

        // Calculate overall balance
        self.add_all_balances(&mut results, cases, controls, &overall_pb)?;

        // Calculate matched pair details
        overall_pb.set_message("Processing matched pairs...");
        self.add_matched_pair_details(&mut results, cases, controls)?;
        overall_pb.finish_with_message("Balance calculation complete");

        self.log_balance_statistics(&results);
        Ok(results)
    }

    /// Calculate balance metrics for all covariate types
    fn add_all_balances(
        &self,
        results: &mut BalanceResults,
        cases: &[(String, NaiveDate)],
        controls: &[(String, NaiveDate)],
        overall_pb: &ProgressBar,
    ) -> Result<(), IdsError> {
        // Update progress bar to account for occupation processing
        let total_steps = 4; // demographics, income, education, occupation
        overall_pb.set_length(total_steps);

        overall_pb.set_message("Processing demographics...");
        self.calculate_demographic_balance(results, cases, controls)?;
        overall_pb.inc(1);

        overall_pb.set_message("Processing income...");
        self.calculate_income_balance(results, cases, controls)?;
        overall_pb.inc(1);

        overall_pb.set_message("Processing education...");
        self.calculate_education_balance(results, cases, controls)?;
        overall_pb.inc(1);

        overall_pb.set_message("Processing occupation...");
        self.calculate_occupation_balance(results, cases, controls)?;
        overall_pb.inc(1);

        Ok(())
    }

    fn calculate_demographic_balance(
        &self,
        results: &mut BalanceResults,
        cases: &[(String, NaiveDate)],
        controls: &[(String, NaiveDate)],
    ) -> Result<(), IdsError> {
        // Original variables
        let (summary, missing_rates) = self.metrics.calculate_numeric_balance(
            self,
            cases,
            controls,
            CovariateType::Demographics,
            "Family Size",
            |covariate| covariate.family_size().map(f64::from),
        )?;
        results.add_summary(summary);
        results.add_missing_rate("Family Size".to_string(), missing_rates.0, missing_rates.1);

        let (summary, missing_rates) = self.metrics.calculate_numeric_balance(
            self,
            cases,
            controls,
            CovariateType::Demographics,
            "Municipality",
            |covariate| covariate.municipality().map(f64::from),
        )?;
        results.add_summary(summary);
        results.add_missing_rate("Municipality".to_string(), missing_rates.0, missing_rates.1);

        let (summaries, missing_rates) = self.metrics.calculate_categorical_balance(
            self,
            cases,
            controls,
            CovariateType::Demographics,
            "Family Type",
            |covariate| covariate.family_type().map(|s| s.to_string()),
        )?;

        for summary in summaries {
            results.add_summary(summary);
        }
        results.add_missing_rate("Family Type".to_string(), missing_rates.0, missing_rates.1);

        // New variables from TROUBLE.md (BEF register)

        // Civil status (CIVST) - Categorical
        let (summaries, missing_rates) = self.metrics.calculate_categorical_balance(
            self,
            cases,
            controls,
            CovariateType::Demographics,
            "Civil Status",
            |covariate| covariate.civil_status().map(|s| s.to_string()),
        )?;

        for summary in summaries {
            results.add_summary(summary);
        }
        results.add_missing_rate("Civil Status".to_string(), missing_rates.0, missing_rates.1);

        // Gender (KOEN) - Categorical
        let (summaries, missing_rates) = self.metrics.calculate_categorical_balance(
            self,
            cases,
            controls,
            CovariateType::Demographics,
            "Gender",
            |covariate| covariate.gender().map(|s| s.to_string()),
        )?;

        for summary in summaries {
            results.add_summary(summary);
        }
        results.add_missing_rate("Gender".to_string(), missing_rates.0, missing_rates.1);

        // Citizenship (STATSB) - Categorical
        let (summaries, missing_rates) = self.metrics.calculate_categorical_balance(
            self,
            cases,
            controls,
            CovariateType::Demographics,
            "Citizenship",
            |covariate| covariate.citizenship().map(|s| s.to_string()),
        )?;

        for summary in summaries {
            results.add_summary(summary);
        }
        results.add_missing_rate("Citizenship".to_string(), missing_rates.0, missing_rates.1);

        // Age (ALDER) - Numeric
        let (summary, missing_rates) = self.metrics.calculate_numeric_balance(
            self,
            cases,
            controls,
            CovariateType::Demographics,
            "Age",
            |covariate| covariate.age().map(f64::from),
        )?;
        results.add_summary(summary);
        results.add_missing_rate("Age".to_string(), missing_rates.0, missing_rates.1);

        // Children count (ANTBOERNF/ANTBOERNH) - Numeric
        let (summary, missing_rates) = self.metrics.calculate_numeric_balance(
            self,
            cases,
            controls,
            CovariateType::Demographics,
            "Children Count",
            |covariate| covariate.children_count().map(f64::from),
        )?;
        results.add_summary(summary);
        results.add_missing_rate(
            "Children Count".to_string(),
            missing_rates.0,
            missing_rates.1,
        );

        Ok(())
    }

    fn calculate_income_balance(
        &self,
        results: &mut BalanceResults,
        cases: &[(String, NaiveDate)],
        controls: &[(String, NaiveDate)],
    ) -> Result<(), IdsError> {
        // Original income variable
        let (summary, missing_rates) = self.metrics.calculate_numeric_balance(
            self,
            cases,
            controls,
            CovariateType::Income,
            "Income",
            types::Covariate::income_amount,
        )?;

        results.add_summary(summary);
        results.add_missing_rate("Income".to_string(), missing_rates.0, missing_rates.1);

        // New variables from TROUBLE.md (IND register)

        // Wage income (LOENMV_13) - Numeric
        let (summary, missing_rates) = self.metrics.calculate_numeric_balance(
            self,
            cases,
            controls,
            CovariateType::Income,
            "Wage Income",
            types::Covariate::wage_income,
        )?;

        results.add_summary(summary);
        results.add_missing_rate("Wage Income".to_string(), missing_rates.0, missing_rates.1);

        // Employment status (BESKST13) - Numeric categorical
        let (summary, missing_rates) = self.metrics.calculate_numeric_balance(
            self,
            cases,
            controls,
            CovariateType::Income,
            "Employment Status",
            |covariate| covariate.employment_status().map(f64::from),
        )?;

        results.add_summary(summary);
        results.add_missing_rate(
            "Employment Status".to_string(),
            missing_rates.0,
            missing_rates.1,
        );

        // Also add as categorical for better representation
        let (summaries, missing_rates) = self.metrics.calculate_categorical_balance(
            self,
            cases,
            controls,
            CovariateType::Income,
            "Employment Status Category",
            |covariate| covariate.employment_status().map(|val| val.to_string()),
        )?;

        for summary in summaries {
            results.add_summary(summary);
        }
        results.add_missing_rate(
            "Employment Status Category".to_string(),
            missing_rates.0,
            missing_rates.1,
        );

        Ok(())
    }

    fn calculate_education_balance(
        &self,
        results: &mut BalanceResults,
        cases: &[(String, NaiveDate)],
        controls: &[(String, NaiveDate)],
    ) -> Result<(), IdsError> {
        // 1. Process education levels as categorical variables
        let (summaries, missing_rates) = self.metrics.calculate_categorical_balance(
            self,
            cases,
            controls,
            CovariateType::Education,
            "Education Level",
            |covariate| covariate.education_level().map(|s| s.to_string()),
        )?;

        for summary in summaries {
            results.add_summary(summary);
        }
        results.add_missing_rate(
            "Education Level".to_string(),
            missing_rates.0,
            missing_rates.1,
        );

        // 2. Process ISCED codes as a separate categorical variable
        // Only if ISCED codes are available in the data
        let (isced_summaries, isced_missing_rates) = self.metrics.calculate_categorical_balance(
            self,
            cases,
            controls,
            CovariateType::Education,
            "ISCED Level",
            |covariate| covariate.isced_code().map(|s| s.to_string()),
        )?;

        for summary in isced_summaries {
            results.add_summary(summary);
        }
        results.add_missing_rate(
            "ISCED Level".to_string(),
            isced_missing_rates.0,
            isced_missing_rates.1,
        );

        // 3. Process education years as a numeric variable (if available)
        let (years_summary, years_missing_rates) = self.metrics.calculate_numeric_balance(
            self,
            cases,
            controls,
            CovariateType::Education,
            "Education Years",
            |covariate| covariate.education_years().map(f64::from),
        )?;

        results.add_summary(years_summary);
        results.add_missing_rate(
            "Education Years".to_string(),
            years_missing_rates.0,
            years_missing_rates.1,
        );

        Ok(())
    }

    fn calculate_occupation_balance(
        &self,
        results: &mut BalanceResults,
        cases: &[(String, NaiveDate)],
        controls: &[(String, NaiveDate)],
    ) -> Result<(), IdsError> {
        // 1. Process SOCIO13 codes as categorical variables
        let (code_summaries, code_missing_rates) = self.metrics.calculate_categorical_balance(
            self,
            cases,
            controls,
            CovariateType::Occupation,
            "SOCIO13 Code",
            |covariate| covariate.occupation_code().map(|s| s.to_string()),
        )?;

        for summary in code_summaries {
            results.add_summary(summary);
        }
        results.add_missing_rate(
            "SOCIO13 Code".to_string(),
            code_missing_rates.0,
            code_missing_rates.1,
        );

        // 2. Process SOCIO13 codes as a numeric variable for standardized difference calculation
        let (socio_summary, socio_missing_rates) = self.metrics.calculate_numeric_balance(
            self,
            cases,
            controls,
            CovariateType::Occupation,
            "SOCIO13 Value",
            |covariate| {
                covariate
                    .occupation_code()
                    .clone()
                    .and_then(|code| code.parse::<f64>().ok())
            },
        )?;

        results.add_summary(socio_summary);
        results.add_missing_rate(
            "SOCIO13 Value".to_string(),
            socio_missing_rates.0,
            socio_missing_rates.1,
        );

        // 3. Process occupation classification system as a separate categorical variable
        // This might be used for different versions or systems (DISCO, ISCO, etc.)
        let (class_summaries, class_missing_rates) = self.metrics.calculate_categorical_balance(
            self,
            cases,
            controls,
            CovariateType::Occupation,
            "Classification System",
            |covariate| covariate.classification().map(|s| s.to_string()),
        )?;

        for summary in class_summaries {
            results.add_summary(summary);
        }
        results.add_missing_rate(
            "Classification System".to_string(),
            class_missing_rates.0,
            class_missing_rates.1,
        );

        // New variables from TROUBLE.md (AKM register)

        // SOCIO - older socioeconomic classification
        let (socio_summary, socio_missing_rates) = self.metrics.calculate_numeric_balance(
            self,
            cases,
            controls,
            CovariateType::Occupation,
            "SOCIO",
            |covariate| covariate.socio().map(f64::from),
        )?;

        results.add_summary(socio_summary);
        results.add_missing_rate(
            "SOCIO".to_string(),
            socio_missing_rates.0,
            socio_missing_rates.1,
        );

        // Also as categorical
        let (summaries, missing_rates) = self.metrics.calculate_categorical_balance(
            self,
            cases,
            controls,
            CovariateType::Occupation,
            "SOCIO Category",
            |covariate| covariate.socio().map(|val| val.to_string()),
        )?;

        for summary in summaries {
            results.add_summary(summary);
        }
        results.add_missing_rate(
            "SOCIO Category".to_string(),
            missing_rates.0,
            missing_rates.1,
        );

        // SOCIO02 - another socioeconomic classification
        let (socio02_summary, socio02_missing_rates) = self.metrics.calculate_numeric_balance(
            self,
            cases,
            controls,
            CovariateType::Occupation,
            "SOCIO02",
            |covariate| covariate.socio02().map(f64::from),
        )?;

        results.add_summary(socio02_summary);
        results.add_missing_rate(
            "SOCIO02".to_string(),
            socio02_missing_rates.0,
            socio02_missing_rates.1,
        );

        // Also as categorical
        let (summaries, missing_rates) = self.metrics.calculate_categorical_balance(
            self,
            cases,
            controls,
            CovariateType::Occupation,
            "SOCIO02 Category",
            |covariate| covariate.socio02().map(|val| val.to_string()),
        )?;

        for summary in summaries {
            results.add_summary(summary);
        }
        results.add_missing_rate(
            "SOCIO02 Category".to_string(),
            missing_rates.0,
            missing_rates.1,
        );

        // PRE_SOCIO - previous socioeconomic status
        let (pre_socio_summary, pre_socio_missing_rates) = self.metrics.calculate_numeric_balance(
            self,
            cases,
            controls,
            CovariateType::Occupation,
            "Previous Socioeconomic Status",
            |covariate| covariate.pre_socio().map(f64::from),
        )?;

        results.add_summary(pre_socio_summary);
        results.add_missing_rate(
            "Previous Socioeconomic Status".to_string(),
            pre_socio_missing_rates.0,
            pre_socio_missing_rates.1,
        );

        // Also as categorical
        let (summaries, missing_rates) = self.metrics.calculate_categorical_balance(
            self,
            cases,
            controls,
            CovariateType::Occupation,
            "Previous Socioeconomic Category",
            |covariate| covariate.pre_socio().map(|val| val.to_string()),
        )?;

        for summary in summaries {
            results.add_summary(summary);
        }
        results.add_missing_rate(
            "Previous Socioeconomic Category".to_string(),
            missing_rates.0,
            missing_rates.1,
        );

        Ok(())
    }

    /// Log statistics about the balance calculation results
    fn log_balance_statistics(&self, results: &BalanceResults) {
        debug!("Balance calculation completed:");
        debug!("Total summaries: {}", results.summaries.len());
        debug!(
            "Total matched pair details: {}",
            results.matched_pair_details.len()
        );

        for summary in &results.summaries {
            if summary.std_diff.abs() > 0.1 {
                debug!(
                    "Large imbalance detected for {}: std_diff = {:.3}",
                    summary.variable, summary.std_diff
                );
            }
        }
    }
}
</file>

<file path="src/balance/checker/builder.rs">
use super::BalanceChecker;
use crate::balance::metrics::BalanceMetrics;
use types::{
    error::{IdsError, Result},
    storage::{arrow::backend::ArrowBackend as ArrowStore, CovariateCache, ThreadSafeStore},
};

/// Builder for `BalanceChecker` with configurable settings
pub struct BalanceCheckerBuilder {
    store: Option<ArrowStore>,
    cache_capacity: usize,
    debug_mode: bool,
}

impl Default for BalanceCheckerBuilder {
    fn default() -> Self {
        Self {
            store: None,
            cache_capacity: 100_000, // Default cache capacity
            debug_mode: false,
        }
    }
}

impl BalanceCheckerBuilder {
    /// Create a new builder with default settings
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }

    /// Set the data store for the `BalanceChecker`
    #[must_use] pub fn with_store(mut self, store: ArrowStore) -> Self {
        self.store = Some(store);
        self
    }

    /// Set the cache capacity for the `BalanceChecker`
    #[must_use] pub fn with_cache_capacity(mut self, capacity: usize) -> Self {
        self.cache_capacity = capacity;
        self
    }

    /// Enable or disable debug mode for the `BalanceChecker`
    #[must_use] pub fn with_debug_mode(mut self, debug: bool) -> Self {
        self.debug_mode = debug;
        self
    }

    /// Build the `BalanceChecker` with the configured settings
    ///
    /// # Errors
    ///
    /// Returns an error if no store was provided
    pub fn build(self) -> Result<BalanceChecker> {
        let store = self.store.ok_or_else(|| {
            IdsError::invalid_operation("Cannot build BalanceChecker without a store".to_string())
        })?;

        Ok(BalanceChecker {
            store: ThreadSafeStore::new(store),
            cache: CovariateCache::new(self.cache_capacity),
            metrics: BalanceMetrics::new(),
            results: None,
        })
    }
}
</file>

<file path="src/balance/checker/mod.rs">
// Core structure for the BalanceChecker with essential methods
mod balance_calculation;
pub mod builder;
mod paired_analysis;
mod performance;

use crate::balance::{metrics::BalanceMetrics, results::BalanceResults};
use crate::models::{CovariateSummary, MatchedPairDetail};
use chrono::NaiveDate;
use std::collections::HashMap;
use types::storage::{CacheKey, CovariateCache, ThreadSafeStore};
use types::{
    error::Result,
    models::{Covariate, CovariateType},
    storage::arrow::backend::ArrowBackend as ArrowStore,
    traits::Store,
};

// Re-export important types and the builder
pub use self::builder::BalanceCheckerBuilder;

/// Main balance checker for analyzing covariate balance between case and control groups
pub struct BalanceChecker {
    pub(crate) store: ThreadSafeStore<ArrowStore>,
    pub(crate) cache: CovariateCache,
    pub(crate) metrics: BalanceMetrics,
    pub(crate) results: Option<BalanceResults>,
}

impl BalanceChecker {
    /// Creates a new `BalanceChecker` with the provided data store
    #[must_use]
    pub fn new(store: ArrowStore) -> Self {
        Self {
            store: ThreadSafeStore::new(store),
            cache: CovariateCache::new(100_000),
            metrics: BalanceMetrics::new(),
            results: None,
        }
    }

    /// Returns a builder for creating a `BalanceChecker` with custom settings
    #[must_use] pub fn builder() -> BalanceCheckerBuilder {
        BalanceCheckerBuilder::new()
    }

    /// Get a covariate value for a specific PNR, type, and date
    pub fn covariate(
        &self,
        pnr: &str,
        covariate_type: CovariateType,
        date: NaiveDate,
    ) -> Result<Option<Covariate>> {
        let key = CacheKey::new(pnr, covariate_type, date);

        // First check the cache
        if let Some(value) = self.cache.get(&key) {
            return Ok(value);
        }

        // Not in cache, get from store
        let mut store = self.store.write();
        let value = store.covariate(pnr, covariate_type, date)?;

        // Cache the result
        self.cache.insert(key, value.clone());

        Ok(value)
    }

    /// Backward compatibility method, deprecated
    #[deprecated(note = "Use covariate method instead")]
    pub fn get_covariate(
        &self,
        pnr: &str,
        covariate_type: CovariateType,
        date: NaiveDate,
    ) -> Result<Option<Covariate>> {
        self.covariate(pnr, covariate_type, date)
    }

    /// Clears the covariate cache
    pub fn clear_cache(&self) {
        self.cache.clear();
    }

    /// Returns the current size of the covariate cache
    pub fn cache_size(&self) -> usize {
        self.cache.len()
    }

    /// Alias for `cache_size` for backward compatibility
    pub fn cache_len(&self) -> usize {
        self.cache.len()
    }

    /// Add a value to the cache (used for testing)
    pub fn add_to_cache(&self, key: CacheKey, value: Option<types::models::Covariate>) {
        self.cache.insert(key, value);
    }

    /// Get the summary for a specific variable from the results
    pub fn get_variable_summary(&self, variable: &str) -> Option<&CovariateSummary> {
        self.results
            .as_ref()
            .and_then(|r| r.summaries.iter().find(|s| s.variable == variable))
    }

    /// Get a reference to the results (mainly for testing)
    pub fn results(&self) -> Option<&BalanceResults> {
        self.results.as_ref()
    }

    /// Get matched pair details for a specific case PNR
    pub fn get_matched_pair_details(&self, case_pnr: &str) -> Vec<&MatchedPairDetail> {
        self.results
            .as_ref()
            .map(|r| {
                r.matched_pair_details
                    .iter()
                    .filter(|d| d.case_pnr == case_pnr)
                    .collect()
            })
            .unwrap_or_default()
    }

    /// Summarizes standardized differences across matched pairs
    pub fn summarize_std_differences(&self) -> HashMap<String, (f64, f64, f64)> {
        let mut summaries = HashMap::new();

        if let Some(results) = &self.results {
            for detail in &results.matched_pair_details {
                let stats = summaries
                    .entry(detail.variable.clone())
                    .or_insert((0.0, 0.0, 0));

                stats.0 += detail.std_diff;
                stats.1 += detail.std_diff.powi(2);
                stats.2 += 1;
            }
        }

        summaries
            .into_iter()
            .map(|(var, (sum, sum_sq, n))| {
                let n = f64::from(n);
                let mean = sum / n;
                let variance = (sum_sq / n) - mean.powi(2);
                (var, (mean, variance.sqrt(), n))
            })
            .collect()
    }
}
</file>

<file path="src/balance/checker/paired_analysis.rs">
use super::BalanceChecker;
use crate::balance::results::BalanceResults;
use crate::models::MatchedPairDetail;
use chrono::NaiveDate;
use hashbrown::HashMap;
use log::debug;
use parking_lot::Mutex;
use rayon::prelude::*;
use std::sync::Arc;
use types::error::IdsError;
use types::models::{Covariate, CovariateType};

impl BalanceChecker {
    /// Add matched pair details to the results
    pub(crate) fn add_matched_pair_details(
        &self,
        results: &mut BalanceResults,
        cases: &[(String, NaiveDate)],
        controls: &[(String, NaiveDate)],
    ) -> Result<(), IdsError> {
        // Group cases by date for better batch processing
        let mut cases_by_date: HashMap<NaiveDate, Vec<&str>> = HashMap::new();
        for (case_pnr, case_date) in cases {
            cases_by_date.entry(*case_date).or_default().push(case_pnr);
        }

        // Do the same for controls
        let mut controls_by_date: HashMap<NaiveDate, Vec<&str>> = HashMap::new();
        for (control_pnr, control_date) in controls {
            controls_by_date
                .entry(*control_date)
                .or_default()
                .push(control_pnr);
        }

        // Determine optimal chunk size based on number of pairs
        let total_pairs: usize = cases_by_date
            .iter()
            .map(|(date, case_pnrs)| {
                let control_count = controls_by_date.get(date).map_or(0, std::vec::Vec::len);
                case_pnrs.len() * control_count
            })
            .sum();

        let num_threads = rayon::current_num_threads();
        let chunk_size = (total_pairs / num_threads).clamp(100, 5000);

        debug!(
            "Processing {} matched pairs for {} cases and {} controls using chunk size {}",
            total_pairs,
            cases.len(),
            controls.len(),
            chunk_size
        );

        // Use a thread-safe container for collecting results
        let pair_details = Arc::new(Mutex::new(Vec::with_capacity(total_pairs * 4)));

        // Define the variables we'll use for prefetching - include Occupation
        let covariate_types = [
            CovariateType::Demographics,
            CovariateType::Income,
            CovariateType::Education,
            CovariateType::Occupation,
        ];

        // Convert HashMaps to Vecs for parallel processing
        let date_groups: Vec<(NaiveDate, Vec<&str>)> = cases_by_date.into_iter().collect();

        // Process each date group in parallel using rayon
        date_groups.par_iter().for_each(|(date, case_pnrs)| {
            // Get matching controls for this date
            let control_pnrs = match controls_by_date.get(date) {
                Some(pnrs) => pnrs,
                None => return, // No controls for this date
            };

            // For large enough groups, prefetch all the data we'll need
            if case_pnrs.len() * control_pnrs.len() > 100 {
                // Collect all PNRs for prefetching (both cases and controls)
                let mut all_pnrs = Vec::with_capacity(case_pnrs.len() + control_pnrs.len());
                all_pnrs.extend(case_pnrs.iter().map(|p| (*p).to_string()));
                all_pnrs.extend(control_pnrs.iter().map(|p| (*p).to_string()));

                // Prefetch all data for this date group
                self.prefetch_data(&all_pnrs, &covariate_types, &[*date]);
            }

            // Process each case-control pair
            for &case_pnr in case_pnrs {
                for &control_pnr in control_pnrs {
                    let mut batch_details = Vec::new();

                    // --- DEMOGRAPHICS ---

                    // Original variables

                    // Family Size
                    if let Ok(Some(detail)) = self.process_matched_pair(
                        case_pnr,
                        control_pnr,
                        *date,
                        CovariateType::Demographics,
                        "Family Size",
                        |cov| cov.family_size().map(f64::from),
                    ) {
                        batch_details.push(detail);
                    }

                    // Municipality
                    if let Ok(Some(detail)) = self.process_matched_pair(
                        case_pnr,
                        control_pnr,
                        *date,
                        CovariateType::Demographics,
                        "Municipality",
                        |cov| cov.municipality().map(f64::from),
                    ) {
                        batch_details.push(detail);
                    }

                    // New demographics variables

                    // Age
                    if let Ok(Some(detail)) = self.process_matched_pair(
                        case_pnr,
                        control_pnr,
                        *date,
                        CovariateType::Demographics,
                        "Age",
                        |cov| cov.age().map(f64::from),
                    ) {
                        batch_details.push(detail);
                    }

                    // Children Count
                    if let Ok(Some(detail)) = self.process_matched_pair(
                        case_pnr,
                        control_pnr,
                        *date,
                        CovariateType::Demographics,
                        "Children Count",
                        |cov| cov.children_count().map(f64::from),
                    ) {
                        batch_details.push(detail);
                    }

                    // --- INCOME ---

                    // Original income variable
                    if let Ok(Some(detail)) = self.process_matched_pair(
                        case_pnr,
                        control_pnr,
                        *date,
                        CovariateType::Income,
                        "Income",
                        types::Covariate::income_amount,
                    ) {
                        batch_details.push(detail);
                    }

                    // New income variables

                    // Wage Income
                    if let Ok(Some(detail)) = self.process_matched_pair(
                        case_pnr,
                        control_pnr,
                        *date,
                        CovariateType::Income,
                        "Wage Income",
                        types::Covariate::wage_income,
                    ) {
                        batch_details.push(detail);
                    }

                    // Employment Status
                    if let Ok(Some(detail)) = self.process_matched_pair(
                        case_pnr,
                        control_pnr,
                        *date,
                        CovariateType::Income,
                        "Employment Status",
                        |cov| cov.employment_status().map(f64::from),
                    ) {
                        batch_details.push(detail);
                    }

                    // --- EDUCATION ---

                    // Education Level - treated as a numeric value
                    if let Ok(Some(detail)) = self.process_matched_pair(
                        case_pnr,
                        control_pnr,
                        *date,
                        CovariateType::Education,
                        "Education Level",
                        |cov| {
                            cov.education_level()
                                .and_then(|level| level.parse::<f64>().ok())
                        },
                    ) {
                        batch_details.push(detail);
                    }

                    // ISCED Level - convert from string code to numeric value for comparison
                    if let Ok(Some(detail)) = self.process_matched_pair(
                        case_pnr,
                        control_pnr,
                        *date,
                        CovariateType::Education,
                        "ISCED Level",
                        |cov| {
                            cov.isced_code().and_then(|code| {
                                // Extract the first character which should be the ISCED level
                                if code.is_empty() {
                                    None
                                } else {
                                    code[0..1].parse::<f64>().ok()
                                }
                            })
                        },
                    ) {
                        batch_details.push(detail);
                    }

                    // Education Years - already a numeric value
                    if let Ok(Some(detail)) = self.process_matched_pair(
                        case_pnr,
                        control_pnr,
                        *date,
                        CovariateType::Education,
                        "Education Years",
                        |cov| cov.education_years().map(f64::from),
                    ) {
                        batch_details.push(detail);
                    }

                    // --- OCCUPATION ---

                    // Original occupation variables

                    // SOCIO13 Occupation Code - convert directly to numeric
                    if let Ok(Some(detail)) = self.process_matched_pair(
                        case_pnr,
                        control_pnr,
                        *date,
                        CovariateType::Occupation,
                        "SOCIO13 Value",
                        |cov| {
                            cov.occupation_code()
                                .and_then(|code| code.parse::<f64>().ok())
                        },
                    ) {
                        batch_details.push(detail);
                    }

                    // Classification System - treat as categorical but convert to numeric
                    // This is retained for compatibility with any non-SOCIO13 classification systems
                    if let Ok(Some(detail)) = self.process_matched_pair(
                        case_pnr,
                        control_pnr,
                        *date,
                        CovariateType::Occupation,
                        "Classification System",
                        |cov| {
                            cov.classification().map(|class| {
                                // Simple hash to create a numeric value for comparison
                                let mut hash = 0.0;
                                for (i, c) in class.chars().enumerate() {
                                    hash += f64::from(c as u32) * (i + 1) as f64;
                                }
                                hash
                            })
                        },
                    ) {
                        batch_details.push(detail);
                    }

                    // New occupation variables

                    // SOCIO
                    if let Ok(Some(detail)) = self.process_matched_pair(
                        case_pnr,
                        control_pnr,
                        *date,
                        CovariateType::Occupation,
                        "SOCIO",
                        |cov| cov.socio().map(f64::from),
                    ) {
                        batch_details.push(detail);
                    }

                    // SOCIO02
                    if let Ok(Some(detail)) = self.process_matched_pair(
                        case_pnr,
                        control_pnr,
                        *date,
                        CovariateType::Occupation,
                        "SOCIO02",
                        |cov| cov.socio02().map(f64::from),
                    ) {
                        batch_details.push(detail);
                    }

                    // PRE_SOCIO
                    if let Ok(Some(detail)) = self.process_matched_pair(
                        case_pnr,
                        control_pnr,
                        *date,
                        CovariateType::Occupation,
                        "Previous Socioeconomic Status",
                        |cov| cov.pre_socio().map(f64::from),
                    ) {
                        batch_details.push(detail);
                    }

                    // Add all details at once to minimize lock contention
                    if !batch_details.is_empty() {
                        let mut details = pair_details.lock();
                        details.extend(batch_details);
                    }
                }
            }
        });

        // Add all collected pair details to the results
        let collected_details = match Arc::try_unwrap(pair_details) {
            Ok(mutex) => mutex.into_inner(),
            Err(arc) => {
                let guard = arc.lock();
                guard.clone()
            }
        };

        log::debug!("Collected {} matched pair details", collected_details.len());

        for detail in collected_details {
            results.add_pair_detail(detail);
        }

        Ok(())
    }

    /// Process a single matched pair for a specific variable
    fn process_matched_pair(
        &self,
        case_pnr: &str,
        control_pnr: &str,
        date: NaiveDate,
        covariate_type: CovariateType,
        variable_name: &str,
        value_extractor: impl Fn(&Covariate) -> Option<f64>,
    ) -> Result<Option<MatchedPairDetail>, IdsError> {
        let case_value = self
            .covariate(case_pnr, covariate_type, date)?
            .as_ref()
            .and_then(&value_extractor);

        let control_value = self
            .covariate(control_pnr, covariate_type, date)?
            .as_ref()
            .and_then(&value_extractor);

        match (case_value, control_value) {
            (Some(case_val), Some(ctrl_val)) => Ok(Some(MatchedPairDetail::new(
                case_pnr.to_string(),
                vec![control_pnr.to_string()],
                date,
                variable_name.to_string(),
                case_val,
                ctrl_val,
                MatchedPairDetail::calculate_std_diff(case_val, ctrl_val),
            ))),
            _ => Ok(None),
        }
    }
}
</file>

<file path="src/balance/checker/performance.rs">
use super::BalanceChecker;
use types::error::IdsError;

impl BalanceChecker {
    /// Process data in parallel with optimal chunk sizing and workload balancing
    pub fn process_data_in_parallel<T, R, F>(
        &self,
        data: &[T],
        processor: F,
    ) -> Result<Vec<R>, IdsError>
    where
        T: Send + Sync,
        R: Send,
        F: Fn(&T) -> Result<R, IdsError> + Send + Sync,
    {
        use rayon::prelude::*;

        // Determine optimal chunk size based on number of items and available threads
        let num_threads = rayon::current_num_threads();
        let items_per_thread = div_ceil(data.len(), num_threads);
        let chunk_size = items_per_thread.clamp(1, 1000); // At least 1, at most 1000

        // Process data in parallel chunks
        data.par_chunks(chunk_size)
            .flat_map(|chunk| {
                chunk
                    .iter()
                    .map(&processor)
                    .collect::<Vec<Result<R, IdsError>>>()
            })
            .collect::<Result<Vec<R>, IdsError>>()
    }

    /// Get or compute a value with caching
    pub fn get_or_compute<K, V, F>(&self, _key: K, compute_fn: F) -> Result<V, IdsError>
    where
        K: std::hash::Hash + Eq + Clone,
        V: Clone,
        F: FnOnce() -> Result<V, IdsError>,
    {
        // This is a simplified implementation that doesn't use time-based caching
        // This would need to be expanded with thread-safe storage in a real implementation

        // For now, we'll just compute the value directly
        compute_fn()
    }

    /// Prefetch data for multiple PNRs and covariates to improve performance
    pub fn prefetch_data(
        &self,
        pnrs: &[String],
        covariate_types: &[types::models::CovariateType],
        dates: &[chrono::NaiveDate],
    ) -> usize {
        // Skip if the dataset is too small to benefit from prefetching
        if pnrs.len() * covariate_types.len() * dates.len() < 100 {
            return 0;
        }

        log::info!(
            "Prefetching data for {} PNRs, {} covariate types, and {} dates ({} total combinations)",
            pnrs.len(),
            covariate_types.len(),
            dates.len(),
            pnrs.len() * covariate_types.len() * dates.len()
        );

        let start = std::time::Instant::now();

        // Get a write lock on the store for exclusive access during bulk operations
        let mut store = self.store.write();

        match self
            .cache
            .bulk_load(&mut *store, pnrs, covariate_types, dates)
        {
            Ok(count) => {
                let elapsed = start.elapsed();
                log::info!(
                    "Prefetched {} covariate values in {:.2?} ({:.1} values/sec)",
                    count,
                    elapsed,
                    count as f64 / elapsed.as_secs_f64()
                );
                count
            }
            Err(e) => {
                log::warn!("Error during data prefetching: {e}");
                0
            }
        }
    }
}

// Helper function for integer division with ceiling
fn div_ceil(a: usize, b: usize) -> usize {
    assert!((b != 0), "Division by zero");
    let d = a / b;
    let r = a % b;
    if r > 0 && b > 0 {
        d + 1
    } else {
        d
    }
}
</file>

<file path="src/balance/checker/README.md">
# Balance Checker Module

This module implements the core functionality for analyzing covariate balance between case and control groups in matched studies. It provides tools to evaluate whether the matching process has resulted in comparable groups.

## Module Structure

The balance checker implementation is organized into these components:

- **mod.rs**: Exports the `BalanceChecker` struct and related types
- **builder.rs**: Implements the builder pattern for creating and configuring balance checkers
- **balance_calculation.rs**: Core logic for calculating balance metrics
- **paired_analysis.rs**: Functions for analyzing matched pairs
- **performance.rs**: Performance measurement and optimization utilities

## Key Components

### BalanceChecker

The main public interface for balance checking operations. It provides methods to:

- Check covariate balance between case and control groups
- Calculate standardized differences for numeric and categorical variables
- Generate detailed reports on balance metrics
- Fetch and cache covariates efficiently

### BalanceCheckerBuilder

A builder for creating and configuring `BalanceChecker` instances with specific settings:

```rust
let checker = BalanceCheckerBuilder::new()
    .with_store(data_store)
    .with_cache_capacity(200_000)
    .with_debug_mode(true)
    .build()?;
```

### Balance Calculation

The core logic for calculating balance metrics across different covariate types:

- **Demographics**: Age, gender, family size, geographic location
- **Income**: Earnings, employment status
- **Education**: Education level, years of education
- **Occupation**: Job type, industry sector

### Paired Analysis

Specialized analysis for matched pairs that calculates:

- Balance metrics for each case-control pair
- Standardized differences at the individual level
- Detailed statistics for matched pair quality

### Performance Optimization

The module uses several approaches to optimize performance:

- **Caching**: Cache frequently accessed covariates
- **Parallel Processing**: Process data in parallel using rayon
- **Batch Processing**: Group similar operations to improve throughput
- **Memory Management**: Adaptive memory usage based on system capabilities

## Usage Example

```rust
// Create a balance checker
let checker = BalanceCheckerBuilder::new()
    .with_store(data_store)
    .build()?;

// Run balance analysis
let results = checker.check_balance(&matched_pairs)?;

// View results
println!("Overall balance quality: {}", results.get_balance_quality());
println!("Imbalanced variables: {}", results.get_imbalanced_variables().len());

// Generate detailed report
let report = results.generate_report();
report.save_to_file("balance_report.html")?;
```

## Integration with Other Modules

The balance checker integrates with:

- **Processor**: For efficient data processing
- **Metrics**: For statistical calculations
- **Legacy Cache**: For optimized data access
- **Results**: For structured output generation

## Design Considerations

1. **Memory Efficiency**: The module is designed to handle large datasets efficiently
2. **Extensibility**: New covariate types and processors can be easily added
3. **Configurability**: Many aspects of the balance checking can be customized
4. **Reliability**: Comprehensive error handling and diagnostics
</file>

<file path="src/balance/proc_impl/categorical.rs">
use super::super::memory::MemoryGuard;
use super::super::BalanceChecker;
use super::config::ProcessorConfig;
use super::date_grouping::DateGroupingParams;
use super::progress::create_progress_style;
use super::OptimizationStrategy;
use chrono::NaiveDate;
use hashbrown::HashMap;
use indicatif::ParallelProgressIterator;
use rayon::prelude::*;
use std::time::Instant;
use types::models::{Covariate, CovariateType};

/// Processor for categorical covariate values
pub struct CategoricalProcessor {
    config: ProcessorConfig,
}

impl CategoricalProcessor {
    /// Create a new categorical processor with the given configuration
    pub fn new(config: ProcessorConfig) -> Self {
        Self { config }
    }

    /// Collect categorical values for a list of subjects
    pub fn collect_categorical_values<F>(
        &self,
        subjects: &[(String, NaiveDate)],
        covariate_type: CovariateType,
        checker: &BalanceChecker,
        extractor: &F,
    ) -> (Vec<String>, usize)
    where
        F: Fn(&Covariate) -> Option<String> + Send + Sync,
    {
        // Get the optimal chunk size for this workload
        let chunk_size = self.config.get_optimal_chunk_size(subjects.len());

        // Extract unique dates for prefetching and improved locality
        let dates: Vec<_> = subjects
            .iter()
            .map(|(_, date)| *date)
            .collect::<std::collections::HashSet<_>>()
            .into_iter()
            .collect();

        log::debug!(
            "Processing {} subjects with {} unique dates for categorical values, chunk size {}",
            subjects.len(),
            dates.len(),
            chunk_size
        );

        // Prefetch data if we have a good locality pattern (few dates, many subjects)
        if dates.len() < 5 && subjects.len() > 1000 {
            // Extract unique PNRs to avoid duplicates
            let pnrs: Vec<_> = subjects.iter().map(|(pnr, _)| pnr.clone()).collect();

            // Prefetch data for all combinations in a single batch
            let covariate_types = [covariate_type];
            log::info!(
                "Prefetching {} categorical data points ({}×{}×{})",
                pnrs.len() * covariate_types.len() * dates.len(),
                pnrs.len(),
                covariate_types.len(),
                dates.len()
            );
            checker.prefetch_data(&pnrs, &covariate_types, &dates);
        }

        // Create styled progress bar
        let style = create_progress_style(covariate_type);
        let progress = subjects
            .par_chunks(chunk_size)
            .progress_with_style(style)
            .with_prefix("Categorical Values")
            .with_message(format!(
                "Processing {} categorical covariates...",
                subjects.len()
            ));

        // Set global thread pool configuration (if not already set)
        rayon::ThreadPoolBuilder::new()
            .num_threads(self.config.thread_count)
            .build_global()
            .ok(); // Ignore error if already initialized

        // Process chunks in parallel with better memory locality
        let results: Vec<_> = progress
            .map(|chunk| self.process_categorical_chunk(chunk, covariate_type, checker, extractor))
            .collect();

        // Calculate total capacity for the combined results
        let total_capacity: usize = results.iter().map(|(v, _)| v.len()).sum();

        // Create memory guard for the combined results
        // String sizes are variable, so estimate 32 bytes per string on average
        const AVG_STRING_SIZE: usize = 32;
        let guard_id = format!(
            "combined_categorical_{}_{}",
            covariate_type as u8, total_capacity
        );
        let _memory_guard = MemoryGuard::new(&guard_id, total_capacity * AVG_STRING_SIZE);

        // Allocate the result vector
        let mut all_values = Vec::with_capacity(total_capacity);
        let mut total_missing = 0;

        // Combine all partial results efficiently
        for (values, missing) in results {
            all_values.extend(values);
            total_missing += missing;
        }

        (all_values, total_missing)
    }

    /// Process a single chunk of subjects for categorical values - extracted for better code organization
    #[inline]
    fn process_categorical_chunk<F>(
        &self,
        chunk: &[(String, NaiveDate)],
        covariate_type: CovariateType,
        checker: &BalanceChecker,
        extractor: &F,
    ) -> (Vec<String>, usize)
    where
        F: Fn(&Covariate) -> Option<String> + Send + Sync,
    {
        // Reserve capacity to avoid reallocations
        let mut values = Vec::with_capacity(chunk.len());
        let mut missing = 0;

        // Track cache hits and misses for optimization
        let mut cache_hits = 0;
        let mut cache_misses = 0;

        // Process based on the selected optimization strategy
        match self.config.optimization_strategy {
            OptimizationStrategy::Safe => {
                // Safe mode: always process linearly without date grouping
                for (pnr, date) in chunk {
                    let start = std::time::Instant::now();
                    self.process_single_categorical_item(
                        pnr,
                        *date,
                        covariate_type,
                        checker,
                        extractor,
                        &mut values,
                        &mut missing,
                        &mut cache_hits,
                        &mut cache_misses,
                        start,
                    );
                }
            }
            OptimizationStrategy::Balanced => {
                // In balanced mode, only use date grouping for small chunks
                if chunk.len() < 500 {
                    // For small chunks, try the date grouping optimization
                    self.process_with_date_grouping_categorical(DateGroupingParams {
                        chunk,
                        covariate_type,
                        checker,
                        extractor,
                        values: &mut values,
                        missing: &mut missing,
                        cache_hits: &mut cache_hits,
                        cache_misses: &mut cache_misses,
                    });
                } else {
                    // For larger chunks, process linearly to avoid memory issues
                    for (pnr, date) in chunk {
                        let start = std::time::Instant::now();
                        self.process_single_categorical_item(
                            pnr,
                            *date,
                            covariate_type,
                            checker,
                            extractor,
                            &mut values,
                            &mut missing,
                            &mut cache_hits,
                            &mut cache_misses,
                            start,
                        );
                    }
                }
            }
            OptimizationStrategy::Performance => {
                // Performance mode: use date grouping optimization for all chunk sizes
                self.process_with_date_grouping_categorical(DateGroupingParams {
                    chunk,
                    covariate_type,
                    checker,
                    extractor,
                    values: &mut values,
                    missing: &mut missing,
                    cache_hits: &mut cache_hits,
                    cache_misses: &mut cache_misses,
                });
            }
        }

        // Log cache performance statistics for larger chunks
        if chunk.len() > 1000 && (cache_hits + cache_misses > 0) {
            let hit_rate = (cache_hits as f64 / (cache_hits + cache_misses) as f64) * 100.0;
            log::debug!(
                "Cache performance for {} categorical items: {:.1}% hit rate ({} hits, {} misses)",
                chunk.len(),
                hit_rate,
                cache_hits,
                cache_misses
            );
        }

        (values, missing)
    }

    /// Process a single subject for categorical values
    #[inline]
    fn process_single_categorical_item<F>(
        &self,
        pnr: &str,
        date: NaiveDate,
        covariate_type: CovariateType,
        checker: &BalanceChecker,
        extractor: &F,
        values: &mut Vec<String>,
        missing: &mut usize,
        cache_hits: &mut usize,
        cache_misses: &mut usize,
        start: Instant,
    ) where
        F: Fn(&Covariate) -> Option<String> + Send + Sync,
    {
        // Get covariate from store, update cache metrics
        let covariate_result = checker.covariate(pnr, covariate_type, date);

        if covariate_result.is_ok() {
            let lookup_time = start.elapsed();
            if lookup_time.as_micros() < 50 {
                *cache_hits += 1;
            } else {
                *cache_misses += 1;
            }
        }

        // Handle the result
        match covariate_result {
            Ok(Some(covariate)) => {
                if let Some(value) = extractor(&covariate) {
                    values.push(value);
                } else {
                    *missing += 1;
                }
            }
            _ => *missing += 1,
        }
    }

    /// Process a chunk of subjects with date grouping optimization for categorical values
    #[inline]
    fn process_with_date_grouping_categorical<F>(&self, params: DateGroupingParams<'_, F, String>)
    where
        F: Fn(&Covariate) -> Option<String> + Send + Sync,
    {
        // Create a memory reservation for the temporary date grouping
        let guard_id = format!(
            "date_group_categorical_{}_{}",
            params.covariate_type as u8,
            params.chunk.len()
        );
        let estimated_size = params.chunk.len()
            * (std::mem::size_of::<String>() + std::mem::size_of::<NaiveDate>() * 2);
        let _memory_guard = MemoryGuard::new(&guard_id, estimated_size);

        // Use date grouping for better cache locality
        let mut date_groups = HashMap::with_capacity(params.chunk.len() / 10);

        // Group by date first
        for (pnr, date) in params.chunk {
            date_groups
                .entry(*date)
                .or_insert_with(Vec::new)
                .push(pnr.as_str());
        }

        // Process each date group
        for (date, pnrs) in date_groups {
            for pnr in pnrs {
                let start = std::time::Instant::now();
                self.process_single_categorical_item(
                    pnr,
                    date,
                    params.covariate_type,
                    params.checker,
                    params.extractor,
                    params.values,
                    params.missing,
                    params.cache_hits,
                    params.cache_misses,
                    start,
                );
            }
        }
    }
}
</file>

<file path="src/balance/proc_impl/config.rs">
use super::super::memory::memory_manager;
use super::OptimizationStrategy;
use log;

/// Processor configuration to control performance characteristics
#[derive(Clone)]
pub struct ProcessorConfig {
    pub thread_count: usize,
    pub chunk_size_multiplier: usize,
    pub optimization_strategy: OptimizationStrategy,
}

impl Default for ProcessorConfig {
    fn default() -> Self {
        // Use the memory manager to determine optimal settings
        let mem_manager = memory_manager();

        Self {
            thread_count: mem_manager.get_max_parallel_tasks(),
            chunk_size_multiplier: 1,
            optimization_strategy: OptimizationStrategy::from_memory_tier(mem_manager.get_tier()),
        }
    }
}

impl ProcessorConfig {
    /// Create a new `ProcessorConfig` with default values
    pub fn new() -> Self {
        Self::default()
    }

    /// Create a new `ProcessorConfig` with custom configuration
    #[allow(dead_code)]
    pub fn with_config(
        thread_count: Option<usize>,
        chunk_size_multiplier: Option<usize>,
        optimization_strategy: Option<OptimizationStrategy>,
    ) -> Self {
        let mem_manager = memory_manager();

        Self {
            thread_count: thread_count.unwrap_or_else(|| mem_manager.get_max_parallel_tasks()),
            chunk_size_multiplier: chunk_size_multiplier.unwrap_or(1),
            optimization_strategy: optimization_strategy
                .unwrap_or_else(|| OptimizationStrategy::from_memory_tier(mem_manager.get_tier())),
        }
    }

    /// Configure optimization strategy
    #[allow(dead_code)]
    pub fn with_optimization_strategy(mut self, strategy: OptimizationStrategy) -> Self {
        self.optimization_strategy = strategy;
        self
    }

    /// Automatically select optimization strategy based on system resources
    #[allow(dead_code)]
    pub fn auto_configure(mut self) -> Self {
        // Get memory manager for system resources
        let mem_manager = memory_manager();

        // Select strategy based on available memory
        self.optimization_strategy = OptimizationStrategy::from_memory_tier(mem_manager.get_tier());

        log::info!(
            "Auto-configured optimization strategy: {:?} (detected memory tier: {:?})",
            self.optimization_strategy,
            mem_manager.get_tier()
        );

        self
    }

    /// Get the optimal chunk size based on workload and system capabilities
    pub fn get_optimal_chunk_size(&self, total_items: usize) -> usize {
        // Use memory manager for base chunk size determination
        let mem_manager = memory_manager();
        let base_chunk_size = mem_manager.get_optimal_chunk_size(total_items);

        // Apply the multiplier to allow tuning
        let chunk_size = base_chunk_size * self.chunk_size_multiplier;

        // Round to nearest hundred for cleaner numbers
        (chunk_size / 100) * 100
    }
}
</file>

<file path="src/balance/proc_impl/date_grouping.rs">
use super::super::BalanceChecker;
use chrono::NaiveDate;
use types::models::CovariateType;

/// Parameters for processing a chunk of data with date grouping
pub struct DateGroupingParams<'a, F, V> {
    pub chunk: &'a [(String, NaiveDate)],
    pub covariate_type: CovariateType,
    pub checker: &'a BalanceChecker,
    pub extractor: &'a F,
    pub values: &'a mut Vec<V>,
    pub missing: &'a mut usize,
    pub cache_hits: &'a mut usize,
    pub cache_misses: &'a mut usize,
}
</file>

<file path="src/balance/proc_impl/mod.rs">
// Export submodules
pub mod categorical;
pub mod config;
pub mod date_grouping;
pub mod numeric;
pub mod progress;

// Export the main processor value and parameters
pub use super::optimization::OptimizationStrategy;
</file>

<file path="src/balance/proc_impl/numeric.rs">
use super::super::memory::MemoryGuard;
use super::super::BalanceChecker;
use super::config::ProcessorConfig;
use super::date_grouping::DateGroupingParams;
use super::progress::create_progress_style;
use super::OptimizationStrategy;
use chrono::NaiveDate;
use hashbrown::HashMap;
use indicatif::ParallelProgressIterator;
use rayon::prelude::*;
use std::time::Instant;
use types::models::{Covariate, CovariateType};

/// Processor for numeric covariate values
pub struct NumericProcessor {
    config: ProcessorConfig,
}

impl NumericProcessor {
    /// Create a new numeric processor with the given configuration
    pub fn new(config: ProcessorConfig) -> Self {
        Self { config }
    }

    /// Collect numeric values for a list of subjects
    pub fn collect_numeric_values<F>(
        &self,
        subjects: &[(String, NaiveDate)],
        covariate_type: CovariateType,
        checker: &BalanceChecker,
        extractor: &F,
    ) -> (Vec<f64>, usize)
    where
        F: Fn(&Covariate) -> Option<f64> + Send + Sync,
    {
        // Get the optimal chunk size for this workload
        let chunk_size = self.config.get_optimal_chunk_size(subjects.len());

        // Extract unique dates for prefetching and improved locality
        let dates: Vec<_> = subjects
            .iter()
            .map(|(_, date)| *date)
            .collect::<std::collections::HashSet<_>>()
            .into_iter()
            .collect();

        log::debug!(
            "Processing {} subjects with {} unique dates for numeric values, chunk size {}",
            subjects.len(),
            dates.len(),
            chunk_size
        );

        // Prefetch data if we have a good locality pattern (few dates, many subjects)
        if dates.len() < 5 && subjects.len() > 1000 {
            // Extract unique PNRs to avoid duplicates
            let pnrs: Vec<_> = subjects.iter().map(|(pnr, _)| pnr.clone()).collect();

            // Prefetch data for all combinations in a single batch
            let covariate_types = [covariate_type];
            log::info!(
                "Prefetching {} numeric data points ({}×{}×{})",
                pnrs.len() * covariate_types.len() * dates.len(),
                pnrs.len(),
                covariate_types.len(),
                dates.len()
            );
            checker.prefetch_data(&pnrs, &covariate_types, &dates);
        }

        // Create styled progress bar
        let style = create_progress_style(covariate_type);
        let progress = subjects
            .par_chunks(chunk_size)
            .progress_with_style(style)
            .with_prefix("Numeric Values")
            .with_message(format!(
                "Processing {} numeric covariates...",
                subjects.len()
            ));

        // Set global thread pool configuration (if not already set)
        rayon::ThreadPoolBuilder::new()
            .num_threads(self.config.thread_count)
            .build_global()
            .ok(); // Ignore error if already initialized

        // Process chunks in parallel with better memory locality
        let results: Vec<_> = progress
            .map(|chunk| self.process_numeric_chunk(chunk, covariate_type, checker, extractor))
            .collect();

        // Calculate total capacity for the combined results
        let total_capacity: usize = results.iter().map(|(v, _)| v.len()).sum();

        // Create memory guard for the combined results
        let guard_id = format!(
            "combined_numeric_{}_{}",
            covariate_type as u8, total_capacity
        );
        let _memory_guard =
            MemoryGuard::new(&guard_id, total_capacity * std::mem::size_of::<f64>());

        // Allocate the result vector
        let mut all_values = Vec::with_capacity(total_capacity);
        let mut total_missing = 0;

        // Combine all partial results efficiently
        for (values, missing) in results {
            all_values.extend(values);
            total_missing += missing;
        }

        (all_values, total_missing)
    }

    /// Process a single chunk of subjects for numeric values - extracted for better code organization
    #[inline]
    fn process_numeric_chunk<F>(
        &self,
        chunk: &[(String, NaiveDate)],
        covariate_type: CovariateType,
        checker: &BalanceChecker,
        extractor: &F,
    ) -> (Vec<f64>, usize)
    where
        F: Fn(&Covariate) -> Option<f64> + Send + Sync,
    {
        // Reserve capacity to avoid reallocations
        let mut values = Vec::with_capacity(chunk.len());
        let mut missing = 0;

        // Track cache hits and misses for optimization
        let mut cache_hits = 0;
        let mut cache_misses = 0;

        // Process based on the selected optimization strategy
        match self.config.optimization_strategy {
            OptimizationStrategy::Safe => {
                // Safe mode: always process linearly without date grouping
                for (pnr, date) in chunk {
                    let start = std::time::Instant::now();
                    self.process_single_numeric_item(
                        pnr,
                        *date,
                        covariate_type,
                        checker,
                        extractor,
                        &mut values,
                        &mut missing,
                        &mut cache_hits,
                        &mut cache_misses,
                        start,
                    );
                }
            }
            OptimizationStrategy::Balanced => {
                // In balanced mode, only use date grouping for very small chunks
                if chunk.len() < 500 {
                    // For small chunks, try the date grouping optimization
                    self.process_with_date_grouping_numeric(DateGroupingParams {
                        chunk,
                        covariate_type,
                        checker,
                        extractor,
                        values: &mut values,
                        missing: &mut missing,
                        cache_hits: &mut cache_hits,
                        cache_misses: &mut cache_misses,
                    });
                } else {
                    // For larger chunks, process linearly to avoid memory issues
                    for (pnr, date) in chunk {
                        let start = std::time::Instant::now();
                        self.process_single_numeric_item(
                            pnr,
                            *date,
                            covariate_type,
                            checker,
                            extractor,
                            &mut values,
                            &mut missing,
                            &mut cache_hits,
                            &mut cache_misses,
                            start,
                        );
                    }
                }
            }
            OptimizationStrategy::Performance => {
                // Performance mode: use date grouping optimization for all chunk sizes
                self.process_with_date_grouping_numeric(DateGroupingParams {
                    chunk,
                    covariate_type,
                    checker,
                    extractor,
                    values: &mut values,
                    missing: &mut missing,
                    cache_hits: &mut cache_hits,
                    cache_misses: &mut cache_misses,
                });
            }
        }

        // Report cache performance data for optimization
        if chunk.len() > 1000 {
            let hit_rate = if cache_hits + cache_misses > 0 {
                (cache_hits as f64 / (cache_hits + cache_misses) as f64) * 100.0
            } else {
                0.0
            };
            log::debug!(
                "Cache performance for {} numeric items: {:.1}% hit rate ({} hits, {} misses)",
                chunk.len(),
                hit_rate,
                cache_hits,
                cache_misses
            );
        }

        (values, missing)
    }

    /// Process a single subject for numeric values
    #[inline]
    fn process_single_numeric_item<F>(
        &self,
        pnr: &str,
        date: NaiveDate,
        covariate_type: CovariateType,
        checker: &BalanceChecker,
        extractor: &F,
        values: &mut Vec<f64>,
        missing: &mut usize,
        cache_hits: &mut usize,
        cache_misses: &mut usize,
        start: Instant,
    ) where
        F: Fn(&Covariate) -> Option<f64> + Send + Sync,
    {
        // Get covariate from store, update cache metrics
        let covariate_result = checker.covariate(pnr, covariate_type, date);

        if covariate_result.is_ok() {
            let lookup_time = start.elapsed();
            if lookup_time.as_micros() < 50 {
                *cache_hits += 1;
            } else {
                *cache_misses += 1;
            }
        }

        // Handle the result
        match covariate_result {
            Ok(Some(covariate)) => {
                if let Some(value) = extractor(&covariate) {
                    values.push(value);
                } else {
                    *missing += 1;
                }
            }
            _ => *missing += 1,
        }
    }

    /// Process a chunk of subjects with date grouping optimization for numeric values
    #[inline]
    fn process_with_date_grouping_numeric<F>(&self, params: DateGroupingParams<'_, F, f64>)
    where
        F: Fn(&Covariate) -> Option<f64> + Send + Sync,
    {
        // Create a memory reservation for the temporary date grouping
        let guard_id = format!(
            "date_group_numeric_{}_{}",
            params.covariate_type as u8,
            params.chunk.len()
        );
        let estimated_size = params.chunk.len()
            * (std::mem::size_of::<String>() + std::mem::size_of::<NaiveDate>() * 2);
        let _memory_guard = MemoryGuard::new(&guard_id, estimated_size);

        // Use date grouping for better cache locality
        let mut date_groups = HashMap::with_capacity(params.chunk.len() / 10);

        // Group by date first
        for (pnr, date) in params.chunk {
            date_groups
                .entry(*date)
                .or_insert_with(Vec::new)
                .push(pnr.as_str());
        }

        // Process each date group
        for (date, pnrs) in date_groups {
            for pnr in pnrs {
                let start = std::time::Instant::now();
                self.process_single_numeric_item(
                    pnr,
                    date,
                    params.covariate_type,
                    params.checker,
                    params.extractor,
                    params.values,
                    params.missing,
                    params.cache_hits,
                    params.cache_misses,
                    start,
                );
            }
        }
    }
}
</file>

<file path="src/balance/proc_impl/progress.rs">
use indicatif::ProgressStyle;
use types::models::CovariateType;

/// Create a progress style with a custom template and dynamic covariate type display
pub fn create_progress_style(covariate_type: CovariateType) -> ProgressStyle {
    ProgressStyle::default_bar()
        .template(
            "{prefix:.bold.dim} [{elapsed_precise}] {bar:40.cyan/blue} {pos:>7}/{len:7} \
             ({percent}%) {msg}\n\
             ⏱️  ETA: {eta_precise:.dim} | 🚀 {per_sec:.green} records/sec | \
             📊 Processing: {covariate_type}",
        )
        .unwrap()
        .with_key(
            "covariate_type",
            move |_state: &indicatif::ProgressState, w: &mut dyn std::fmt::Write| {
                write!(w, "{covariate_type:?}").unwrap();
            },
        )
}
</file>

<file path="src/balance/proc_impl/README.md">
# Processor Implementation Module

This module contains the implementation details for the covariate value processor, which was modularized from a monolithic ~700 line file into smaller, more focused components.

## Module Structure

The processor implementation is organized into the following components:

- **config.rs**: Configuration for the processor, including optimization strategies and thread management
- **date_grouping.rs**: Date-based data grouping for optimization of database access patterns
- **progress.rs**: Progress reporting and visualization utilities
- **numeric.rs**: Processing of numeric covariate values
- **categorical.rs**: Processing of categorical covariate values
- **mod.rs**: Module exports and re-exports

## Design Philosophy

The modularization followed these principles:

1. **Separation of Concerns**: Each module has a single, well-defined responsibility
2. **Interface Stability**: The public API remained stable while internal implementations were refactored
3. **Code Reuse**: Common patterns were extracted into reusable components
4. **Performance Optimization**: Memory and computational efficiency were maintained or improved

## Component Descriptions

### Config (`config.rs`)

The configuration module defines the `ProcessorConfig` struct which controls:

- Thread count for parallel processing
- Chunk size multiplier for workload distribution
- Optimization strategy selection
- Dynamic configuration based on available system resources

```rust
// Example of creating a configuration
let config = ProcessorConfig::new()
    .with_optimization_strategy(OptimizationStrategy::Performance);
```

### Date Grouping (`date_grouping.rs`)

This module provides a parameter struct that encapsulates the parameters for date-based processing, reducing function argument counts and improving readability.

```rust
// Parameters for processing with date grouping
struct DateGroupingParams<'a, F, V> {
    chunk: &'a [(String, NaiveDate)],
    covariate_type: CovariateType,
    checker: &'a BalanceChecker,
    extractor: &'a F,
    values: &'a mut Vec<V>,
    missing: &'a mut usize,
    cache_hits: &'a mut usize,
    cache_misses: &'a mut usize,
}
```

### Progress Reporting (`progress.rs`)

Provides utilities for creating and customizing progress bars for long-running operations, helping users track the progress of data processing.

```rust
// Creating a progress bar for covariate processing
let style = create_progress_style(covariate_type);
let progress = subjects
    .par_chunks(chunk_size)
    .progress_with_style(style)
    .with_prefix("Processing...")
    .with_message("Working on data...");
```

### Numeric Processing (`numeric.rs`)

The `NumericProcessor` handles collection and processing of numeric covariate values, implementing:

- Parallel data collection
- Batched processing for efficiency
- Memory-optimized data handling
- Cache-friendly access patterns

### Categorical Processing (`categorical.rs`)

The `CategoricalProcessor` handles collection and processing of categorical (string) covariate values, similar to the numeric processor but with type-specific optimizations.

## Integration with Main Processor

The main `ValueProcessor` in `processor.rs` serves as a facade for these implementation details, delegating to the appropriate specialized processor based on the value type being processed.

## Performance Considerations

The modularized implementation maintains or improves upon the performance of the original monolithic version through:

1. Better cache locality with date-based grouping
2. Memory tier-based optimization strategy selection
3. Parallel processing with rayon
4. Progress reporting with minimal overhead
5. Structured parameter passing for better compiler optimization
</file>

<file path="src/balance/memory.rs">
//! Adaptive memory management system for efficient resource utilization.
//!
//! This module provides a dynamic memory management system that adapts cache sizes,
//! batch sizes, and parallelism based on system resources. It automatically detects
//! available memory and adjusts settings to maximize performance without exhausting
//! system resources.

use log::{debug, info};
use std::collections::HashMap;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::{Arc, Mutex, OnceLock};
use std::time::Instant;

/// Memory usage tier for adaptive memory management
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MemoryTier {
    /// Low memory tier (< 8GB available)
    Low,
    /// Medium memory tier (8-16GB available)
    Medium,
    /// High memory tier (16-32GB available)
    High,
    /// Very high memory tier (> 32GB available)
    VeryHigh,
}

impl MemoryTier {
    /// Get the cache size scaling factor for this tier
    #[inline]
    fn cache_size_factor(&self) -> f64 {
        match self {
            Self::Low => 0.5,      // Smaller caches for low memory
            Self::Medium => 1.0,   // Base size for medium memory
            Self::High => 2.0,     // Larger caches for high memory
            Self::VeryHigh => 4.0, // Much larger caches for very high memory
        }
    }

    /// Get the batch size scaling factor for this tier
    #[inline]
    fn batch_size_factor(&self) -> f64 {
        match self {
            Self::Low => 0.5,      // Smaller batches for low memory
            Self::Medium => 1.0,   // Base size for medium memory
            Self::High => 2.0,     // Larger batches for high memory
            Self::VeryHigh => 3.0, // Much larger batches for very high memory
        }
    }

    /// Get the parallelism scaling factor for this tier
    #[inline]
    fn parallelism_factor(&self) -> f64 {
        match self {
            Self::Low => 0.5,      // Less parallelism for low memory
            Self::Medium => 0.75,  // Moderate parallelism for medium memory
            Self::High => 1.0,     // Full CPU parallelism for high memory
            Self::VeryHigh => 1.5, // Potentially higher parallelism for I/O bound tasks
        }
    }
}

/// Dynamic memory manager for adaptive resource allocation
pub struct MemoryManager {
    /// Current memory usage tier, determined dynamically
    tier: MemoryTier,
    /// Base cache size, scaled by tier
    base_cache_size: usize,
    /// Currently tracked allocations
    allocations: Mutex<HashMap<String, usize>>,
    /// Total currently allocated memory
    allocated_memory: AtomicUsize,
    /// Maximum memory to allocate
    max_memory: usize,
    /// CPU count for parallelism calculations
    cpu_count: usize,
}

impl Default for MemoryManager {
    fn default() -> Self {
        Self::new()
    }
}

impl MemoryManager {
    /// Create a new memory manager with dynamic resource detection
    pub fn new() -> Self {
        // Detect system memory
        let system_memory = Self::detect_system_memory();

        // Determine tier based on available memory
        let tier = if system_memory < 8 * 1024 * 1024 * 1024 {
            MemoryTier::Low
        } else if system_memory < 16 * 1024 * 1024 * 1024 {
            MemoryTier::Medium
        } else if system_memory < 32 * 1024 * 1024 * 1024 {
            MemoryTier::High
        } else {
            MemoryTier::VeryHigh
        };

        // Determine maximum memory to use (25% of system memory)
        let max_memory = (system_memory / 4).max(1024 * 1024 * 1024); // At least 1GB

        // Base cache size - will be scaled by tier
        let base_cache_size = 500_000;

        // Get CPU count
        let cpu_count = num_cpus::get();

        info!(
            "Memory manager initialized: {:?} tier, {:.2}GB max memory, {} CPUs",
            tier,
            max_memory as f64 / (1024.0 * 1024.0 * 1024.0),
            cpu_count
        );

        Self {
            tier,
            base_cache_size,
            allocations: Mutex::new(HashMap::new()),
            allocated_memory: AtomicUsize::new(0),
            max_memory,
            cpu_count,
        }
    }

    /// Detect available system memory
    fn detect_system_memory() -> usize {
        #[cfg(target_os = "linux")]
        {
            if let Ok(mem_info) = std::fs::read_to_string("/proc/meminfo") {
                if let Some(mem_line) = mem_info.lines().find(|line| line.starts_with("MemTotal:"))
                {
                    if let Some(mem_kb_str) = mem_line.split_whitespace().nth(1) {
                        if let Ok(mem_kb) = mem_kb_str.parse::<usize>() {
                            return mem_kb * 1024; // Convert KB to bytes
                        }
                    }
                }
            }
        }

        #[cfg(target_os = "macos")]
        {
            use std::process::Command;
            if let Ok(output) = Command::new("sysctl").arg("-n").arg("hw.memsize").output() {
                if let Ok(mem_str) = String::from_utf8(output.stdout) {
                    if let Ok(mem_bytes) = mem_str.trim().parse::<usize>() {
                        return mem_bytes;
                    }
                }
            }
        }

        #[cfg(target_os = "windows")]
        {
            use std::mem::{size_of, zeroed};
            use winapi::um::sysinfoapi::{GlobalMemoryStatusEx, MEMORYSTATUSEX};

            unsafe {
                let mut mem_status: MEMORYSTATUSEX = zeroed();
                mem_status.dwLength = size_of::<MEMORYSTATUSEX>() as u32;

                if GlobalMemoryStatusEx(&mut mem_status) != 0 {
                    return mem_status.ullTotalPhys as usize;
                }
            }
        }

        // Default if we can't detect: assume 16GB
        16 * 1024 * 1024 * 1024
    }

    /// Get the current memory tier
    pub fn get_tier(&self) -> MemoryTier {
        self.tier
    }

    /// Get recommended cache size based on memory tier and current allocations
    pub fn get_recommended_cache_size(&self) -> usize {
        let base_size = self.base_cache_size;
        let tier_factor = self.tier.cache_size_factor();

        // Calculate scaled size
        let scaled_size = (base_size as f64 * tier_factor) as usize;

        // Adjust based on current memory pressure
        let current_allocated = self.allocated_memory.load(Ordering::Relaxed);
        let memory_used_ratio = current_allocated as f64 / self.max_memory as f64;

        // If we're using more than 80% of our allocation, reduce the cache size
        if memory_used_ratio > 0.8 {
            ((scaled_size as f64 * (1.0 - (memory_used_ratio - 0.8) * 5.0)) as usize)
                .max(base_size / 4) // Don't go below 1/4 of base size
        } else {
            scaled_size
        }
    }

    /// Get the maximum parallel tasks to use based on CPU count and memory tier
    pub fn get_max_parallel_tasks(&self) -> usize {
        let parallelism_factor = self.tier.parallelism_factor();
        ((self.cpu_count as f64 * parallelism_factor).round() as usize).max(1) // At least 1 thread
    }

    /// Get optimal batch size for prefetching based on memory tier
    pub fn get_prefetch_batch_size(&self) -> usize {
        let base_size = 10_000;
        let tier_factor = self.tier.batch_size_factor();
        (f64::from(base_size) * tier_factor) as usize
    }

    /// Get the optimal chunk size for processing based on total items and memory tier
    pub fn get_optimal_chunk_size(&self, total_items: usize) -> usize {
        // Base calculation: 1/10 of total items
        let base_chunk = (total_items / 10).clamp(1000, 10_000);

        // Scale by memory tier
        let tier_factor = self.tier.batch_size_factor();
        (base_chunk as f64 * tier_factor) as usize
    }

    /// Track a memory allocation, returning a guard that will automatically untrack on drop
    pub fn track_allocation(&self, id: &str, size: usize) -> MemoryGuard {
        let allocation_id = id.to_string();

        // Update allocation tracking
        {
            let mut allocations = self.allocations.lock().unwrap();
            allocations.insert(allocation_id.clone(), size);
        }

        // Update total allocated memory
        self.allocated_memory.fetch_add(size, Ordering::SeqCst);

        debug!("Tracked allocation: {id} ({size} bytes)");

        // Return a guard that will automatically untrack on drop
        MemoryGuard {
            manager: Arc::new(std::ptr::from_ref::<MemoryManager>(self) as usize),
            id: allocation_id,
            size,
            start_time: Instant::now(),
        }
    }

    /// Internal method used by `MemoryGuard` to untrack an allocation on drop
    fn untrack_allocation(&self, id: &str, size: usize) {
        // Update allocation tracking
        {
            let mut allocations = self.allocations.lock().unwrap();
            allocations.remove(id);
        }

        // Update total allocated memory
        self.allocated_memory.fetch_sub(size, Ordering::SeqCst);

        debug!("Untracked allocation: {id} ({size} bytes)");
    }
}

// Use a thread-safe singleton pattern for the memory manager
static MEMORY_MANAGER: OnceLock<MemoryManager> = OnceLock::new();

/// Get the global memory manager instance
pub fn memory_manager() -> &'static MemoryManager {
    MEMORY_MANAGER.get_or_init(MemoryManager::new)
}

/// RAII guard for tracking memory allocations
///
/// When this guard is dropped, the allocation is automatically untracked
/// and resources are released.
pub struct MemoryGuard {
    /// Raw pointer to the memory manager as a usize for thread safety
    manager: Arc<usize>,
    /// ID of this allocation for tracking
    id: String,
    /// Size of this allocation in bytes
    size: usize,
    /// Time when this allocation was created
    start_time: Instant,
}

impl MemoryGuard {
    /// Create a new memory guard
    #[must_use] pub fn new(id: &str, size: usize) -> Self {
        memory_manager().track_allocation(id, size)
    }

    /// Get the size of this allocation
    #[must_use] pub fn size(&self) -> usize {
        self.size
    }

    /// Get the elapsed time since this allocation was created
    #[must_use] pub fn elapsed(&self) -> std::time::Duration {
        self.start_time.elapsed()
    }
}

impl Drop for MemoryGuard {
    fn drop(&mut self) {
        // This is using Arc<usize> where the usize value is actually the address of
        // the MemoryManager. This is a workaround for sending the MemoryManager pointer
        // across threads.
        let raw_ptr = Arc::as_ptr(&self.manager);
        let ptr_val = unsafe { *raw_ptr };
        let manager_ptr = ptr_val as *const MemoryManager;

        unsafe {
            (*manager_ptr).untrack_allocation(&self.id, self.size);
        }
    }
}
</file>

<file path="src/balance/metrics.rs">
use super::stats::StatisticalCalculations;
use super::BalanceChecker;
use crate::models::CovariateSummary;
use chrono::NaiveDate;
use log::{debug, info, warn};
use types::error::Result as IdsResult;
use types::models::{Covariate, CovariateType};

/// Main balance metrics calculator
pub struct BalanceMetrics {
    processor: super::processor::ValueProcessor,
}

impl BalanceMetrics {
    /// Create a new balance metrics calculator
    #[must_use] pub fn new() -> Self {
        Self {
            processor: super::processor::ValueProcessor::new(),
        }
    }

    /// Calculate balance metrics for a numeric variable
    pub fn calculate_numeric_balance(
        &self,
        checker: &BalanceChecker,
        cases: &[(String, NaiveDate)],
        controls: &[(String, NaiveDate)],
        covariate_type: CovariateType,
        variable_name: &str,
        extractor: impl Fn(&Covariate) -> Option<f64> + Send + Sync,
    ) -> IdsResult<(CovariateSummary, (f64, f64))> {
        // Log diagnostics for first call
        if variable_name == "Family Size" {
            self.log_diagnostics(cases, controls, checker, true);
        }

        debug!(
            "Calculating balance for numeric variable {variable_name} (type: {covariate_type:?})"
        );

        // Extract values
        let (case_values, case_missing) =
            self.processor
                .collect_numeric_values(cases, covariate_type, checker, &extractor);

        let (control_values, control_missing) =
            self.processor
                .collect_numeric_values(controls, covariate_type, checker, &extractor);

        // Calculate missing rates
        let case_missing_rate = self.calculate_missing_rate(case_missing, cases.len());
        let control_missing_rate = self.calculate_missing_rate(control_missing, controls.len());

        // Calculate statistics
        let case_stats = StatisticalCalculations::calculate_summary(&case_values);
        let control_stats = StatisticalCalculations::calculate_summary(&control_values);

        // Calculate standardized mean difference
        let std_diff = StatisticalCalculations::calculate_standardized_difference_from_summaries(
            &case_stats,
            &control_stats,
        );

        // Calculate variance ratio
        let variance_ratio = StatisticalCalculations::calculate_variance_ratio_from_summaries(
            &case_stats,
            &control_stats,
        );

        // Create summary
        let summary = CovariateSummary::new(
            variable_name.to_string(),
            case_stats.mean,
            control_stats.mean,
            std_diff,
            variance_ratio,
        );

        Ok((summary, (case_missing_rate, control_missing_rate)))
    }

    /// Calculate balance metrics for a categorical variable
    pub fn calculate_categorical_balance(
        &self,
        checker: &BalanceChecker,
        cases: &[(String, NaiveDate)],
        controls: &[(String, NaiveDate)],
        covariate_type: CovariateType,
        variable_name: &str,
        extractor: impl Fn(&Covariate) -> Option<String> + Send + Sync,
    ) -> IdsResult<(Vec<CovariateSummary>, (f64, f64))> {
        debug!(
            "Calculating balance for categorical variable {variable_name} (type: {covariate_type:?})"
        );

        // Extract values
        let (case_values, case_missing) =
            self.processor
                .collect_categorical_values(cases, covariate_type, checker, &extractor);

        let (control_values, control_missing) = self.processor.collect_categorical_values(
            controls,
            covariate_type,
            checker,
            &extractor,
        );

        // Calculate missing rates
        let case_missing_rate = self.calculate_missing_rate(case_missing, cases.len());
        let control_missing_rate = self.calculate_missing_rate(control_missing, controls.len());

        // Calculate category counts and proportions
        let case_counts = self.count_categories(&case_values);
        let control_counts = self.count_categories(&control_values);

        // Combine categories from both groups
        let all_categories: Vec<_> = case_counts
            .keys()
            .chain(control_counts.keys())
            .collect::<std::collections::HashSet<_>>()
            .into_iter()
            .cloned()
            .collect();

        // Calculate proportions and standardized differences for each category
        let mut results = Vec::new();
        for category in all_categories {
            let case_count = case_counts.get(&category).copied().unwrap_or(0);
            let case_prop = if case_values.is_empty() {
                0.0
            } else {
                case_count as f64 / case_values.len() as f64
            };

            let control_count = control_counts.get(&category).copied().unwrap_or(0);
            let control_prop = if control_values.is_empty() {
                0.0
            } else {
                control_count as f64 / control_values.len() as f64
            };

            // Calculate standardized difference for categorical variables
            let pooled_var =
                (case_prop * (1.0 - case_prop) + control_prop * (1.0 - control_prop)) / 2.0;
            let pooled_sd = pooled_var.sqrt();

            let std_diff = if pooled_sd == 0.0 {
                0.0
            } else {
                (case_prop - control_prop) / pooled_sd
            };

            // For categorical variables, variance ratio is set to 1.0
            let variance_ratio = 1.0;

            // Create summary for this category
            let category_name = if variable_name.is_empty() {
                category.clone()
            } else {
                format!("{variable_name}: {category}")
            };

            let summary = CovariateSummary::new(
                category_name,
                case_prop,
                control_prop,
                std_diff,
                variance_ratio,
            );

            results.push(summary);
        }

        Ok((results, (case_missing_rate, control_missing_rate)))
    }

    // Helper methods

    /// Log diagnostic information about the data
    fn log_diagnostics(
        &self,
        cases: &[(String, NaiveDate)],
        controls: &[(String, NaiveDate)],
        _checker: &BalanceChecker,
        verbose: bool,
    ) {
        // Count unique cases and controls for logging
        let unique_cases: std::collections::HashSet<&str> =
            cases.iter().map(|(s, _)| s.as_str()).collect();
        let unique_controls: std::collections::HashSet<&str> =
            controls.iter().map(|(s, _)| s.as_str()).collect();

        // Log case & control counts
        info!(
            "Case-control balance: {} cases, {} controls ({:.1}x), {} unique cases, {} unique controls",
            cases.len(),
            controls.len(),
            controls.len() as f64 / cases.len() as f64,
            unique_cases.len(),
            unique_controls.len(),
        );

        if verbose {
            // Diagnostics for PNR formats
            let dash_count = cases
                .iter()
                .map(|(pnr, _)| pnr)
                .filter(|pnr| pnr.contains('-'))
                .count();

            if dash_count > 0 {
                warn!(
                    "{dash_count} PNRs contain dashes, which might affect matching"
                );
            }
        }
    }

    /// Calculate missing data rate
    fn calculate_missing_rate(&self, missing: usize, total: usize) -> f64 {
        if total == 0 {
            0.0
        } else {
            missing as f64 / total as f64
        }
    }

    /// Count occurrences of each category
    fn count_categories(&self, values: &[String]) -> std::collections::HashMap<String, usize> {
        let mut counts = std::collections::HashMap::new();
        for value in values {
            *counts.entry(value.clone()).or_insert(0) += 1;
        }
        counts
    }
}

impl Default for BalanceMetrics {
    fn default() -> Self {
        Self::new()
    }
}
</file>

<file path="src/balance/mod.rs">
//! Balance analysis module for covariate analysis in matched studies
//!
//! This module provides functionality for analyzing covariate balance between
//! case and control groups, calculating standardized mean differences, and
//! generating detailed reports.

// Core functionality
pub mod checker; // Main balance checker implementation
mod memory; // Memory management for large datasets
pub mod metrics; // Balance metrics calculations
mod optimization; // Optimization strategies for processing
mod proc_impl; // Implementation details for processor
mod processor; // Main value processor
pub mod results; // Results data structures
mod stats; // Statistical calculations

// Public exports
pub use checker::{BalanceChecker, BalanceCheckerBuilder};
pub use memory::{memory_manager, MemoryGuard, MemoryTier};
pub use optimization::OptimizationStrategy;
pub use processor::ValueProcessor;
pub use results::{BalanceResults, MatchedPairSummary};
</file>

<file path="src/balance/optimization.rs">
use super::memory::MemoryTier;

/// Controls how data is processed during balance checking
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OptimizationStrategy {
    /// Safe mode: no date grouping, linear processing only
    /// Best for systems with limited memory or when stability is critical
    #[default]
    Safe,

    /// Balanced mode: uses date grouping only for small datasets
    /// Good default for most systems
    Balanced,

    /// Performance mode: uses date grouping optimization extensively
    /// Best for high-memory systems (32+ GB) when speed is critical
    Performance,
}

impl OptimizationStrategy {
    /// Maps memory tier to optimization strategy
    #[must_use] pub fn from_memory_tier(tier: MemoryTier) -> Self {
        match tier {
            MemoryTier::VeryHigh => OptimizationStrategy::Performance,
            MemoryTier::High => OptimizationStrategy::Performance,
            MemoryTier::Medium => OptimizationStrategy::Balanced,
            MemoryTier::Low => OptimizationStrategy::Safe,
        }
    }
}
</file>

<file path="src/balance/processor.rs">
use super::BalanceChecker;
use chrono::NaiveDate;
use types::models::{Covariate, CovariateType};

// Re-export optimization strategy from separate module
pub use super::optimization::OptimizationStrategy;

// Import components from the proc_impl module
use super::proc_impl::categorical::CategoricalProcessor;
use super::proc_impl::config::ProcessorConfig;
use super::proc_impl::numeric::NumericProcessor;

/// Main processor for covariate values
pub struct ValueProcessor {
    config: ProcessorConfig,
    numeric_processor: NumericProcessor,
    categorical_processor: CategoricalProcessor,
}

impl Default for ValueProcessor {
    fn default() -> Self {
        Self::new()
    }
}

impl ValueProcessor {
    /// Create a new `ValueProcessor` with default settings
    #[must_use] pub fn new() -> Self {
        let config = ProcessorConfig::new();
        Self {
            numeric_processor: NumericProcessor::new(config.clone()),
            categorical_processor: CategoricalProcessor::new(config.clone()),
            config,
        }
    }

    /// Create a new `ValueProcessor` with custom configuration
    #[allow(dead_code)]
    #[must_use] pub fn with_config(
        thread_count: Option<usize>,
        chunk_size_multiplier: Option<usize>,
        optimization_strategy: Option<OptimizationStrategy>,
    ) -> Self {
        let config = ProcessorConfig::with_config(
            thread_count,
            chunk_size_multiplier,
            optimization_strategy,
        );
        Self {
            numeric_processor: NumericProcessor::new(config.clone()),
            categorical_processor: CategoricalProcessor::new(config.clone()),
            config,
        }
    }

    /// Configure optimization strategy
    #[allow(dead_code)]
    #[must_use] pub fn with_optimization_strategy(mut self, strategy: OptimizationStrategy) -> Self {
        self.config = self.config.with_optimization_strategy(strategy);
        self.numeric_processor = NumericProcessor::new(self.config.clone());
        self.categorical_processor = CategoricalProcessor::new(self.config.clone());
        self
    }

    /// Automatically select optimization strategy based on system resources
    #[allow(dead_code)]
    #[must_use] pub fn auto_configure(mut self) -> Self {
        self.config = self.config.auto_configure();
        self.numeric_processor = NumericProcessor::new(self.config.clone());
        self.categorical_processor = CategoricalProcessor::new(self.config.clone());
        self
    }

    /// Collect numeric values for a list of subjects
    /// Delegates to the numeric processor
    pub fn collect_numeric_values<F>(
        &self,
        subjects: &[(String, NaiveDate)],
        covariate_type: CovariateType,
        checker: &BalanceChecker,
        extractor: &F,
    ) -> (Vec<f64>, usize)
    where
        F: Fn(&Covariate) -> Option<f64> + Send + Sync,
    {
        self.numeric_processor
            .collect_numeric_values(subjects, covariate_type, checker, extractor)
    }

    /// Collect categorical values for a list of subjects
    /// Delegates to the categorical processor
    pub fn collect_categorical_values<F>(
        &self,
        subjects: &[(String, NaiveDate)],
        covariate_type: CovariateType,
        checker: &BalanceChecker,
        extractor: &F,
    ) -> (Vec<String>, usize)
    where
        F: Fn(&Covariate) -> Option<String> + Send + Sync,
    {
        self.categorical_processor.collect_categorical_values(
            subjects,
            covariate_type,
            checker,
            extractor,
        )
    }
}
</file>

<file path="src/balance/results.rs">
use crate::models::{CovariateSummary, MatchedPairDetail};
use chrono::NaiveDate;
use hashbrown::HashMap;

#[derive(Clone)]
pub struct BalanceResults {
    pub summaries: Vec<CovariateSummary>,
    pub missing_data_rates: HashMap<String, (f64, f64)>,
    pub matched_pair_details: Vec<MatchedPairDetail>,
}

#[derive(Clone)]
pub struct MatchedPairSummary {
    pub case_pnr: String,
    pub control_pnrs: Vec<String>,
    pub treatment_date: NaiveDate,
    pub summaries: Vec<CovariateSummary>,
    pub missing_rates: HashMap<String, (f64, f64)>,
}

impl Default for BalanceResults {
    fn default() -> Self {
        Self::new()
    }
}

impl BalanceResults {
    #[must_use] pub fn new() -> Self {
        Self {
            summaries: Vec::new(),
            missing_data_rates: HashMap::new(),
            matched_pair_details: Vec::new(),
        }
    }

    pub fn add_summary(&mut self, summary: CovariateSummary) {
        self.summaries.push(summary);
    }

    pub fn add_missing_rate(&mut self, variable: String, case_rate: f64, control_rate: f64) {
        self.missing_data_rates
            .insert(variable, (case_rate, control_rate));
    }

    pub fn add_pair_detail(&mut self, detail: MatchedPairDetail) {
        self.matched_pair_details.push(detail);
    }

    /// Combine another `BalanceResults` into this one
    pub fn combine(&mut self, other: BalanceResults) {
        // Add all summaries
        self.summaries.extend(other.summaries);

        // Merge missing data rates
        for (variable, rates) in other.missing_data_rates {
            self.missing_data_rates.insert(variable, rates);
        }

        // Add all matched pair details
        self.matched_pair_details.extend(other.matched_pair_details);
    }
}
</file>

<file path="src/balance/stats.rs">
use statrs::statistics::Statistics;

pub(crate) struct StatisticalSummary {
    pub mean: f64,
    pub variance: f64,
}

pub(crate) struct StatisticalCalculations;

impl StatisticalCalculations {
    pub fn calculate_summary(values: &[f64]) -> StatisticalSummary {
        StatisticalSummary {
            mean: values.mean(),
            variance: values.variance(),
        }
    }

    pub fn calculate_standardized_difference_from_summaries(
        case_summary: &StatisticalSummary,
        control_summary: &StatisticalSummary,
    ) -> f64 {
        let pooled_sd = ((case_summary.variance + control_summary.variance) / 2.0).sqrt();
        (case_summary.mean - control_summary.mean) / pooled_sd
    }

    pub fn calculate_variance_ratio_from_summaries(
        case_summary: &StatisticalSummary,
        control_summary: &StatisticalSummary,
    ) -> f64 {
        case_summary.variance / control_summary.variance
    }
}
</file>

<file path="src/core/config.rs">
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs::File;
use std::io::BufReader;
use std::path::Path;
use types::models::CovariateType;
use types::traits::VariableType;

/// Configuration for a covariate variable
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CovariateVariableConfig {
    /// Variable name (e.g., "Age", "Family Size")
    pub name: String,

    /// Variable type (Numeric, Categorical, Binary)
    pub variable_type: VariableType,

    /// Field accessor method in the Covariate struct (e.g., "`get_age`", "`get_family_size`")
    pub accessor: String,

    /// Translation map to use for categorical variables (e.g., "`family_type`", "civst")
    pub translation: Option<String>,

    /// Description of the variable
    pub description: Option<String>,

    /// Default value when variable is missing
    pub default_value: Option<String>,

    /// Additional configuration options as key-value pairs
    pub options: HashMap<String, String>,
}

/// Configuration for a covariate type
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CovariateTypeConfig {
    /// Name of the covariate type (e.g., "Demographics", "Income")
    pub name: String,

    /// Covariate type enum
    pub covariate_type: CovariateType,

    /// List of variables in this covariate type
    pub variables: Vec<CovariateVariableConfig>,

    /// Description of the covariate type
    pub description: Option<String>,
}

/// Complete configuration for all covariate processing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CovariatesConfig {
    /// List of covariate types
    pub covariate_types: Vec<CovariateTypeConfig>,

    /// Global settings
    pub settings: HashMap<String, String>,
}

impl CovariatesConfig {
    /// Load a covariates configuration from a file
    pub fn from_file<P: AsRef<Path>>(path: P) -> Result<Self, Box<dyn std::error::Error>> {
        let file = File::open(path)?;
        let reader = BufReader::new(file);
        let config: CovariatesConfig = serde_json::from_reader(reader)?;
        Ok(config)
    }

    /// Get a covariate type configuration by type
    #[must_use] pub fn get_covariate_type(
        &self,
        covariate_type: CovariateType,
    ) -> Option<&CovariateTypeConfig> {
        self.covariate_types
            .iter()
            .find(|ct| ct.covariate_type == covariate_type)
    }

    /// Get a default configuration with all standard covariate types and variables
    #[must_use] pub fn default_config() -> Self {
        // Demographics variables
        let demographics_variables = vec![
            CovariateVariableConfig {
                name: "Family Size".to_string(),
                variable_type: VariableType::Numeric,
                accessor: "family_size".to_string(),
                translation: None,
                description: Some("Size of the family unit".to_string()),
                default_value: None,
                options: HashMap::new(),
            },
            CovariateVariableConfig {
                name: "Municipality".to_string(),
                variable_type: VariableType::Numeric,
                accessor: "municipality".to_string(),
                translation: None,
                description: Some("Municipality code".to_string()),
                default_value: None,
                options: HashMap::new(),
            },
            CovariateVariableConfig {
                name: "Family Type".to_string(),
                variable_type: VariableType::Categorical,
                accessor: "family_type".to_string(),
                translation: Some("family_type".to_string()),
                description: Some("Type of family structure".to_string()),
                default_value: None,
                options: HashMap::new(),
            },
            CovariateVariableConfig {
                name: "Civil Status".to_string(),
                variable_type: VariableType::Categorical,
                accessor: "civil_status".to_string(),
                translation: Some("civst".to_string()),
                description: Some("Civil status code".to_string()),
                default_value: None,
                options: HashMap::new(),
            },
            CovariateVariableConfig {
                name: "Gender".to_string(),
                variable_type: VariableType::Categorical,
                accessor: "gender".to_string(),
                translation: None,
                description: Some("Gender code".to_string()),
                default_value: None,
                options: HashMap::new(),
            },
            CovariateVariableConfig {
                name: "Citizenship".to_string(),
                variable_type: VariableType::Categorical,
                accessor: "citizenship".to_string(),
                translation: Some("statsb".to_string()),
                description: Some("Citizenship/country code".to_string()),
                default_value: None,
                options: HashMap::new(),
            },
            CovariateVariableConfig {
                name: "Age".to_string(),
                variable_type: VariableType::Numeric,
                accessor: "age".to_string(),
                translation: None,
                description: Some("Age in years".to_string()),
                default_value: None,
                options: HashMap::new(),
            },
            CovariateVariableConfig {
                name: "Children Count".to_string(),
                variable_type: VariableType::Numeric,
                accessor: "children_count".to_string(),
                translation: None,
                description: Some("Number of children".to_string()),
                default_value: None,
                options: HashMap::new(),
            },
        ];

        // Income variables
        let income_variables = vec![
            CovariateVariableConfig {
                name: "Income Amount".to_string(),
                variable_type: VariableType::Numeric,
                accessor: "income_amount".to_string(),
                translation: None,
                description: Some("Total income amount".to_string()),
                default_value: Some("0".to_string()),
                options: HashMap::new(),
            },
            CovariateVariableConfig {
                name: "Wage Income".to_string(),
                variable_type: VariableType::Numeric,
                accessor: "wage_income".to_string(),
                translation: None,
                description: Some("Income from wages (LOENMV_13)".to_string()),
                default_value: Some("0".to_string()),
                options: HashMap::new(),
            },
            CovariateVariableConfig {
                name: "Employment Status".to_string(),
                variable_type: VariableType::Categorical,
                accessor: "employment_status".to_string(),
                translation: Some("beskst13".to_string()),
                description: Some("Employment status code (BESKST13)".to_string()),
                default_value: None,
                options: HashMap::new(),
            },
        ];

        // Education variables
        let education_variables = vec![
            CovariateVariableConfig {
                name: "Education Level".to_string(),
                variable_type: VariableType::Categorical,
                accessor: "education_level".to_string(),
                translation: None,
                description: Some("Highest education level attained".to_string()),
                default_value: None,
                options: HashMap::new(),
            },
            CovariateVariableConfig {
                name: "ISCED Code".to_string(),
                variable_type: VariableType::Categorical,
                accessor: "isced_code".to_string(),
                translation: None,
                description: Some(
                    "International Standard Classification of Education code".to_string(),
                ),
                default_value: None,
                options: HashMap::new(),
            },
            CovariateVariableConfig {
                name: "Education Years".to_string(),
                variable_type: VariableType::Numeric,
                accessor: "education_years".to_string(),
                translation: None,
                description: Some("Years of education".to_string()),
                default_value: None,
                options: HashMap::new(),
            },
        ];

        // Occupation variables
        let occupation_variables = vec![
            CovariateVariableConfig {
                name: "Occupation Code".to_string(),
                variable_type: VariableType::Categorical,
                accessor: "occupation_code".to_string(),
                translation: None,
                description: Some("Occupation classification code".to_string()),
                default_value: None,
                options: HashMap::new(),
            },
            CovariateVariableConfig {
                name: "Classification".to_string(),
                variable_type: VariableType::Categorical,
                accessor: "classification".to_string(),
                translation: None,
                description: Some("Classification system used for the occupation code".to_string()),
                default_value: None,
                options: HashMap::new(),
            },
            CovariateVariableConfig {
                name: "SOCIO".to_string(),
                variable_type: VariableType::Categorical,
                accessor: "socio".to_string(),
                translation: Some("socio13".to_string()),
                description: Some("Socioeconomic classification (SOCIO)".to_string()),
                default_value: None,
                options: HashMap::new(),
            },
            CovariateVariableConfig {
                name: "SOCIO02".to_string(),
                variable_type: VariableType::Categorical,
                accessor: "socio02".to_string(),
                translation: None,
                description: Some("Alternative socioeconomic classification (SOCIO02)".to_string()),
                default_value: None,
                options: HashMap::new(),
            },
            CovariateVariableConfig {
                name: "PRE_SOCIO".to_string(),
                variable_type: VariableType::Categorical,
                accessor: "pre_socio".to_string(),
                translation: Some("pre_socio".to_string()),
                description: Some("Previous socioeconomic classification (PRE_SOCIO)".to_string()),
                default_value: None,
                options: HashMap::new(),
            },
        ];

        // Create the complete configuration
        Self {
            covariate_types: vec![
                CovariateTypeConfig {
                    name: "Demographics".to_string(),
                    covariate_type: CovariateType::Demographics,
                    variables: demographics_variables,
                    description: Some(
                        "Demographic variables like age, gender, and family status".to_string(),
                    ),
                },
                CovariateTypeConfig {
                    name: "Income".to_string(),
                    covariate_type: CovariateType::Income,
                    variables: income_variables,
                    description: Some("Income-related variables".to_string()),
                },
                CovariateTypeConfig {
                    name: "Education".to_string(),
                    covariate_type: CovariateType::Education,
                    variables: education_variables,
                    description: Some("Education-related variables".to_string()),
                },
                CovariateTypeConfig {
                    name: "Occupation".to_string(),
                    covariate_type: CovariateType::Occupation,
                    variables: occupation_variables,
                    description: Some("Occupation and employment variables".to_string()),
                },
            ],
            settings: HashMap::new(),
        }
    }

    /// Save the configuration to a file
    pub fn save_to_file<P: AsRef<Path>>(&self, path: P) -> Result<(), Box<dyn std::error::Error>> {
        let json = serde_json::to_string_pretty(self)?;
        std::fs::write(path, json)?;
        Ok(())
    }
}

/// Helper for generating a default configuration file
pub fn generate_default_config<P: AsRef<Path>>(path: P) -> Result<(), Box<dyn std::error::Error>> {
    let config = CovariatesConfig::default_config();
    config.save_to_file(path)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    #[test]
    fn test_config_serialization() {
        let config = CovariatesConfig::default_config();
        let serialized = serde_json::to_string_pretty(&config).unwrap();
        let deserialized: CovariatesConfig = serde_json::from_str(&serialized).unwrap();

        assert_eq!(
            config.covariate_types.len(),
            deserialized.covariate_types.len()
        );

        // Check that all covariate types are present
        for ct in &config.covariate_types {
            let found = deserialized
                .covariate_types
                .iter()
                .find(|c| c.covariate_type == ct.covariate_type)
                .unwrap();

            assert_eq!(ct.name, found.name);
            assert_eq!(ct.variables.len(), found.variables.len());
        }
    }

    #[test]
    fn test_save_and_load_config() -> Result<(), Box<dyn std::error::Error>> {
        let config = CovariatesConfig::default_config();

        // Create a temporary file
        let mut temp_file = NamedTempFile::new()?;
        let path = temp_file.path().to_path_buf();

        // Write the config to the file
        let json = serde_json::to_string_pretty(&config)?;
        temp_file.write_all(json.as_bytes())?;
        temp_file.flush()?;

        // Load the config from the file
        let loaded_config = CovariatesConfig::from_file(&path)?;

        // Check that the loaded config matches the original
        assert_eq!(
            config.covariate_types.len(),
            loaded_config.covariate_types.len()
        );

        Ok(())
    }

    #[test]
    fn test_generate_default_config() -> Result<(), Box<dyn std::error::Error>> {
        // Create a temporary file
        let temp_file = NamedTempFile::new()?;
        let path = temp_file.path().to_path_buf();

        // Generate the default config
        generate_default_config(&path)?;

        // Load the config from the file
        let config = CovariatesConfig::from_file(&path)?;

        // Check that the config has the expected types
        assert_eq!(config.covariate_types.len(), 4);

        let types: Vec<CovariateType> = config
            .covariate_types
            .iter()
            .map(|ct| ct.covariate_type)
            .collect();

        assert!(types.contains(&CovariateType::Demographics));
        assert!(types.contains(&CovariateType::Income));
        assert!(types.contains(&CovariateType::Education));
        assert!(types.contains(&CovariateType::Occupation));

        Ok(())
    }
}
</file>

<file path="src/core/mod.rs">
pub mod config;
pub mod registry;

pub use config::{
    generate_default_config, CovariateTypeConfig, CovariateVariableConfig, CovariatesConfig,
};
pub use registry::CovariateProcessorRegistry;

// Re-export common error types that we use
pub use types::error::IdsError as Error;
// Create a type alias for Result to use with our Error type
pub type Result<T> = std::result::Result<T, Error>;
</file>

<file path="src/core/registry.rs">
use std::collections::HashMap;
use types::models::CovariateType;
use types::traits::CovariateProcessor;
use types::translation::TranslationMaps;

use crate::core::config::CovariatesConfig;
use crate::processing::demographic::DemographicsProcessor;
use crate::processing::education::EducationProcessor;
use crate::processing::factory::ProcessorFactory;
use crate::processing::income::IncomeProcessor;
use crate::processing::occupation::OccupationProcessor;

/// Registry for covariate processors
pub struct CovariateProcessorRegistry {
    processors: HashMap<CovariateType, Box<dyn CovariateProcessor>>,
}

impl CovariateProcessorRegistry {
    /// Create a new registry with all standard processors
    #[must_use] pub fn new() -> Self {
        let mut registry = Self {
            processors: HashMap::new(),
        };

        // Register all standard processors
        registry.register(Box::new(DemographicsProcessor::new()));
        registry.register(Box::new(EducationProcessor::new()));
        registry.register(Box::new(IncomeProcessor::new()));
        registry.register(Box::new(OccupationProcessor::new()));

        registry
    }

    /// Create a new registry from configuration
    #[must_use] pub fn from_config(config: CovariatesConfig) -> Self {
        Self::from_config_with_translations(config, None)
    }

    /// Create a new registry from configuration with translation maps
    #[must_use] pub fn from_config_with_translations(
        config: CovariatesConfig,
        translation_maps: Option<TranslationMaps>,
    ) -> Self {
        let mut registry = Self {
            processors: HashMap::new(),
        };

        let factory = match translation_maps {
            Some(maps) => ProcessorFactory::new(config).with_translation_maps(maps),
            None => ProcessorFactory::new(config),
        };

        // Create and register processors for all covariate types
        match factory.create_all_processors() {
            Ok(processors) => {
                for processor in processors {
                    registry.register(processor);
                }
            }
            Err(e) => {
                // Log the error but continue with empty registry
                log::warn!("Failed to create processors: {e}");
            }
        }

        registry
    }

    /// Register a new processor
    pub fn register(&mut self, processor: Box<dyn CovariateProcessor>) {
        self.processors
            .insert(processor.covariate_type(), processor);
    }

    /// Get a processor by covariate type
    #[must_use] pub fn get(&self, covariate_type: CovariateType) -> Option<&dyn CovariateProcessor> {
        self.processors.get(&covariate_type).map(std::convert::AsRef::as_ref)
    }

    /// Get all registered processors
    #[must_use] pub fn get_all(&self) -> Vec<&dyn CovariateProcessor> {
        self.processors.values().map(std::convert::AsRef::as_ref).collect()
    }

    /// Get all covariate types
    #[must_use] pub fn get_all_types(&self) -> Vec<CovariateType> {
        self.processors.keys().copied().collect()
    }

    /// Get all processors for a specific covariate type
    #[must_use] pub fn get_processors_for_type(
        &self,
        covariate_type: CovariateType,
    ) -> Vec<&dyn CovariateProcessor> {
        // In the current implementation, we only have one processor per type,
        // but we return a Vec for future extensibility
        if let Some(processor) = self.get(covariate_type) {
            vec![processor]
        } else {
            Vec::new()
        }
    }
}

impl Default for CovariateProcessorRegistry {
    fn default() -> Self {
        Self::new()
    }
}
</file>

<file path="src/data/matched_pairs/loader.rs">
use super::{MatchedPairRecord, MatchedPairsResult};
use hashbrown::HashMap;
use std::path::Path;
use types::error::IdsError;

pub fn load_matched_pairs(path: &Path) -> Result<MatchedPairsResult, IdsError> {
    let mut reader = csv::Reader::from_path(path).map_err(IdsError::from)?;
    let mut pairs: HashMap<(String, chrono::NaiveDate), Vec<String>> = HashMap::new();

    for result in reader.deserialize() {
        let record: MatchedPairRecord = result.map_err(IdsError::from)?;

        pairs
            .entry((record.case_pnr.clone(), record.case_treatment_date))
            .or_default()
            .push(record.control_pnr.clone());
    }

    Ok(pairs
        .into_iter()
        .map(|((case_pnr, date), controls)| (case_pnr, date, controls))
        .collect())
}
</file>

<file path="src/data/matched_pairs/mod.rs">
pub mod loader;
pub mod record;

pub use loader::load_matched_pairs;
pub use record::{CaseWithControls, Control, MatchedPairRecord};

pub type MatchedPairsResult = Vec<(String, chrono::NaiveDate, Vec<String>)>;

/// Load matched pair records from a CSV file
///
/// This is a wrapper around the csv reader to load matched pair records
///
/// # Arguments
/// * `path` - The path to the CSV file
///
/// # Returns
/// * `Result<Vec<MatchedPairRecord>, Box<dyn std::error::Error>>` - A list of matched pair records
pub fn load_matched_pair_records(
    path: &std::path::Path,
) -> Result<Vec<MatchedPairRecord>, Box<dyn std::error::Error>> {
    use csv::Reader;
    use std::fs::File;

    let file = File::open(path)?;
    let mut reader = Reader::from_reader(file);

    let records: Result<Vec<MatchedPairRecord>, _> = reader.deserialize().collect();
    Ok(records?)
}
</file>

<file path="src/data/matched_pairs/record.rs">
use chrono::NaiveDate;
use serde::{Deserialize, Deserializer};

#[derive(Deserialize, Debug, Clone)]
pub struct MatchedPairRecord {
    pub case_id: String,
    pub case_pnr: String,
    #[serde(with = "core::utils::date_format")]
    pub case_birth_date: NaiveDate,
    #[serde(with = "core::utils::date_format")]
    pub case_treatment_date: NaiveDate,
    pub control_id: String,
    pub control_pnr: String,
    #[serde(with = "core::utils::date_format")]
    pub control_birth_date: NaiveDate,
    pub birth_date_diff_days: i64,
    #[serde(deserialize_with = "deserialize_optional_i64")]
    pub mother_age_diff_days: i64,
    #[serde(deserialize_with = "deserialize_optional_i64")]
    pub father_age_diff_days: i64,
}

// Function to deserialize columns that could be NA or empty as 0
fn deserialize_optional_i64<'de, D>(deserializer: D) -> Result<i64, D::Error>
where
    D: Deserializer<'de>,
{
    let s: Option<String> = Option::deserialize(deserializer)?;
    match s {
        Some(s) if s.is_empty() || s.to_uppercase() == "NA" => Ok(0),
        Some(s) => s.parse::<i64>().map_err(serde::de::Error::custom),
        None => Ok(0),
    }
}

impl MatchedPairRecord {
    #[must_use] pub fn get_case_info(&self) -> (&str, NaiveDate) {
        (&self.case_pnr, self.case_treatment_date)
    }

    #[must_use] pub fn get_control_info(&self) -> (&str, NaiveDate) {
        (&self.control_pnr, self.case_treatment_date)
    }
}

/// Represents a single control for a case
#[derive(Debug, Clone)]
pub struct Control {
    pub id: String,
    pub pnr: String,
    pub birth_date: NaiveDate,
    pub birth_date_diff: i64,
    pub mother_age_diff: Option<i64>,
    pub father_age_diff: Option<i64>,
}

/// Represents a case with multiple controls
#[derive(Debug, Clone)]
pub struct CaseWithControls {
    pub case_id: String,
    pub case_pnr: String,
    pub case_birth_date: NaiveDate,
    pub case_treatment_date: NaiveDate,
    pub controls: Vec<Control>,
}

impl CaseWithControls {
    /// Convert a list of `MatchedPairRecords` into a list of `CaseWithControls`,
    /// grouping by `case_id`
    #[must_use] pub fn from_matched_pair_records(records: &[MatchedPairRecord]) -> Vec<Self> {
        let mut case_map: hashbrown::HashMap<String, CaseWithControls> = hashbrown::HashMap::new();

        for record in records {
            let case_id = record.case_id.clone();

            // Convert the control part of the MatchedPairRecord to a Control
            let control = Control {
                id: record.control_id.clone(),
                pnr: record.control_pnr.clone(),
                birth_date: record.control_birth_date,
                birth_date_diff: record.birth_date_diff_days,
                mother_age_diff: Some(record.mother_age_diff_days),
                father_age_diff: Some(record.father_age_diff_days),
            };

            // If we've seen this case before, add this control to its list
            if let Some(case_entry) = case_map.get_mut(&case_id) {
                case_entry.controls.push(control);
            } else {
                // Otherwise, create a new CaseWithControls
                let case_entry = CaseWithControls {
                    case_id: record.case_id.clone(),
                    case_pnr: record.case_pnr.clone(),
                    case_birth_date: record.case_birth_date,
                    case_treatment_date: record.case_treatment_date,
                    controls: vec![control],
                };
                case_map.insert(case_id, case_entry);
            }
        }

        case_map.into_values().collect()
    }
}
</file>

<file path="src/data/mod.rs">
pub mod matched_pairs;
mod storage;

pub use matched_pairs::*;
pub use storage::*;
</file>

<file path="src/data/storage.rs">
use chrono::NaiveDate;
use serde::{Deserialize, Serialize};
use std::path::Path;
use types::models::{CovariateType, CovariateValue};
use types::translation::TranslationMaps;

/// Data structure for storing covariate information
#[derive(Serialize, Deserialize)]
pub struct CovariateData {
    pub pnr: String,
    pub date: NaiveDate,
    pub covariate_type: CovariateType,
    pub value: CovariateValue,
    pub translated_value: Option<String>,
}

/// Save covariate data to a file
pub fn save_covariates(
    data: &[CovariateData],
    path: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    let file = std::fs::File::create(path)?;
    let writer = std::io::BufWriter::new(file);
    serde_json::to_writer(writer, data)?;
    Ok(())
}

/// Storage for covariate data with translation capabilities
pub struct CovariateStorage {
    translations: TranslationMaps,
    data: Vec<CovariateData>,
}

impl CovariateStorage {
    /// Create a new covariate storage with default translations
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        Ok(Self {
            translations: TranslationMaps::new()?,
            data: Vec::new(),
        })
    }

    /// Add a covariate to storage, automatically translating values when possible
    pub fn add_covariate(&mut self, mut covariate: CovariateData) {
        // Translate values based on covariate type
        covariate.translated_value = match &covariate.value {
            CovariateValue::Demographics { citizenship, .. } => citizenship
                .as_ref()
                .and_then(|code| {
                    self.translations
                        .translate(types::translation::TranslationType::Statsb, code)
                })
                .map(String::from),
            // Add more translations as needed
            _ => None,
        };

        self.data.push(covariate);
    }

    /// Save all stored covariates to a CSV file
    pub fn save_to_csv(&self, path: &Path) -> Result<(), Box<dyn std::error::Error>> {
        let mut writer = csv::Writer::from_path(path)?;

        writer.write_record([
            "PNR",
            "Date",
            "Covariate Type",
            "Raw Value",
            "Translated Value",
        ])?;

        for covariate in &self.data {
            writer.write_record([
                &covariate.pnr,
                &covariate.date.to_string(),
                &format!("{:?}", covariate.covariate_type),
                &format!("{:?}", covariate.value),
                covariate.translated_value.as_deref().unwrap_or(""),
            ])?;
        }

        writer.flush()?;
        Ok(())
    }
}
</file>

<file path="src/processing/demographic/mod.rs">
use crate::core::config::CovariateTypeConfig;
use crate::core::Error;
use crate::processing::processor::ConfigurableProcessor;
use types::error::{IdsError, Result};
use types::models::{Covariate, CovariateType};
use types::traits::CovariateProcessor;

/// Processor for demographic covariates
pub struct DemographicsProcessor {
    name: String,
}

impl DemographicsProcessor {
    /// Create a new demographics processor
    #[must_use] pub fn new() -> Self {
        Self {
            name: "Demographics".to_string(),
        }
    }
}

impl CovariateProcessor for DemographicsProcessor {
    fn process(&self, _store: &dyn types::traits::access::Store, _year: i32) -> Result<Covariate> {
        // Default implementation - would be overridden by concrete implementation
        Err(IdsError::invalid_operation("Not implemented".to_string()))
    }

    fn covariate_type(&self) -> CovariateType {
        CovariateType::Demographics
    }

    fn required_fields(&self) -> Vec<String> {
        vec![
            "KOM".to_string(),
            "FAMILIE_TYPE".to_string(),
            "STATSB".to_string(),
            "ANTPERSF".to_string(),
        ]
    }

    fn name(&self) -> &str {
        &self.name
    }

    fn is_categorical(&self) -> bool {
        // Demographics can be both, default to false
        false
    }

    fn process_numeric(&self, covariate: &Covariate) -> Option<f64> {
        if covariate.type_() != CovariateType::Demographics {
            return None;
        }

        // Example implementation for age
        covariate.age().map(f64::from)
    }

    fn process_categorical(&self, covariate: &Covariate) -> Option<String> {
        if covariate.type_() != CovariateType::Demographics {
            return None;
        }

        // Example implementation for gender
        covariate.gender().clone()
    }
}

impl ConfigurableProcessor for DemographicsProcessor {
    fn from_config(config: &CovariateTypeConfig) -> std::result::Result<Self, Error> {
        if config.covariate_type != CovariateType::Demographics {
            return Err(Error::config(format!(
                "Invalid covariate type: expected Demographics, got {:?}",
                config.covariate_type
            )));
        }

        Ok(Self {
            name: config.name.clone(),
        })
    }
}

/// Default implementation
impl Default for DemographicsProcessor {
    fn default() -> Self {
        Self::new()
    }
}
</file>

<file path="src/processing/education/mod.rs">
use crate::core::config::CovariateTypeConfig;
use crate::core::Error;
use crate::processing::processor::ConfigurableProcessor;
use types::error::{IdsError, Result};
use types::models::{Covariate, CovariateType};
use types::traits::CovariateProcessor;

/// Processor for education covariates
pub struct EducationProcessor {
    name: String,
}

impl EducationProcessor {
    /// Create a new education processor
    #[must_use] pub fn new() -> Self {
        Self {
            name: "Education".to_string(),
        }
    }
}

impl CovariateProcessor for EducationProcessor {
    fn process(&self, _store: &dyn types::traits::access::Store, _year: i32) -> Result<Covariate> {
        // Default implementation - would be overridden by concrete implementation
        Err(IdsError::invalid_operation("Not implemented".to_string()))
    }

    fn covariate_type(&self) -> CovariateType {
        CovariateType::Education
    }

    fn required_fields(&self) -> Vec<String> {
        vec!["HFAUDD".to_string()]
    }

    fn name(&self) -> &str {
        &self.name
    }

    fn is_categorical(&self) -> bool {
        // Default to false
        false
    }

    fn process_numeric(&self, covariate: &Covariate) -> Option<f64> {
        if covariate.type_() != CovariateType::Education {
            return None;
        }

        // Example implementation for education years
        covariate.education_years().map(f64::from)
    }

    fn process_categorical(&self, covariate: &Covariate) -> Option<String> {
        if covariate.type_() != CovariateType::Education {
            return None;
        }

        // Example implementation for education level
        covariate.education_level().clone()
    }
}

impl ConfigurableProcessor for EducationProcessor {
    fn from_config(config: &CovariateTypeConfig) -> std::result::Result<Self, Error> {
        if config.covariate_type != CovariateType::Education {
            return Err(Error::config(format!(
                "Invalid covariate type: expected Education, got {:?}",
                config.covariate_type
            )));
        }

        Ok(Self {
            name: config.name.clone(),
        })
    }
}

/// Default implementation
impl Default for EducationProcessor {
    fn default() -> Self {
        Self::new()
    }
}
</file>

<file path="src/processing/income/mod.rs">
use crate::core::config::CovariateTypeConfig;
use crate::core::Error;
use crate::processing::processor::ConfigurableProcessor;
use types::error::{IdsError, Result};
use types::models::{Covariate, CovariateType};
use types::traits::CovariateProcessor;

/// Processor for income covariates
pub struct IncomeProcessor {
    name: String,
}

impl IncomeProcessor {
    /// Create a new income processor
    #[must_use] pub fn new() -> Self {
        Self {
            name: "Income".to_string(),
        }
    }
}

impl CovariateProcessor for IncomeProcessor {
    fn process(&self, _store: &dyn types::traits::access::Store, _year: i32) -> Result<Covariate> {
        // Default implementation - would be overridden by concrete implementation
        Err(IdsError::invalid_operation("Not implemented".to_string()))
    }

    fn covariate_type(&self) -> CovariateType {
        CovariateType::Income
    }

    fn required_fields(&self) -> Vec<String> {
        vec!["PERINDKIALT_13".to_string()]
    }

    fn name(&self) -> &str {
        &self.name
    }

    fn is_categorical(&self) -> bool {
        false
    }

    fn process_numeric(&self, covariate: &Covariate) -> Option<f64> {
        if covariate.type_() != CovariateType::Income {
            return None;
        }

        covariate.income_amount()
    }

    fn process_categorical(&self, covariate: &Covariate) -> Option<String> {
        if covariate.type_() != CovariateType::Income {
            return None;
        }

        // Example: convert employment status to string
        covariate
            .employment_status()
            .map(|status| status.to_string())
    }
}

impl ConfigurableProcessor for IncomeProcessor {
    fn from_config(config: &CovariateTypeConfig) -> std::result::Result<Self, Error> {
        if config.covariate_type != CovariateType::Income {
            return Err(Error::config(format!(
                "Invalid covariate type: expected Income, got {:?}",
                config.covariate_type
            )));
        }

        Ok(Self {
            name: config.name.clone(),
        })
    }
}

/// Default implementation
impl Default for IncomeProcessor {
    fn default() -> Self {
        Self::new()
    }
}
</file>

<file path="src/processing/occupation/mod.rs">
use crate::core::config::CovariateTypeConfig;
use crate::core::Error;
use crate::processing::processor::ConfigurableProcessor;
use types::error::{IdsError, Result};
use types::models::{Covariate, CovariateType};
use types::traits::CovariateProcessor;

/// Processor for occupation covariates
pub struct OccupationProcessor {
    name: String,
}

impl OccupationProcessor {
    /// Create a new occupation processor
    #[must_use] pub fn new() -> Self {
        Self {
            name: "Occupation".to_string(),
        }
    }
}

impl CovariateProcessor for OccupationProcessor {
    fn process(&self, _store: &dyn types::traits::access::Store, _year: i32) -> Result<Covariate> {
        // Default implementation - would be overridden by concrete implementation
        Err(IdsError::invalid_operation("Not implemented".to_string()))
    }

    fn covariate_type(&self) -> CovariateType {
        CovariateType::Occupation
    }

    fn required_fields(&self) -> Vec<String> {
        vec!["DISCO08".to_string(), "SOCIO".to_string()]
    }

    fn name(&self) -> &str {
        &self.name
    }

    fn is_categorical(&self) -> bool {
        true
    }

    fn process_numeric(&self, covariate: &Covariate) -> Option<f64> {
        if covariate.type_() != CovariateType::Occupation {
            return None;
        }

        // Example: use socio as numeric value
        covariate.socio().map(f64::from)
    }

    fn process_categorical(&self, covariate: &Covariate) -> Option<String> {
        if covariate.type_() != CovariateType::Occupation {
            return None;
        }

        // Example: use occupation code as categorical
        covariate.occupation_code().clone()
    }
}

impl ConfigurableProcessor for OccupationProcessor {
    fn from_config(config: &CovariateTypeConfig) -> std::result::Result<Self, Error> {
        if config.covariate_type != CovariateType::Occupation {
            return Err(Error::config(format!(
                "Invalid covariate type: expected Occupation, got {:?}",
                config.covariate_type
            )));
        }

        Ok(Self {
            name: config.name.clone(),
        })
    }
}

/// Default implementation
impl Default for OccupationProcessor {
    fn default() -> Self {
        Self::new()
    }
}
</file>

<file path="src/processing/factory.rs">
use anyhow::Result;
use std::collections::HashMap;
use types::models::{Covariate, CovariateType};
use types::traits::{CovariateProcessor, VariableType};
use types::translation::{TranslationMaps, TranslationType};

use crate::core::config::{CovariateTypeConfig, CovariateVariableConfig, CovariatesConfig};
use crate::processing::processor::ConfigurableVariableProcessor;

/// A configurable covariate processor built from configuration
pub struct ConfigurableProcessorImpl {
    name: String,
    covariate_type: CovariateType,
    #[allow(dead_code)]
    variables: HashMap<String, VariableType>,
}

impl ConfigurableProcessorImpl {
    /// Create a new processor from configuration
    #[must_use] pub fn new(config: &CovariateTypeConfig) -> Self {
        let mut variables = HashMap::new();

        // Register all variables with their types
        for var in &config.variables {
            variables.insert(var.name.clone(), var.variable_type);
        }

        Self {
            name: config.name.clone(),
            covariate_type: config.covariate_type,
            variables,
        }
    }
}

impl CovariateProcessor for ConfigurableProcessorImpl {
    fn process(
        &self,
        _store: &dyn types::traits::access::Store,
        _year: i32,
    ) -> types::error::Result<Covariate> {
        // Default implementation, will be overridden by concrete processors
        Err(types::error::IdsError::invalid_operation(
            "Not implemented".to_string(),
        ))
    }

    fn covariate_type(&self) -> CovariateType {
        self.covariate_type
    }

    fn required_fields(&self) -> Vec<String> {
        // Default to empty list - concrete implementations will provide actual fields
        Vec::new()
    }

    fn name(&self) -> &str {
        &self.name
    }

    fn is_categorical(&self) -> bool {
        // Default to false - specialized implementations will determine this
        false
    }

    fn process_numeric(&self, _covariate: &Covariate) -> Option<f64> {
        // Default to None - specialized implementations will be needed
        None
    }

    fn process_categorical(&self, _covariate: &Covariate) -> Option<String> {
        // Default to None - specialized implementations will be needed
        None
    }
}

/// A configurable variable processor built from configuration
pub struct ConfigurableVariableProcessorImpl {
    name: String,
    variable_type: VariableType,
    covariate_type: CovariateType,
    accessor: String,
    translation: Option<String>,
    translation_maps: Option<TranslationMaps>,
    description: Option<String>,
}

impl ConfigurableVariableProcessorImpl {
    /// Create a new variable processor from configuration
    #[must_use] pub fn new(config: &CovariateVariableConfig, covariate_type: CovariateType) -> Self {
        Self {
            name: config.name.clone(),
            variable_type: config.variable_type,
            covariate_type,
            accessor: config.accessor.clone(),
            translation: config.translation.clone(),
            translation_maps: None,
            description: config.description.clone(),
        }
    }

    /// Create a new variable processor with translation maps
    #[must_use] pub fn with_translation_maps(
        config: &CovariateVariableConfig,
        covariate_type: CovariateType,
        translation_maps: TranslationMaps,
    ) -> Self {
        Self {
            name: config.name.clone(),
            variable_type: config.variable_type,
            covariate_type,
            accessor: config.accessor.clone(),
            translation: config.translation.clone(),
            translation_maps: Some(translation_maps),
            description: config.description.clone(),
        }
    }

    /// Convert a categorical value to a numeric code for numeric operations
    fn categorical_to_numeric(&self, value: &str) -> f64 {
        // Simple hash function to convert categorical values to numeric
        let mut hash = 0.0;
        for (i, b) in value.bytes().enumerate() {
            hash += f64::from(b) * (i + 1) as f64;
        }
        hash
    }

    /// Process a covariate value based on the accessor method name
    fn process_value(&self, covariate: &Covariate) -> Option<f64> {
        if covariate.type_() != self.covariate_type {
            return None;
        }

        match self.accessor.as_str() {
            // Demographics accessors - support both old and new method names
            "get_family_size" | "family_size" => covariate.family_size().map(f64::from),
            "get_municipality" | "municipality" => covariate.municipality().map(f64::from),
            "get_family_type" | "family_type" => {
                covariate.family_type().and_then(|v| v.parse::<f64>().ok())
            }
            "get_civil_status" | "civil_status" => covariate
                .civil_status()
                .map(|v| f64::from(v.bytes().next().unwrap_or(0))), // unwrap_or(0) is safe - default to 0 if empty string
            "get_gender" | "gender" => covariate
                .gender()
                .map(|v| f64::from(v.bytes().next().unwrap_or(0))), // unwrap_or(0) is safe - default to 0 if empty string
            "get_citizenship" | "citizenship" => covariate.citizenship().map(|v| {
                let mut hash = 0.0;
                for (i, b) in v.bytes().enumerate() {
                    hash += f64::from(b) * (i + 1) as f64;
                }
                hash
            }),
            "get_age" | "age" => covariate.age().map(f64::from),
            "get_children_count" | "children_count" => covariate.children_count().map(f64::from),

            // Income accessors
            "get_income_amount" | "income_amount" => covariate.income_amount(),
            "get_wage_income" | "wage_income" => covariate.wage_income(),
            "get_employment_status" | "employment_status" => {
                covariate.employment_status().map(f64::from)
            }

            // Education accessors
            "get_education_level" | "education_level" => covariate
                .education_level()
                .map(|v| self.categorical_to_numeric(&v)),
            "get_isced_code" | "isced_code" => covariate
                .isced_code()
                .map(|v| self.categorical_to_numeric(&v)),
            "get_education_years" | "education_years" => {
                covariate.education_years().map(f64::from)
            }

            // Occupation accessors
            "get_occupation_code" | "occupation_code" => covariate
                .occupation_code()
                .map(|v| self.categorical_to_numeric(&v)),
            "get_classification" | "classification" => covariate
                .classification()
                .map(|v| self.categorical_to_numeric(&v)),
            "get_socio" | "socio" => covariate.socio().map(f64::from),
            "get_socio02" | "socio02" => covariate.socio02().map(f64::from),
            "get_pre_socio" | "pre_socio" => covariate.pre_socio().map(f64::from),

            // Unknown accessor
            _ => {
                log::warn!("Unknown accessor method: {}", self.accessor);
                None
            }
        }
    }

    /// Process a categorical value based on the accessor method name
    fn process_categorical_value(&self, covariate: &Covariate) -> Option<String> {
        if covariate.type_() != self.covariate_type {
            return None;
        }

        let raw_value = match self.accessor.as_str() {
            // Demographics accessors - support both old and new method names
            "get_family_size" | "family_size" => {
                return covariate.family_size().map(|v| v.to_string())
            }
            "get_municipality" | "municipality" => {
                return covariate.municipality().map(|v| v.to_string())
            }
            "get_family_type" | "family_type" => covariate.family_type(),
            "get_civil_status" | "civil_status" => covariate.civil_status(),
            "get_gender" | "gender" => covariate.gender(),
            "get_citizenship" | "citizenship" => covariate.citizenship(),
            "get_age" | "age" => return covariate.age().map(|v| v.to_string()),
            "get_children_count" | "children_count" => {
                return covariate.children_count().map(|v| v.to_string())
            }

            // Income accessors
            "get_income_amount" | "income_amount" => {
                return covariate.income_amount().map(|v| v.to_string())
            }
            "get_wage_income" | "wage_income" => {
                return covariate.wage_income().map(|v| v.to_string())
            }
            "get_employment_status" | "employment_status" => {
                return covariate.employment_status().map(|v| v.to_string())
            }

            // Education accessors
            "get_education_level" | "education_level" => covariate.education_level(),
            "get_isced_code" | "isced_code" => covariate.isced_code(),
            "get_education_years" | "education_years" => {
                return covariate.education_years().map(|v| v.to_string())
            }

            // Occupation accessors
            "get_occupation_code" | "occupation_code" => covariate.occupation_code(),
            "get_classification" | "classification" => covariate.classification(),
            "get_socio" | "socio" => return covariate.socio().map(|v| v.to_string()),
            "get_socio02" | "socio02" => return covariate.socio02().map(|v| v.to_string()),
            "get_pre_socio" | "pre_socio" => return covariate.pre_socio().map(|v| v.to_string()),

            // Unknown accessor
            _ => {
                log::warn!("Unknown accessor method: {}", self.accessor);
                return None;
            }
        };

        // Apply translation if available
        if let (Some(translation_name), Some(translation_maps)) =
            (&self.translation, &self.translation_maps)
        {
            if let Some(value) = &raw_value {
                // Map translation type name to enum
                let translation_type = match translation_name.as_str() {
                    "statsb" => Some(TranslationType::Statsb),
                    "civst" => Some(TranslationType::Civst),
                    "family_type" => Some(TranslationType::FamilyType),
                    "fm_mark" => Some(TranslationType::FmMark),
                    "hustype" => Some(TranslationType::Hustype),
                    "reg" => Some(TranslationType::Reg),
                    "socio13" => Some(TranslationType::Socio13),
                    _ => None,
                };

                // Apply translation if type is recognized
                if let Some(trans_type) = translation_type {
                    if let Some(translated) = translation_maps.translate(trans_type, value) {
                        return Some(translated.to_string());
                    }
                }

                // Return original value if translation failed
                return Some(value.to_string());
            }
        }

        raw_value.map(|s| s.to_string())
    }
}

impl CovariateProcessor for ConfigurableVariableProcessorImpl {
    fn process(
        &self,
        _store: &dyn types::traits::access::Store,
        _year: i32,
    ) -> types::error::Result<Covariate> {
        // Default implementation, will be overridden by concrete processors
        Err(types::error::IdsError::invalid_operation(
            "Not implemented".to_string(),
        ))
    }

    fn covariate_type(&self) -> CovariateType {
        self.covariate_type
    }

    fn required_fields(&self) -> Vec<String> {
        // Default to empty list - concrete implementations will provide actual fields
        Vec::new()
    }

    fn name(&self) -> &str {
        &self.name
    }

    fn process_numeric(&self, covariate: &Covariate) -> Option<f64> {
        self.process_value(covariate)
    }

    fn process_categorical(&self, covariate: &Covariate) -> Option<String> {
        self.process_categorical_value(covariate)
    }

    fn is_categorical(&self) -> bool {
        matches!(self.variable_type, VariableType::Categorical)
    }

    fn variable_type(&self) -> VariableType {
        self.variable_type
    }
}

impl ConfigurableVariableProcessor for ConfigurableVariableProcessorImpl {
    fn variable_type() -> VariableType {
        VariableType::Categorical // Default, will be overridden
    }

    fn from_config(_config: &CovariateVariableConfig) -> Result<Self, crate::core::Error>
    where
        Self: Sized,
    {
        // This implementation requires covariate type, so it's not fully implemented here
        Err(crate::core::Error::config(
            "Incomplete implementation - use factory",
        ))
    }

    fn process(&self, _covariate: &Covariate) -> Option<types::models::CovariateValue> {
        // This would be implemented in specialized processors
        None
    }

    fn get_name(&self) -> &str {
        &self.name
    }

    fn get_description(&self) -> Option<&str> {
        self.description.as_deref()
    }
}

/// Factory for creating processors from configuration
pub struct ProcessorFactory {
    config: CovariatesConfig,
    translation_maps: Option<TranslationMaps>,
}

impl ProcessorFactory {
    /// Create a new factory from configuration
    #[must_use] pub fn new(config: CovariatesConfig) -> Self {
        Self {
            config,
            translation_maps: None,
        }
    }

    /// Set translation maps for the factory
    #[must_use] pub fn with_translation_maps(mut self, translation_maps: TranslationMaps) -> Self {
        self.translation_maps = Some(translation_maps);
        self
    }

    /// Create a processor for a covariate type
    #[must_use] pub fn create_processor(
        &self,
        covariate_type: CovariateType,
    ) -> Option<Box<dyn CovariateProcessor>> {
        self.config
            .get_covariate_type(covariate_type)
            .map(|config| {
                Box::new(ConfigurableProcessorImpl::new(config)) as Box<dyn CovariateProcessor>
            })
    }

    /// Create a processor for a specific variable
    #[must_use] pub fn create_variable_processor(
        &self,
        covariate_type: CovariateType,
        variable_name: &str,
    ) -> Option<Box<dyn CovariateProcessor>> {
        let covariate_config = self.config.get_covariate_type(covariate_type)?;
        let variable_config = covariate_config
            .variables
            .iter()
            .find(|v| v.name == variable_name)?;

        if let Some(translation_maps) = &self.translation_maps {
            Some(
                Box::new(ConfigurableVariableProcessorImpl::with_translation_maps(
                    variable_config,
                    covariate_type,
                    translation_maps.clone(),
                )) as Box<dyn CovariateProcessor>,
            )
        } else {
            Some(Box::new(ConfigurableVariableProcessorImpl::new(
                variable_config,
                covariate_type,
            )) as Box<dyn CovariateProcessor>)
        }
    }

    /// Create all processors for all covariate types
    pub fn create_all_processors(&self) -> Result<Vec<Box<dyn CovariateProcessor>>> {
        // Early validation - check if configuration is valid
        if self.config.covariate_types.is_empty() {
            return Err(anyhow::anyhow!(
                "No covariate types defined in configuration"
            ));
        }

        // Log what we're creating
        log::debug!(
            "Creating processors for {} covariate types",
            self.config.covariate_types.len()
        );

        // Create processors
        let processors = self
            .config
            .covariate_types
            .iter()
            .map(|config| {
                // Log each processor being created
                log::trace!("Creating processor for {}", config.name);
                Box::new(ConfigurableProcessorImpl::new(config)) as Box<dyn CovariateProcessor>
            })
            .collect();

        Ok(processors)
    }

    /// Create processors for all variables in a specific covariate type
    pub fn create_variable_processors_for_type(
        &self,
        covariate_type: CovariateType,
    ) -> Result<Vec<Box<dyn CovariateProcessor>>> {
        if let Some(covariate_config) = self.config.get_covariate_type(covariate_type) {
            // Check if we have variables defined
            if covariate_config.variables.is_empty() {
                return Err(anyhow::anyhow!(
                    "No variables defined for covariate type {:?}",
                    covariate_type
                )
                .context(format!("Configuration for {}", covariate_config.name)));
            }

            // Log what we're creating
            log::debug!(
                "Creating processors for {} variables of type {:?}",
                covariate_config.variables.len(),
                covariate_type
            );

            // Create variable processors
            let processors = covariate_config
                .variables
                .iter()
                .map(|var_config| {
                    log::trace!("Creating processor for variable {}", var_config.name);

                    if let Some(translation_maps) = &self.translation_maps {
                        Box::new(ConfigurableVariableProcessorImpl::with_translation_maps(
                            var_config,
                            covariate_type,
                            translation_maps.clone(),
                        )) as Box<dyn CovariateProcessor>
                    } else {
                        Box::new(ConfigurableVariableProcessorImpl::new(
                            var_config,
                            covariate_type,
                        )) as Box<dyn CovariateProcessor>
                    }
                })
                .collect();

            Ok(processors)
        } else {
            // No configuration for this type
            Err(anyhow::anyhow!(
                "No configuration found for covariate type {:?}",
                covariate_type
            ))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::config::CovariatesConfig;
    use types::models::Covariate;

    #[test]
    fn test_create_processor_from_config() {
        let config = CovariatesConfig::default_config();
        let factory = ProcessorFactory::new(config);

        // Create a processor for demographics
        let processor = match factory.create_processor(CovariateType::Demographics) {
            Some(p) => p,
            None => panic!("Demographics processor should be available in default config"),
        };

        assert_eq!(processor.name(), "Demographics");
        assert_eq!(processor.covariate_type(), CovariateType::Demographics);
    }

    #[test]
    fn test_create_variable_processor() {
        let config = CovariatesConfig::default_config();
        let factory = ProcessorFactory::new(config);

        // Create a processor for a specific variable
        let processor = match factory.create_variable_processor(CovariateType::Demographics, "Age")
        {
            Some(p) => p,
            None => panic!("Age variable processor should be available in default config"),
        };

        assert_eq!(processor.name(), "Age");
        assert_eq!(processor.covariate_type(), CovariateType::Demographics);
        assert_eq!(processor.variable_type(), VariableType::Numeric);

        // Create a test covariate

        let covariate = Covariate::demographics(
            2,               // family_size
            101,             // municipality
            "1".to_string(), // family_type
        )
        .with_civil_status("G".to_string())
        .with_gender("M".to_string())
        .with_citizenship("5100".to_string())
        .with_age(42)
        .with_children_count(2)
        .build();

        // Test the processor
        let value = processor.process_numeric(&covariate);
        assert_eq!(value, Some(42.0));
    }

    #[test]
    fn test_create_all_processors() -> Result<()> {
        let config = CovariatesConfig::default_config();
        let factory = ProcessorFactory::new(config);

        // Create all processors
        let processors = factory.create_all_processors()?;

        // Should have one processor for each covariate type
        assert_eq!(processors.len(), 4);

        // Verify that we have a processor for each type
        let types: Vec<CovariateType> = processors.iter().map(|p| p.covariate_type()).collect();

        assert!(types.contains(&CovariateType::Demographics));
        assert!(types.contains(&CovariateType::Income));
        assert!(types.contains(&CovariateType::Education));
        assert!(types.contains(&CovariateType::Occupation));

        Ok(())
    }

    #[test]
    fn test_empty_config_returns_error() {
        let config = CovariatesConfig {
            covariate_types: vec![], // Empty config
            settings: HashMap::new(),
        };
        let factory = ProcessorFactory::new(config);

        // Should return an error because the config is empty
        let result = factory.create_all_processors();
        assert!(result.is_err());

        // Check if there is an error as expected
        if let Err(err) = result {
            assert!(err.to_string().contains("No covariate types defined"));
        } else {
            panic!("Expected an error but got Ok");
        }
    }

    #[test]
    fn test_create_variable_processors_for_type() -> Result<()> {
        let config = CovariatesConfig::default_config();
        let factory = ProcessorFactory::new(config);

        // Create all processors for Demographics
        let processors =
            factory.create_variable_processors_for_type(CovariateType::Demographics)?;

        // Should have the correct number of processors
        assert_eq!(processors.len(), 8); // 8 demographic variables

        // Check that we have processor for specific variables
        let variable_names: Vec<&str> = processors.iter().map(|p| p.name()).collect();

        assert!(variable_names.contains(&"Age"));
        assert!(variable_names.contains(&"Family Size"));
        assert!(variable_names.contains(&"Family Type"));
        assert!(variable_names.contains(&"Gender"));

        Ok(())
    }

    #[test]
    fn test_invalid_covariate_type_returns_error() {
        let config = CovariatesConfig::default_config();
        // Create a copy of just the Demographics type from the config
        let demographics_type = config.covariate_types[0].clone();

        // Create a test config that only has Demographics defined
        let reduced_config = CovariatesConfig {
            covariate_types: vec![
                demographics_type, // Just Demographics
            ],
            settings: HashMap::new(),
        };
        let reduced_factory = ProcessorFactory::new(reduced_config);

        // Should return error for a non-existent type
        let result = reduced_factory.create_variable_processors_for_type(CovariateType::Occupation);
        assert!(result.is_err());

        // Check if there is an error as expected
        if let Err(err) = result {
            assert!(err.to_string().contains("Occupation"));
        } else {
            panic!("Expected an error but got Ok");
        }
    }
}
</file>

<file path="src/processing/mod.rs">
pub mod demographic;
pub mod education;
pub mod factory;
pub mod income;
pub mod occupation;
pub mod processor;

// Re-export the main processor interfaces for convenience
pub use factory::ProcessorFactory;
pub use processor::{ConfigurableProcessor, ConfigurableVariableProcessor};

// Re-export the specific processors
pub use demographic::DemographicsProcessor;
pub use education::EducationProcessor;
pub use income::IncomeProcessor;
pub use occupation::OccupationProcessor;
</file>

<file path="src/processing/processor.rs">
use crate::core::config::{CovariateTypeConfig, CovariateVariableConfig};
use crate::core::Error;
use types::models::{Covariate, CovariateValue};
use types::traits::{CovariateProcessor, VariableType};

/// A processor that can be configured from configuration
pub trait ConfigurableProcessor: CovariateProcessor {
    /// Create a new processor from configuration
    fn from_config(config: &CovariateTypeConfig) -> std::result::Result<Self, Error>
    where
        Self: Sized;
}

/// A variable processor that can be configured
pub trait ConfigurableVariableProcessor {
    /// The variable type this processor handles
    fn variable_type() -> VariableType;

    /// Create a new processor from configuration
    fn from_config(config: &CovariateVariableConfig) -> std::result::Result<Self, Error>
    where
        Self: Sized;

    /// Process a covariate and return a value
    fn process(&self, covariate: &Covariate) -> Option<CovariateValue>;

    /// Get the name of the variable
    fn get_name(&self) -> &str;

    /// Get the description of the variable
    fn get_description(&self) -> Option<&str>;
}
</file>

<file path="src/reporting/balance_report.rs">
use crate::balance::BalanceResults;

pub struct BalanceReport {
    results: BalanceResults,
}

impl BalanceReport {
    #[must_use]
    pub const fn new(results: BalanceResults) -> Self {
        Self { results }
    }

    #[must_use] pub fn generate_summary_statistics(&self) -> Vec<ReportRow> {
        self.results
            .summaries
            .iter()
            .map(|summary| {
                let (case_missing, control_missing) = self
                    .results
                    .missing_data_rates
                    .get(&summary.variable)
                    .unwrap_or(&(0.0, 0.0));

                ReportRow {
                    variable: summary.variable.clone(),
                    mean_cases: summary.mean_cases,
                    mean_controls: summary.mean_controls,
                    std_diff: summary.std_diff,
                    variance_ratio: summary.variance_ratio,
                    missing_cases: *case_missing,
                    missing_controls: *control_missing,
                }
            })
            .collect()
    }
}

#[derive(Debug)]
pub struct ReportRow {
    pub variable: String,
    pub mean_cases: f64,
    pub mean_controls: f64,
    pub std_diff: f64,
    pub variance_ratio: f64,
    pub missing_cases: f64,
    pub missing_controls: f64,
}
</file>

<file path="src/reporting/comprehensive_report.rs">
use crate::balance::BalanceResults;
use hashbrown::HashMap;
use std::path::Path;

pub struct ComprehensiveReport {
    results: BalanceResults,
}

impl ComprehensiveReport {
    #[must_use]
    pub const fn new(results: BalanceResults) -> Self {
        Self { results }
    }

    /// Save all balance results to separate files
    ///
    /// # Errors
    /// Returns an error if there are issues writing to the output files
    pub fn save_to_files(&self, base_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
        // Save overall summaries
        self.save_overall_summaries(base_path)?;

        // Save missing data rates
        self.save_missing_rates(base_path)?;

        // Save matched pair summaries
        self.save_matched_pair_summaries(base_path)?;

        // Save matched pair summary statistics
        self.save_matched_pair_summary(&base_path.join("matched_pair_summary.csv"))?;

        Ok(())
    }

    /// Generate plots for the balance analysis
    ///
    /// # Errors
    /// Returns an error if there are issues generating the plots
    pub fn generate_plots(&self, plots_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
        use std::fs;

        // Ensure plots directory exists
        fs::create_dir_all(plots_dir)?;

        // Generate standardized difference distribution plot
        self.generate_std_diff_distribution_plot(plots_dir)?;

        // Generate missing data rate plot
        self.generate_missing_data_plot(plots_dir)?;

        Ok(())
    }

    /// Generate a plot showing the distribution of standardized differences
    fn generate_std_diff_distribution_plot(
        &self,
        plots_dir: &Path,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // This is a placeholder. In a real implementation, we would use a plotting library
        // like plotters to create visualization of standardized differences.

        // Create a simple text-based plot visualization for now
        let plot_path = plots_dir.join("std_diff_distribution.txt");
        let mut content = String::new();

        content.push_str("Standardized Difference Distribution (ASCII Visualization)\n");
        content.push_str("=====================================================\n\n");

        let summaries = self.summarize_matched_pair_balance();

        for (variable, std_diffs) in summaries {
            // Get basic stats
            let mean = std_diffs.iter().sum::<f64>() / std_diffs.len() as f64;

            // Create a simple histogram
            let mut histogram = [0; 11]; // -0.5 to 0.5 in 0.1 increments

            for &diff in &std_diffs {
                if (-0.5..=0.5).contains(&diff) {
                    let bin = ((diff + 0.5) / 0.1).floor() as usize;
                    let bin = bin.min(10); // Ensure we don't go out of bounds
                    histogram[bin] += 1;
                }
            }

            // Normalize for display
            let max_count = histogram.iter().copied().max().unwrap_or(1);
            let scale = 40.0 / f64::from(max_count);

            content.push_str(&format!("{variable} (mean: {mean:.3}):\n"));

            for (i, &count) in histogram.iter().enumerate() {
                let lower = -0.5 + i as f64 * 0.1;
                let upper = lower + 0.1;
                let bar_len = (f64::from(count) * scale).round() as usize;
                let bar = "#".repeat(bar_len);

                content.push_str(&format!(
                    "[{lower:.1}, {upper:.1}): {bar} {count}\n"
                ));
            }
            content.push('\n');
        }

        // Write to file
        std::fs::write(plot_path, content)?;

        Ok(())
    }

    /// Generate a plot showing missing data rates
    fn generate_missing_data_plot(
        &self,
        plots_dir: &Path,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // Create a simple text-based plot for missing data rates
        let plot_path = plots_dir.join("missing_data_rates.txt");
        let mut content = String::new();

        content.push_str("Missing Data Rates (ASCII Visualization)\n");
        content.push_str("=====================================\n\n");

        for (var, (case_rate, control_rate)) in &self.results.missing_data_rates {
            let case_bar_len = (case_rate * 50.0).round() as usize;
            let control_bar_len = (control_rate * 50.0).round() as usize;

            let case_bar = "#".repeat(case_bar_len);
            let control_bar = "#".repeat(control_bar_len);

            content.push_str(&format!("{var}:\n"));
            content.push_str(&format!(
                "Cases:    {} {:.1}%\n",
                case_bar,
                case_rate * 100.0
            ));
            content.push_str(&format!(
                "Controls: {} {:.1}%\n\n",
                control_bar,
                control_rate * 100.0
            ));
        }

        // Write to file
        std::fs::write(plot_path, content)?;

        Ok(())
    }

    fn save_overall_summaries(&self, base_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
        let path = base_path.join("covariate_balance.csv");
        let mut wtr = csv::Writer::from_path(path)?;

        // Enhanced CSV with category information
        wtr.write_record([
            "Variable",
            "Category",
            "Register",
            "Register Variable",
            "Mean (Cases)",
            "Mean (Controls)",
            "Standardized Difference",
            "Variance Ratio",
        ])?;

        // Map variables to their categories and register details
        for summary in &self.results.summaries {
            // Determine variable category and register info
            let (category, register, register_variable) =
                super::csv_report::categorize_variable(&summary.variable);

            wtr.write_record([
                &summary.variable,
                category,
                register,
                register_variable,
                &summary.mean_cases.to_string(),
                &summary.mean_controls.to_string(),
                &summary.std_diff.to_string(),
                &summary.variance_ratio.to_string(),
            ])?;
        }

        wtr.flush()?;
        Ok(())
    }

    // Using the categorize_variable in csv_report instead

    fn save_missing_rates(&self, base_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
        let path = base_path.join("missing_data_rates.csv");
        let mut wtr = csv::Writer::from_path(path)?;

        wtr.write_record(["Variable", "Case Missing Rate", "Control Missing Rate"])?;

        for (var, (case_rate, control_rate)) in &self.results.missing_data_rates {
            wtr.write_record([var, &case_rate.to_string(), &control_rate.to_string()])?;
        }

        wtr.flush()?;
        Ok(())
    }

    fn save_matched_pair_summaries(
        &self,
        base_path: &Path,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let path = base_path.join("matched_pair_details.csv");
        let mut wtr = csv::Writer::from_path(path)?;

        wtr.write_record([
            "Case PNR",
            "Control PNRs",
            "Treatment Date",
            "Variable",
            "Case Value",
            "Control Value",
            "Standardized Difference",
        ])?;

        for detail in &self.results.matched_pair_details {
            wtr.write_record([
                &detail.case_pnr,
                &detail.control_pnrs.join(";"), // Join multiple control PNRs with semicolon
                &detail.treatment_date.to_string(),
                &detail.variable,
                &detail.case_value.to_string(),
                &detail.control_value.to_string(),
                &detail.std_diff.to_string(),
            ])?;
        }

        wtr.flush()?;
        Ok(())
    }

    #[must_use] pub fn summarize_matched_pair_balance(&self) -> HashMap<String, Vec<f64>> {
        let mut summaries: HashMap<String, Vec<f64>> = HashMap::new();

        for detail in &self.results.matched_pair_details {
            summaries
                .entry(detail.variable.clone())
                .or_default()
                .push(detail.std_diff);
        }

        summaries
    }

    pub fn save_matched_pair_summary(&self, path: &Path) -> Result<(), Box<dyn std::error::Error>> {
        let mut wtr = csv::Writer::from_path(path)?;

        wtr.write_record([
            "Variable",
            "Mean Std Diff",
            "Median Std Diff",
            "Max Std Diff",
            "Std Diff > 0.1 (%)",
            "N Pairs",
        ])?;

        let summaries = self.summarize_matched_pair_balance();

        for (variable, std_diffs) in summaries {
            let mean_diff = std_diffs.iter().sum::<f64>() / std_diffs.len() as f64;
            let median_diff = {
                let mut sorted = std_diffs.clone();
                sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());
                sorted[sorted.len() / 2]
            };
            let max_diff = std_diffs.iter().fold(0.0f64, |a, &b| a.max(b.abs()));
            let large_diff_pct = std_diffs.iter().filter(|&&x| x.abs() > 0.1).count() as f64
                / std_diffs.len() as f64
                * 100.0;

            wtr.write_record([
                &variable,
                &format!("{mean_diff:.3}"),
                &format!("{median_diff:.3}"),
                &format!("{max_diff:.3}"),
                &format!("{large_diff_pct:.1}"),
                &std_diffs.len().to_string(),
            ])?;
        }

        wtr.flush()?;
        Ok(())
    }
}
</file>

<file path="src/reporting/csv_report.rs">
use super::balance_report::BalanceReport;
use std::path::Path;
use types::error::IdsError;

pub trait CsvReport {
    fn save_to_csv(&self, path: &Path) -> Result<(), IdsError>;
}

// Helper function to categorize variables - to be reused across modules
pub fn categorize_variable(variable: &str) -> (&'static str, &'static str, &'static str) {
    match variable {
        // Demographics variables (BEF)
        v if v.contains("Family Size") => ("Demographics", "BEF", "ANTPERSF/ANTPERSH"),
        v if v.contains("Municipality") => ("Demographics", "BEF", "KOM"),
        v if v.contains("Family Type") => ("Demographics", "BEF", "FAMILIE_TYPE"),
        v if v.contains("Civil Status") => ("Demographics", "BEF", "CIVST"),
        v if v.contains("Gender") => ("Demographics", "BEF", "KOEN"),
        v if v.contains("Citizenship") => ("Demographics", "BEF", "STATSB"),
        v if v.contains("Age") => ("Demographics", "BEF", "ALDER"),
        v if v.contains("Children Count") => ("Demographics", "BEF", "ANTBOERNF/ANTBOERNH"),

        // Income variables (IND)
        "Income" => ("Income", "IND", "PERINDKIALT_13"),
        v if v.contains("Wage Income") => ("Income", "IND", "LOENMV_13"),
        v if v.contains("Employment Status") => ("Income", "IND", "BESKST13"),

        // Occupation variables (AKM)
        v if v.contains("SOCIO13") => ("Occupation", "AKM", "SOCIO13"),
        v if v == "SOCIO" || v.contains("SOCIO Category") => ("Occupation", "AKM", "SOCIO"),
        v if v.contains("SOCIO02") => ("Occupation", "AKM", "SOCIO02"),
        v if v.contains("Previous Socioeconomic") => ("Occupation", "IND", "PRE_SOCIO"),
        v if v.contains("Classification System") => ("Occupation", "AKM", "Classification"),

        // Education variables
        v if v.contains("Education") || v.contains("ISCED") => ("Education", "UDDA", "Education"),

        // Default case
        _ => ("Other", "", ""),
    }
}

impl CsvReport for BalanceReport {
    fn save_to_csv(&self, output_path: &Path) -> Result<(), IdsError> {
        let mut wtr = csv::Writer::from_path(output_path)?;

        // Enhanced CSV format with categories
        wtr.write_record([
            "Variable",
            "Category",
            "Register",
            "Register Variable",
            "Mean (Cases)",
            "Mean (Controls)",
            "Std. Difference",
            "Variance Ratio",
            "Missing (Cases)",
            "Missing (Controls)",
        ])?;

        for row in self.generate_summary_statistics() {
            // Categorize the variable
            let (category, register, register_var) = categorize_variable(&row.variable);

            wtr.write_record([
                &row.variable,
                category,
                register,
                register_var,
                &format!("{:.2}", row.mean_cases),
                &format!("{:.2}", row.mean_controls),
                &format!("{:.3}", row.std_diff),
                &format!("{:.3}", row.variance_ratio),
                &format!("{:.1}%", row.missing_cases * 100.0),
                &format!("{:.1}%", row.missing_controls * 100.0),
            ])?;
        }

        wtr.flush()?;
        Ok(())
    }
}
</file>

<file path="src/reporting/mod.rs">
mod balance_report;
mod comprehensive_report;
mod csv_report;
mod structured_output;

pub use balance_report::BalanceReport;
pub use comprehensive_report::ComprehensiveReport;
pub use csv_report::CsvReport;
pub use structured_output::{OutputDirType, StructuredOutputManager};
</file>

<file path="src/reporting/structured_output.rs">
use crate::balance::results::BalanceResults;
use crate::data::matched_pairs::record::{CaseWithControls, MatchedPairRecord};
use chrono::Local;
use hashbrown::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use types::error::IdsError;

/// A centralized manager for structured output organization
pub struct StructuredOutputManager {
    /// Root output directory
    base_dir: PathBuf,
    /// Report directory for HTML and human-readable output
    report_dir: PathBuf,
    /// Data directory for raw CSV files
    data_dir: PathBuf,
    /// Plots directory for all visualizations
    plots_dir: PathBuf,
    /// Log directory for all logs
    logs_dir: PathBuf,
    /// Flag to enable detailed debug information in reports
    debug_mode: bool,
    /// Runtime information to include in reports
    runtime_info: HashMap<String, String>,
}

impl StructuredOutputManager {
    /// Create a new structured output manager with the given base directory
    pub fn new<P: AsRef<Path>>(base_dir: P) -> Result<Self, IdsError> {
        let base_dir = base_dir.as_ref().to_path_buf();
        let timestamp = Local::now().format("%Y%m%d_%H%M%S").to_string();

        // Create the main directory structure
        let report_dir = base_dir.join("report");
        let data_dir = base_dir.join("data");
        let plots_dir = base_dir.join("plots");
        let logs_dir = base_dir.join("logs");

        // Create additional subdirectories
        let dirs = [
            &report_dir,
            &data_dir,
            &data_dir.join("balance"),
            &data_dir.join("matching"),
            &data_dir.join("register"),
            &plots_dir,
            &plots_dir.join("balance"),
            &plots_dir.join("matching"),
            &plots_dir.join("data_quality"),
            &logs_dir,
        ];

        for dir in &dirs {
            fs::create_dir_all(dir).map_err(|e| {
                IdsError::io_error(format!("Failed to create directory {dir:?}: {e}"))
            })?;
        }

        // Initialize runtime information
        let mut runtime_info = HashMap::new();
        runtime_info.insert("generated_at".to_string(), timestamp);
        runtime_info.insert("version".to_string(), env!("CARGO_PKG_VERSION").to_string());

        Ok(Self {
            base_dir,
            report_dir,
            data_dir,
            plots_dir,
            logs_dir,
            debug_mode: false,
            runtime_info,
        })
    }

    /// Enable debug mode with more detailed output
    #[must_use] pub fn with_debug_mode(mut self, debug: bool) -> Self {
        self.debug_mode = debug;
        self
    }

    /// Add custom runtime information to be included in reports
    pub fn with_runtime_info<K: Into<String>, V: Into<String>>(mut self, key: K, value: V) -> Self {
        self.runtime_info.insert(key.into(), value.into());
        self
    }

    /// Get the path to the specified output directory
    #[must_use] pub fn get_dir_path(&self, dir_type: OutputDirType) -> PathBuf {
        match dir_type {
            OutputDirType::Base => self.base_dir.clone(),
            OutputDirType::Report => self.report_dir.clone(),
            OutputDirType::Data => self.data_dir.clone(),
            OutputDirType::Plots => self.plots_dir.clone(),
            OutputDirType::Logs => self.logs_dir.clone(),
            OutputDirType::BalanceData => self.data_dir.join("balance"),
            OutputDirType::MatchingData => self.data_dir.join("matching"),
            OutputDirType::RegisterData => self.data_dir.join("register"),
            OutputDirType::BalancePlots => self.plots_dir.join("balance"),
            OutputDirType::MatchingPlots => self.plots_dir.join("matching"),
            OutputDirType::DataQualityPlots => self.plots_dir.join("data_quality"),
        }
    }

    /// Output balance results in structured format
    pub fn output_balance_results(
        &self,
        results: &BalanceResults,
        filename_prefix: Option<&str>,
    ) -> Result<(), IdsError> {
        // Get the base balance data directory
        let balance_dir = self.get_dir_path(OutputDirType::BalanceData);
        let prefix = filename_prefix.unwrap_or("balance");

        // Output covariate balance
        let covariate_path = balance_dir.join(format!("{prefix}_covariate_balance.csv"));
        self.write_csv_data(
            &covariate_path,
            "Variable,Mean (Cases),Mean (Controls),Standardized Difference,Variance Ratio",
            &results
                .summaries
                .iter()
                .map(|s| {
                    format!(
                        "{},{},{},{},{}",
                        s.variable, s.mean_cases, s.mean_controls, s.std_diff, s.variance_ratio
                    )
                })
                .collect::<Vec<_>>(),
        )?;

        // Output missing data rates
        let missing_path = balance_dir.join(format!("{prefix}_missing_data_rates.csv"));
        let missing_header = "Variable,Case Missing Rate,Control Missing Rate";
        let missing_rates: Vec<String> = results
            .missing_data_rates
            .iter()
            .map(|(var, (case_rate, ctrl_rate))| format!("{var},{case_rate},{ctrl_rate}"))
            .collect();
        self.write_csv_data(&missing_path, missing_header, &missing_rates)?;

        // Generate standardized difference statistics
        let std_diff_path = balance_dir.join(format!("{prefix}_std_differences.csv"));
        let std_diff_header = "Variable,Min,Max,Mean,StdDev,AbsMean";
        let mut var_stats: HashMap<String, Vec<f64>> = HashMap::new();

        // Collect by variable
        for detail in &results.matched_pair_details {
            var_stats
                .entry(detail.variable.clone())
                .or_default()
                .push(detail.std_diff);
        }

        // Calculate statistics for each variable
        let std_diff_data: Vec<String> = var_stats
            .iter()
            .map(|(var, values)| {
                if values.is_empty() {
                    return format!("{var},0.0,0.0,0.0,0.0,0.0");
                }

                let sum: f64 = values.iter().sum();
                let mean = sum / values.len() as f64;
                let sum_squared: f64 = values.iter().map(|v| (v - mean).powi(2)).sum();
                let std_dev = (sum_squared / values.len() as f64).sqrt();
                let abs_mean = values.iter().map(|v| v.abs()).sum::<f64>() / values.len() as f64;

                format!(
                    "{},{},{},{},{},{}",
                    var,
                    values.iter().copied().fold(f64::INFINITY, f64::min),
                    values.iter().copied().fold(f64::NEG_INFINITY, f64::max),
                    mean,
                    std_dev,
                    abs_mean
                )
            })
            .collect();
        self.write_csv_data(&std_diff_path, std_diff_header, &std_diff_data)?;

        // Generate HTML report
        self.generate_balance_html_report(results, filename_prefix)?;

        Ok(())
    }

    /// Output matched pairs data in structured format
    pub fn output_matched_pairs(
        &self,
        matched_pair_records: &[MatchedPairRecord],
        filename_prefix: Option<&str>,
    ) -> Result<(), IdsError> {
        // Convert MatchedPairRecord to CaseWithControls
        let matched_pairs = CaseWithControls::from_matched_pair_records(matched_pair_records);
        let matching_dir = self.get_dir_path(OutputDirType::MatchingData);
        let prefix = filename_prefix.unwrap_or("matching");

        // Main matched pairs CSV
        let pairs_path = matching_dir.join(format!("{prefix}_pairs.csv"));
        let pairs_header = "case_id,case_pnr,case_birth_date,case_treatment_date,control_id,control_pnr,control_birth_date,birth_date_diff_days,mother_age_diff_days,father_age_diff_days";

        let pairs_data: Vec<String> = matched_pairs
            .iter()
            .flat_map(|record| {
                record.controls.iter().map(move |control| {
                    format!(
                        "{},{},{},{},{},{},{},{},{},{}",
                        record.case_id,
                        record.case_pnr,
                        record.case_birth_date,
                        record.case_treatment_date,
                        control.id,
                        control.pnr,
                        control.birth_date,
                        control.birth_date_diff,
                        control.mother_age_diff.unwrap_or(-1),
                        control.father_age_diff.unwrap_or(-1)
                    )
                })
            })
            .collect();

        self.write_csv_data(&pairs_path, pairs_header, &pairs_data)?;

        // Matching statistics
        let stats_path = matching_dir.join(format!("{prefix}_stats.csv"));
        let stats_header =
            "case_id,n_controls,avg_birth_diff,max_birth_diff,avg_mother_diff,avg_father_diff";

        let stats_data: Vec<String> = matched_pairs
            .iter()
            .map(|record| {
                let n_controls = record.controls.len();

                if n_controls == 0 {
                    return format!("{},0,0,0,0,0", record.case_id);
                }

                let avg_birth_diff: f64 = record
                    .controls
                    .iter()
                    .map(|c| c.birth_date_diff as f64)
                    .sum::<f64>()
                    / n_controls as f64;

                let max_birth_diff = record
                    .controls
                    .iter()
                    .map(|c| c.birth_date_diff)
                    .max()
                    .unwrap_or(0);

                let avg_mother_diff: f64 = record
                    .controls
                    .iter()
                    .filter_map(|c| c.mother_age_diff)
                    .map(|diff| diff as f64)
                    .sum::<f64>()
                    / n_controls as f64;

                let avg_father_diff: f64 = record
                    .controls
                    .iter()
                    .filter_map(|c| c.father_age_diff)
                    .map(|diff| diff as f64)
                    .sum::<f64>()
                    / n_controls as f64;

                format!(
                    "{},{},{:.2},{},{:.2},{:.2}",
                    record.case_id,
                    n_controls,
                    avg_birth_diff,
                    max_birth_diff,
                    avg_mother_diff,
                    avg_father_diff
                )
            })
            .collect();

        self.write_csv_data(&stats_path, stats_header, &stats_data)?;

        // Generate HTML report
        self.generate_matching_html_report(&matched_pairs, filename_prefix)?;

        Ok(())
    }

    /// Generate a comprehensive index.html report
    pub fn generate_index_html(&self) -> Result<(), IdsError> {
        let report_dir = self.get_dir_path(OutputDirType::Report);
        let index_path = report_dir.join("index.html");

        let html_content = format!(
            r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IDS-RS Analysis Report</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            color: #333;
        }}
        .container {{
            max-width: 1200px;
            margin: 0 auto;
        }}
        header {{
            background-color: #f5f5f5;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 5px;
        }}
        h1 {{
            color: #2c3e50;
            margin-top: 0;
        }}
        .card {{
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }}
        .info-bar {{
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }}
        .section {{
            margin-bottom: 30px;
        }}
        a.report-link {{
            display: inline-block;
            background-color: #3498db;
            color: white;
            padding: 10px 15px;
            text-decoration: none;
            border-radius: 5px;
            margin-right: 10px;
            margin-bottom: 10px;
        }}
        a.report-link:hover {{
            background-color: #2980b9;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
        }}
        th, td {{
            padding: 12px 15px;
            border-bottom: 1px solid #ddd;
            text-align: left;
        }}
        th {{
            background-color: #f2f2f2;
        }}
        tr:hover {{
            background-color: #f5f5f5;
        }}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>IDS-RS Analysis Report</h1>
            <div class="info-bar">
                <strong>Generated:</strong> {generated_at} |
                <strong>Version:</strong> {version}
            </div>
        </header>

        <div class="section">
            <div class="card">
                <h2>Reports</h2>
                <p>Access detailed analysis reports:</p>
                <div>
                    <a href="balance_report.html" class="report-link">Balance Analysis</a>
                    <a href="matching_report.html" class="report-link">Matching Analysis</a>
                    <a href="data_quality_report.html" class="report-link">Data Quality</a>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="card">
                <h2>Analysis Summary</h2>
                <p>Key findings from the analysis:</p>
                <ul>
                    <li>Balance analysis assessed covariate distributions across treatment and control groups</li>
                    <li>Matching analysis evaluated the quality of matched pairs</li>
                    <li>Data quality metrics identified potential issues in the dataset</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <div class="card">
                <h2>Data Files</h2>
                <p>Raw data files available for download:</p>
                <table>
                    <tr>
                        <th>Category</th>
                        <th>Filename</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>Balance</td>
                        <td><a href="../data/balance/balance_covariate_balance.csv">balance_covariate_balance.csv</a></td>
                        <td>Covariate balance statistics</td>
                    </tr>
                    <tr>
                        <td>Balance</td>
                        <td><a href="../data/balance/balance_missing_data_rates.csv">balance_missing_data_rates.csv</a></td>
                        <td>Missing data rates by variable</td>
                    </tr>
                    <tr>
                        <td>Balance</td>
                        <td><a href="../data/balance/balance_std_differences.csv">balance_std_differences.csv</a></td>
                        <td>Standardized difference statistics</td>
                    </tr>
                    <tr>
                        <td>Matching</td>
                        <td><a href="../data/matching/matching_pairs.csv">matching_pairs.csv</a></td>
                        <td>Matched pair records</td>
                    </tr>
                    <tr>
                        <td>Matching</td>
                        <td><a href="../data/matching/matching_stats.csv">matching_stats.csv</a></td>
                        <td>Matching quality statistics</td>
                    </tr>
                </table>
            </div>
        </div>
    </div>
</body>
</html>"#,
            generated_at = self
                .runtime_info
                .get("generated_at")
                .unwrap_or(&String::from("Unknown")),
            version = self
                .runtime_info
                .get("version")
                .unwrap_or(&String::from("Unknown"))
        );

        fs::write(&index_path, html_content)
            .map_err(|e| IdsError::io_error(format!("Failed to write index.html: {e}")))?;

        Ok(())
    }

    /// Utility method to write CSV data to a file
    fn write_csv_data<P: AsRef<Path>>(
        &self,
        path: P,
        header: &str,
        data: &[String],
    ) -> Result<(), IdsError> {
        let content = format!("{}\n{}", header, data.join("\n"));
        fs::write(path, content)
            .map_err(|e| IdsError::io_error(format!("Failed to write CSV data: {e}")))
    }

    /// Generate a detailed HTML report for balance analysis
    fn generate_balance_html_report(
        &self,
        results: &BalanceResults,
        filename_prefix: Option<&str>,
    ) -> Result<(), IdsError> {
        let report_dir = self.get_dir_path(OutputDirType::Report);
        let prefix = filename_prefix.unwrap_or("balance");
        let report_path = report_dir.join(format!("{prefix}_report.html"));

        // Group variables by category
        let mut demographic_rows = String::new();
        let mut income_rows = String::new();
        let mut education_rows = String::new();
        let mut occupation_rows = String::new();
        let mut other_rows = String::new();

        // Variable tooltips for better explanation
        let variable_tooltips: HashMap<&str, &str> = [
            // Demographics
            (
                "Family Size",
                "Number of people in the family unit (ANTPERSF/ANTPERSH)",
            ),
            ("Municipality", "Municipality code (KOM)"),
            ("Family Type", "Type of family unit (FAMILIE_TYPE)"),
            ("Civil Status", "Civil/marital status (CIVST)"),
            ("Gender", "Gender of the individual (KOEN)"),
            ("Citizenship", "Citizenship/nationality (STATSB)"),
            ("Age", "Age of the individual (ALDER)"),
            (
                "Children Count",
                "Number of children in the family (ANTBOERNF/ANTBOERNH)",
            ),
            // Income
            ("Income", "Total personal income (PERINDKIALT_13)"),
            ("Wage Income", "Income from wages (LOENMV_13)"),
            ("Employment Status", "Employment status code (BESKST13)"),
            (
                "Employment Status Category",
                "Employment status category (BESKST13)",
            ),
            // Education
            ("Education Level", "Highest education level attained"),
            (
                "ISCED Level",
                "International Standard Classification of Education level",
            ),
            ("Education Years", "Years of education completed"),
            // Occupation
            (
                "SOCIO13 Code",
                "Socioeconomic classification code (SOCIO13)",
            ),
            (
                "SOCIO13 Value",
                "Socioeconomic classification numeric value (SOCIO13)",
            ),
            (
                "Classification System",
                "Classification system used for occupational coding",
            ),
            ("SOCIO", "Previous socioeconomic classification code"),
            (
                "SOCIO Category",
                "Previous socioeconomic classification category",
            ),
            (
                "SOCIO02",
                "Alternative socioeconomic classification from 2002",
            ),
            (
                "SOCIO02 Category",
                "Alternative socioeconomic classification category from 2002",
            ),
            (
                "Previous Socioeconomic Status",
                "Previous socioeconomic status (PRE_SOCIO)",
            ),
            (
                "Previous Socioeconomic Category",
                "Previous socioeconomic status category (PRE_SOCIO)",
            ),
        ]
        .iter()
        .copied()
        .collect();

        for summary in &results.summaries {
            // Determine if there's an imbalance (std_diff > 0.1)
            let row_class = if summary.std_diff.abs() > 0.1 {
                "imbalanced"
            } else {
                ""
            };

            // Get tooltip for this variable
            let tooltip = variable_tooltips
                .get(summary.variable.as_str())
                .map_or("", |&s| s);

            let row_html = format!(
                r#"<tr class="{}">
                    <td title="{}">{}</td>
                    <td>{:.4}</td>
                    <td>{:.4}</td>
                    <td>{:.4}</td>
                    <td>{:.4}</td>
                </tr>"#,
                row_class,
                tooltip,
                summary.variable,
                summary.mean_cases,
                summary.mean_controls,
                summary.std_diff,
                summary.variance_ratio
            );

            // Categorize the row based on variable name
            if summary.variable.contains("Family")
                || summary.variable.contains("Municipality")
                || summary.variable.contains("Civil Status")
                || summary.variable.contains("Gender")
                || summary.variable.contains("Citizenship")
                || summary.variable.contains("Age")
                || summary.variable.contains("Children")
            {
                demographic_rows.push_str(&row_html);
            } else if summary.variable.contains("Income") || summary.variable.contains("Employment")
            {
                income_rows.push_str(&row_html);
            } else if summary.variable.contains("Education") || summary.variable.contains("ISCED") {
                education_rows.push_str(&row_html);
            } else if summary.variable.contains("SOCIO")
                || summary.variable.contains("Classification")
                || summary.variable.contains("Socioeconomic")
            {
                occupation_rows.push_str(&row_html);
            } else {
                other_rows.push_str(&row_html);
            }
        }

        // Combine all rows with section headers
        let mut variable_rows = String::new();

        if !demographic_rows.is_empty() {
            variable_rows.push_str(
                "<tr class=\"section-header\"><th colspan=\"5\">Demographics Variables</th></tr>",
            );
            variable_rows.push_str(&demographic_rows);
        }

        if !income_rows.is_empty() {
            variable_rows.push_str(
                "<tr class=\"section-header\"><th colspan=\"5\">Income Variables</th></tr>",
            );
            variable_rows.push_str(&income_rows);
        }

        if !education_rows.is_empty() {
            variable_rows.push_str(
                "<tr class=\"section-header\"><th colspan=\"5\">Education Variables</th></tr>",
            );
            variable_rows.push_str(&education_rows);
        }

        if !occupation_rows.is_empty() {
            variable_rows.push_str(
                "<tr class=\"section-header\"><th colspan=\"5\">Occupation Variables</th></tr>",
            );
            variable_rows.push_str(&occupation_rows);
        }

        if !other_rows.is_empty() {
            variable_rows.push_str(
                "<tr class=\"section-header\"><th colspan=\"5\">Other Variables</th></tr>",
            );
            variable_rows.push_str(&other_rows);
        }

        // Calculate missing data for report
        let mut missing_data_rows = String::new();
        for (var, (case_rate, ctrl_rate)) in &results.missing_data_rates {
            missing_data_rows.push_str(&format!(
                r"<tr>
                    <td>{}</td>
                    <td>{:.2}%</td>
                    <td>{:.2}%</td>
                </tr>",
                var,
                case_rate * 100.0,
                ctrl_rate * 100.0
            ));
        }

        // Generate the HTML content
        let html_content = format!(
            r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balance Analysis Report</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            color: #333;
        }}
        .container {{
            max-width: 1200px;
            margin: 0 auto;
        }}
        header {{
            background-color: #f5f5f5;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 5px;
        }}
        h1, h2, h3 {{
            color: #2c3e50;
        }}
        h1 {{
            margin-top: 0;
        }}
        .card {{
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }}
        .info-bar {{
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }}
        th, td {{
            padding: 12px 15px;
            border-bottom: 1px solid #ddd;
            text-align: left;
        }}
        th {{
            background-color: #f2f2f2;
        }}
        tr:hover {{
            background-color: #f5f5f5;
        }}
        tr.imbalanced {{
            background-color: #fff9c4;
        }}
        tr.imbalanced:hover {{
            background-color: #fff59d;
        }}
        .summary-box {{
            background-color: #f1f8e9;
            border-left: 4px solid #7cb342;
            padding: 10px;
            margin-bottom: 20px;
        }}
        .warning-box {{
            background-color: #ffebee;
            border-left: 4px solid #e57373;
            padding: 10px;
            margin-bottom: 20px;
        }}
        a.nav-link {{
            display: inline-block;
            background-color: #3498db;
            color: white;
            padding: 8px 12px;
            text-decoration: none;
            border-radius: 5px;
            margin-right: 10px;
            font-size: 0.9em;
        }}
        a.nav-link:hover {{
            background-color: #2980b9;
        }}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Balance Analysis Report</h1>
            <div class="info-bar">
                <strong>Generated:</strong> {generated_at} |
                <strong>Version:</strong> {version}
                <div style="float: right;">
                    <a href="index.html" class="nav-link">Back to Dashboard</a>
                </div>
            </div>
        </header>

        <div class="card">
            <h2>Covariate Balance Summary</h2>
            <div class="summary-box">
                <p><strong>Analysis Overview:</strong> This report shows the balance of covariates between case and control groups.</p>
                <p><strong>Imbalance Threshold:</strong> Variables with standardized difference > 0.1 are highlighted as potentially imbalanced.</p>
                <p><strong>Register Variables:</strong> The report includes variables from BEF (demographics), IND (income), and AKM (occupation) registers.</p>
            </div>

            <div style="background-color: #f8f9fa; padding: 15px; margin: 15px 0; border-radius: 5px;">
                <h3 style="margin-top: 0;">Register Variables Legend</h3>
                <p><strong>Demographics (BEF):</strong> Family Size (ANTPERSF/ANTPERSH), Municipality (KOM), Family Type (FAMILIE_TYPE), Civil Status (CIVST), Gender (KOEN), Citizenship (STATSB), Age (ALDER), Children Count (ANTBOERNF/ANTBOERNH)</p>
                <p><strong>Income (IND):</strong> Total Income (PERINDKIALT_13), Wage Income (LOENMV_13), Employment Status (BESKST13)</p>
                <p><strong>Occupation (AKM):</strong> SOCIO13, SOCIO, SOCIO02, PRE_SOCIO</p>
                <p><em>Hover over variable names in the table below to see details about the register variables they represent.</em></p>
            </div>

            <table>
                <thead>
                    <tr>
                        <th>Variable</th>
                        <th>Mean (Cases)</th>
                        <th>Mean (Controls)</th>
                        <th>Standardized Difference</th>
                        <th>Variance Ratio</th>
                    </tr>
                </thead>
                <tbody>
                    {variable_rows}
                </tbody>
            </table>
        </div>

        <div class="card">
            <h2>Missing Data Analysis</h2>
            <table>
                <thead>
                    <tr>
                        <th>Variable</th>
                        <th>Cases Missing</th>
                        <th>Controls Missing</th>
                    </tr>
                </thead>
                <tbody>
                    {missing_data_rows}
                </tbody>
            </table>
        </div>

        <div class="card">
            <h2>Data Files</h2>
            <p>Raw data files for further analysis:</p>
            <ul>
                <li><a href="../data/balance/balance_covariate_balance.csv">Covariate Balance Data (CSV)</a></li>
                <li><a href="../data/balance/balance_missing_data_rates.csv">Missing Data Rates (CSV)</a></li>
                <li><a href="../data/balance/balance_std_differences.csv">Standardized Differences (CSV)</a></li>
            </ul>
        </div>
    </div>
</body>
</html>"#,
            generated_at = self
                .runtime_info
                .get("generated_at")
                .unwrap_or(&String::from("Unknown")),
            version = self
                .runtime_info
                .get("version")
                .unwrap_or(&String::from("Unknown")),
            variable_rows = variable_rows,
            missing_data_rows = missing_data_rows
        );

        fs::write(&report_path, html_content).map_err(|e| {
            IdsError::io_error(format!("Failed to write balance HTML report: {e}"))
        })?;

        Ok(())
    }

    /// Generate a detailed HTML report for matching analysis
    fn generate_matching_html_report(
        &self,
        matched_pairs: &[CaseWithControls],
        filename_prefix: Option<&str>,
    ) -> Result<(), IdsError> {
        let report_dir = self.get_dir_path(OutputDirType::Report);
        let prefix = filename_prefix.unwrap_or("matching");
        let report_path = report_dir.join(format!("{prefix}_report.html"));

        // Generate summary statistics
        let total_cases = matched_pairs.len();
        let cases_with_controls = matched_pairs
            .iter()
            .filter(|r| !r.controls.is_empty())
            .count();
        let total_controls: usize = matched_pairs.iter().map(|r| r.controls.len()).sum();
        let avg_controls_per_case = if total_cases > 0 {
            total_controls as f64 / total_cases as f64
        } else {
            0.0
        };

        // Calculate birth date difference statistics
        let mut birth_diffs: Vec<i64> = Vec::new();
        for record in matched_pairs {
            for control in &record.controls {
                birth_diffs.push(control.birth_date_diff);
            }
        }

        let avg_birth_diff = if birth_diffs.is_empty() {
            0.0
        } else {
            birth_diffs.iter().sum::<i64>() as f64 / birth_diffs.len() as f64
        };

        let max_birth_diff = birth_diffs.iter().copied().max().unwrap_or(0);

        // Generate case summary rows
        let mut case_summary_rows = String::new();
        for record in matched_pairs.iter().take(100) {
            // Limit to first 100 for performance
            let controls_count = record.controls.len();
            let control_info = if controls_count > 0 {
                let first_control = &record.controls[0];
                format!(
                    "{} controls, first: {} (diff: {} days)",
                    controls_count, first_control.pnr, first_control.birth_date_diff
                )
            } else {
                "No controls found".to_string()
            };

            case_summary_rows.push_str(&format!(
                r"<tr>
                    <td>{}</td>
                    <td>{}</td>
                    <td>{}</td>
                    <td>{}</td>
                    <td>{}</td>
                </tr>",
                record.case_id,
                record.case_pnr,
                record.case_birth_date,
                record.case_treatment_date,
                control_info
            ));
        }

        // Generate the HTML content
        let html_content = format!(
            r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matching Analysis Report</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            color: #333;
        }}
        .container {{
            max-width: 1200px;
            margin: 0 auto;
        }}
        header {{
            background-color: #f5f5f5;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 5px;
        }}
        h1, h2, h3 {{
            color: #2c3e50;
        }}
        h1 {{
            margin-top: 0;
        }}
        .card {{
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }}
        .info-bar {{
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }}
        .stats-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }}
        .stat-box {{
            background-color: #e3f2fd;
            border-radius: 5px;
            padding: 15px;
            text-align: center;
        }}
        .stat-value {{
            font-size: 24px;
            font-weight: bold;
            margin: 10px 0;
        }}
        .stat-label {{
            font-size: 14px;
            color: #555;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }}
        th, td {{
            padding: 12px 15px;
            border-bottom: 1px solid #ddd;
            text-align: left;
        }}
        th {{
            background-color: #f2f2f2;
        }}
        tr:hover {{
            background-color: #f5f5f5;
        }}
        .summary-box {{
            background-color: #f1f8e9;
            border-left: 4px solid #7cb342;
            padding: 10px;
            margin-bottom: 20px;
        }}
        a.nav-link {{
            display: inline-block;
            background-color: #3498db;
            color: white;
            padding: 8px 12px;
            text-decoration: none;
            border-radius: 5px;
            margin-right: 10px;
            font-size: 0.9em;
        }}
        a.nav-link:hover {{
            background-color: #2980b9;
        }}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Matching Analysis Report</h1>
            <div class="info-bar">
                <strong>Generated:</strong> {generated_at} |
                <strong>Version:</strong> {version}
                <div style="float: right;">
                    <a href="index.html" class="nav-link">Back to Dashboard</a>
                </div>
            </div>
        </header>

        <div class="card">
            <h2>Matching Statistics</h2>

            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-label">Total Cases</div>
                    <div class="stat-value">{total_cases}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Cases With Controls</div>
                    <div class="stat-value">{cases_with_controls}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Total Controls</div>
                    <div class="stat-value">{total_controls}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Avg Controls per Case</div>
                    <div class="stat-value">{avg_controls:.2}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Avg Birth Date Diff (days)</div>
                    <div class="stat-value">{avg_birth_diff:.1}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Max Birth Date Diff (days)</div>
                    <div class="stat-value">{max_birth_diff}</div>
                </div>
            </div>

            <div class="summary-box">
                <p><strong>Matching Overview:</strong> This report shows the results of matching cases to controls.</p>
                <p><strong>Note:</strong> Only the first 100 cases are shown in the table below.</p>
            </div>
        </div>

        <div class="card">
            <h2>Case Summary</h2>
            <table>
                <thead>
                    <tr>
                        <th>Case ID</th>
                        <th>Case PNR</th>
                        <th>Birth Date</th>
                        <th>Treatment Date</th>
                        <th>Controls</th>
                    </tr>
                </thead>
                <tbody>
                    {case_summary_rows}
                </tbody>
            </table>
        </div>

        <div class="card">
            <h2>Data Files</h2>
            <p>Raw data files for further analysis:</p>
            <ul>
                <li><a href="../data/matching/matching_pairs.csv">Matched Pairs Data (CSV)</a></li>
                <li><a href="../data/matching/matching_stats.csv">Matching Statistics (CSV)</a></li>
            </ul>
        </div>
    </div>
</body>
</html>"#,
            generated_at = self
                .runtime_info
                .get("generated_at")
                .unwrap_or(&String::from("Unknown")),
            version = self
                .runtime_info
                .get("version")
                .unwrap_or(&String::from("Unknown")),
            total_cases = total_cases,
            cases_with_controls = cases_with_controls,
            total_controls = total_controls,
            avg_controls = avg_controls_per_case,
            avg_birth_diff = avg_birth_diff,
            max_birth_diff = max_birth_diff,
            case_summary_rows = case_summary_rows
        );

        fs::write(&report_path, html_content).map_err(|e| {
            IdsError::io_error(format!("Failed to write matching HTML report: {e}"))
        })?;

        Ok(())
    }

    /// Generate a basic data quality report
    pub fn generate_data_quality_report(&self) -> Result<(), IdsError> {
        let report_dir = self.get_dir_path(OutputDirType::Report);
        let report_path = report_dir.join("data_quality_report.html");

        // Generate placeholder HTML
        let html_content = format!(
            r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Quality Report</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            color: #333;
        }}
        .container {{
            max-width: 1200px;
            margin: 0 auto;
        }}
        header {{
            background-color: #f5f5f5;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 5px;
        }}
        h1, h2, h3 {{
            color: #2c3e50;
        }}
        h1 {{
            margin-top: 0;
        }}
        .card {{
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }}
        .info-bar {{
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }}
        a.nav-link {{
            display: inline-block;
            background-color: #3498db;
            color: white;
            padding: 8px 12px;
            text-decoration: none;
            border-radius: 5px;
            margin-right: 10px;
            font-size: 0.9em;
        }}
        a.nav-link:hover {{
            background-color: #2980b9;
        }}
        .placeholder {{
            background-color: #f8f9fa;
            border: 1px dashed #ccc;
            padding: 20px;
            text-align: center;
            color: #777;
        }}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Data Quality Report</h1>
            <div class="info-bar">
                <strong>Generated:</strong> {generated_at} |
                <strong>Version:</strong> {version}
                <div style="float: right;">
                    <a href="index.html" class="nav-link">Back to Dashboard</a>
                </div>
            </div>
        </header>

        <div class="card">
            <h2>Data Quality Overview</h2>
            <p>This report provides an overview of data quality metrics across the datasets used for analysis.</p>

            <div class="placeholder">
                <h3>Data Quality Analysis</h3>
                <p>The detailed data quality analysis will appear here in future versions.</p>
            </div>
        </div>
    </div>
</body>
</html>"#,
            generated_at = self
                .runtime_info
                .get("generated_at")
                .unwrap_or(&String::from("Unknown")),
            version = self
                .runtime_info
                .get("version")
                .unwrap_or(&String::from("Unknown"))
        );

        fs::write(&report_path, html_content).map_err(|e| {
            IdsError::io_error(format!("Failed to write data quality HTML report: {e}"))
        })?;

        Ok(())
    }
}

/// Enum for different output directory types
#[derive(Debug, Clone, Copy)]
pub enum OutputDirType {
    Base,
    Report,
    Data,
    Plots,
    Logs,
    BalanceData,
    MatchingData,
    RegisterData,
    BalancePlots,
    MatchingPlots,
    DataQualityPlots,
}
</file>

<file path="src/lib.rs">
// Core modules
pub mod balance;
pub mod core;
pub mod data;
pub mod models;
pub mod prelude;
pub mod processing;
pub mod reporting;

// Re-exports for backward compatibility
pub use core::config::{
    generate_default_config, CovariateTypeConfig, CovariateVariableConfig, CovariatesConfig,
};
pub use core::Error as CovariateError;

// Balance checking functionality
pub use balance::{
    memory_manager, BalanceChecker, BalanceCheckerBuilder, BalanceResults, MemoryGuard, MemoryTier,
    OptimizationStrategy,
};

// Data access
pub use data::matched_pairs::loader::load_matched_pairs;
pub use models::CovariateSummary;

// Processors
pub use core::registry::CovariateProcessorRegistry;
pub use processing::{
    ConfigurableProcessor, DemographicsProcessor, EducationProcessor, IncomeProcessor,
    OccupationProcessor, ProcessorFactory,
};

// Reporting
pub use reporting::{BalanceReport, ComprehensiveReport, CsvReport};

// Re-export types we depend on for convenience
pub use types::models::{Covariate, CovariateType, CovariateValue};
pub use types::traits::{CovariateProcessor, Store, VariableType};
</file>

<file path="src/models.rs">
use chrono::NaiveDate;
use serde::{Deserialize, Serialize};
pub use types::models::{Covariate, CovariateType, CovariateValue, TimeVaryingValue};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CovariateSummary {
    pub variable: String,
    pub mean_cases: f64,
    pub mean_controls: f64,
    pub std_diff: f64,
    pub variance_ratio: f64,
}

impl CovariateSummary {
    #[must_use] pub fn new(
        variable: String,
        mean_cases: f64,
        mean_controls: f64,
        std_diff: f64,
        variance_ratio: f64,
    ) -> Self {
        Self {
            variable,
            mean_cases,
            mean_controls,
            std_diff,
            variance_ratio,
        }
    }

    #[must_use] pub fn is_balanced(&self, threshold: f64) -> bool {
        self.std_diff.abs() <= threshold
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MatchedPairDetail {
    pub case_pnr: String,
    pub control_pnrs: Vec<String>, // Changed from String to Vec<String>
    pub treatment_date: NaiveDate,
    pub variable: String,
    pub case_value: f64,
    pub control_value: f64,
    pub std_diff: f64,
}

impl MatchedPairDetail {
    #[must_use] pub fn new(
        case_pnr: String,
        control_pnrs: Vec<String>,
        treatment_date: NaiveDate,
        variable: String,
        case_value: f64,
        control_value: f64,
        std_diff: f64,
    ) -> Self {
        Self {
            case_pnr,
            control_pnrs,
            treatment_date,
            variable,
            case_value,
            control_value,
            std_diff,
        }
    }

    #[must_use] pub fn calculate_std_diff(case_value: f64, control_value: f64) -> f64 {
        let pooled_var = (case_value.powi(2) + control_value.powi(2)) / 2.0;
        if pooled_var == 0.0 {
            0.0
        } else {
            (case_value - control_value) / pooled_var.sqrt()
        }
    }
}
</file>

<file path="src/prelude.rs">
// Re-export the most commonly used types
pub use crate::core::{Error, Result};

pub use crate::core::config::{CovariateTypeConfig, CovariateVariableConfig, CovariatesConfig};

pub use crate::balance::{
    memory_manager, BalanceChecker, BalanceCheckerBuilder, BalanceResults, MemoryGuard, MemoryTier,
    OptimizationStrategy,
};

pub use crate::processing::{
    ConfigurableProcessor, DemographicsProcessor, EducationProcessor, IncomeProcessor,
    OccupationProcessor, ProcessorFactory,
};

pub use crate::data::matched_pairs::{
    load_matched_pair_records, load_matched_pairs, CaseWithControls, Control, MatchedPairRecord,
};

pub use crate::reporting::{BalanceReport, ComprehensiveReport, CsvReport};

// Re-export types from the types crate that we commonly use
pub use types::models::{Covariate, CovariateType, CovariateValue};

pub use types::traits::{CovariateProcessor, Store, VariableType};
</file>

<file path="Cargo.toml">
[package]
name = "covariates"
version = { workspace = true }
edition = { workspace = true }

[dependencies]
core = { path = "../core" }
loader = { path = "../loader" }
types = { path = "../types" }
chrono = { workspace = true }
csv = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
thiserror = { workspace = true }
log = { workspace = true }
rayon = { workspace = true }
dashmap = { workspace = true }
statrs = { workspace = true }
indicatif = { workspace = true }
rand = { workspace = true }
parking_lot = { workspace = true }
crossbeam-channel = { workspace = true }
crossbeam-utils = { workspace = true }
crossbeam-deque = { workspace = true }
num_cpus = "1.16.0"
ahash = "0.8.11"
hashbrown = { workspace = true }
once_cell = "1.19.0"
lazy_static = "1.4.0"
anyhow = { workspace = true }

[dev-dependencies]
tempfile = "3.10.1"
</file>

</files>
